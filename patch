From kim@eagain.st Mon Dec 13 15:56:31 2021
Delivered-To: alex@memoryandthought.me
Received: by 2002:a02:a1cd:0:0:0:0:0 with SMTP id o13csp5550643jah;
        Mon, 13 Dec 2021 07:56:49 -0800 (PST)
X-Google-Smtp-Source: ABdhPJx+Upwa+K7F6DLcuFnuuXvkKBt/lwTh5gsAvMgOQShtI1z7uqIR2xn663/RKDdg2VO3GM7c
X-Received: by 2002:a05:620a:14ab:: with SMTP id x11mr34151104qkj.84.1639411009287;
        Mon, 13 Dec 2021 07:56:49 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1639411009; cv=none;
        d=google.com; s=arc-20160816;
        b=twOuTYDo0A/fKqWI+UjQAlBAMWzAwK/NNimH6Inlrso7DjC9TmGlhdxMkW3C6u0K0D
         2iJJmVZ88aEMEzIaH9tIKFohbjHbDvCd7DBx0pNpxNc2bHvhXjvvZVMtZMq7R53lqZnB
         C1MKGFuSnNfG+wBXGhF7znhcKDE4hLE22QMNMa+v4tkXzEtOyefKeVE8oppqdinTq6ag
         b/QX2hjzn0xsIrqegPJJaFl43qstGDLvNVHuGnGymXzOg01f6/D/fLk8wrrqA2Y2coeM
         2GpdAt4lGsW1JDRN+gU/Rj/BrbQcSIl81c/o9Cm5QAlzHksiMPJI/tQA8XZdeQAOdvA6
         FIOg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=sender:list-id:list-post:archived-at:list-archive:list-subscribe
         :list-unsubscribe:content-transfer-encoding:mime-version:message-id
         :date:subject:cc:to:from:dkim-signature:dkim-signature;
        bh=604W+LlpxjNEKbYRT5QVyX8hna7xWM8KfmPthQHyVu0=;
        b=NhfT8HkJQhTStP2NetKWMxOXKNz6DkXXheR8gsw8wkJCEEX2lqzWAaWHYM6z7gkKL3
         m1RsVmlOjmcxfyj3DoaUNDyzcCAguDP+BUuJuvxaQRH1VNdsj/vox7EWhmhq0fqgCKou
         Fc5wwOmFIZLo0HfUMPfQ0ZTphBApzqaCBbDRlCd3a37LOtuiLB7+vBhDaD13SS/mXoM+
         7dtEjWHT4asF3DDcttHDo3qlFcoZke0RAGcFaFf/+HbnHqqlhxOaCQMfb9isHINH67VT
         cSt2CaBz9Cl0coudgDXpDrCUTPi+21KqBtvRN0g/QAsWsY9dKQEsoSAR3ugrvUOJjN0R
         TwSw==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=ISW9uvUV;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=HVycmfTA;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Return-Path: <lists@sr.ht>
Received: from mail-b.sr.ht (mail-b.sr.ht. [173.195.146.151])
        by mx.google.com with ESMTPS id n16si11676525qtx.471.2021.12.13.07.56.48
        for <alex@memoryandthought.me>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Mon, 13 Dec 2021 07:56:48 -0800 (PST)
Received-SPF: pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) client-ip=173.195.146.151;
Authentication-Results: mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=ISW9uvUV;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=HVycmfTA;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Authentication-Results: mail-b.sr.ht; dkim=pass header.d=eagain.st header.i=@eagain.st
DKIM-Signature: a=rsa-sha256; bh=qEV2xpxuXwg7M4WDQjVCzYLywRRoxqMaTGVO1ZeO0qg=;
 c=simple/simple; d=lists.sr.ht;
 h=From:To:Cc:Subject:Date:List-Unsubscribe:List-Subscribe:List-Archive:List-Post:List-ID;
 q=dns/txt; s=srht; t=1639411008; v=1;
 b=ISW9uvUVTy/Cfm0Q+JY9TIN96W1SvCPGa0hGJqRJCJXGQoHBTbXHrhghbcmx+EyJEjwzGc1g
 DNXiv4LZ2hYBd/q7+qwK4tZf9hxn1F9RbRrEWIvFVU/HN2bm+Zjtlyo0uPx23Vw3cyCtgZf2yLy
 JSOn7UgUK4O2Qiu8RwC4IEw9Lgljtdc0nQOGo+8kg4PBzlfG/+TThkBg9heX9s+cz1yMB0zp1Zq
 SjkBVe8NLsdT2q2Jpp6+KErPLKUocaB4h10tZEViVfo7w/NT0NGh0+kEKVnwDuCUHwCfvSwtyUz
 6AWLT+kZxyDSUV8a6bfyxRH4DOxVsK3aC3dC5QW6oBiCA==
Received: from lists.my.domain (unknown [173.195.146.144])
	by mail-b.sr.ht (Postfix) with ESMTPSA id 29A2B11EF49
	for <alex@memoryandthought.me>; Mon, 13 Dec 2021 15:56:48 +0000 (UTC)
Received: from out0.migadu.com (out0.migadu.com [94.23.1.103])
	by mail-b.sr.ht (Postfix) with ESMTPS id 95B8D11EF49
	for <~radicle-link/dev@lists.sr.ht>; Mon, 13 Dec 2021 15:56:43 +0000 (UTC)
X-Report-Abuse: Please report any abuse attempt to abuse@migadu.com and include these headers.
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=eagain.st; s=key1;
	t=1639411001;
	h=from:from:reply-to:subject:subject:date:date:message-id:message-id:
	 to:to:cc:cc:mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding;
	bh=604W+LlpxjNEKbYRT5QVyX8hna7xWM8KfmPthQHyVu0=;
	b=HVycmfTAfu/xMIdRd123zvrXD5aD+/rEq/RbXjJItEyb/V3zfWDG51XmvbsBcdKI1hVPcJ
	2Ia1vae/zKfCWvAFVw1xErEwX/Tmas4wFP/ukQ6OwBEmKbwETAcOx/LmR/1WMY+FmJu2Zx
	nktCrUnaD2QKP+IY3QV1h/vLq1nOLgU=
From: Kim Altintop <kim@eagain.st>
To: ~radicle-link/dev@lists.sr.ht
Cc: Kim Altintop <kim@eagain.st>
Subject: [PATCH radicle-link] Stable Rust
Date: Mon, 13 Dec 2021 16:56:31 +0100
Message-Id: <20211213155631.182523-1-kim@eagain.st>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Migadu-Flow: FLOW_OUT
X-Migadu-Auth-User: kim@eagain.st
X-Sourcehut-Patchset-Status: PROPOSED
List-Unsubscribe: <mailto:~radicle-link/dev+unsubscribe@lists.sr.ht?subject=unsubscribe>
List-Subscribe: <mailto:~radicle-link/dev+subscribe@lists.sr.ht?subject=subscribe>
List-Archive: <https://lists.sr.ht/~radicle-link/dev>
Archived-At: <https://lists.sr.ht/~radicle-link/dev/%3C20211213155631.182523-1-kim%40eagain.st%3E>
List-Post: <mailto:~radicle-link/dev@lists.sr.ht>
List-ID: ~radicle-link/dev <~radicle-link/dev.lists.sr.ht>
Sender: ~radicle-link/dev <~radicle-link/dev@lists.sr.ht>

Make all crates compile under stable rust.

A number of `std` features we've been using were either stabilised, or
are unlikely to ever be stabilised. Also GATs don't seem to ever arrive
in a shape or form comprehensible to mere mortals. So let's stop chasing
and reformulate all code to compile under stable.

Note that:

- there does not seem to be a workaround for the `backtrace` feature

  This was used in one place in the `daemon` crate to manually add
  backtrace information to an error message, which may or may not be
  that useful. Executable crates using `anyhow` at the top level should
  still get backtrace information, although this may require to enable
  `anyhow`'s `backtrace` feature.

- a `Try` trait is provided via `radicle-std-ext`

  This will probably not work with `?` desugaring, but we're not using
  that at the moment. The "real" Try trait can be enabled using the
  feature `nightly` when a nightly toolchain is used. Note that
  `nightly` was chosen over `unstable`, as we may want to use the latter
  for our own unstable features at some point.

- the never type (`!`) is provided as `Void` from `radicle-std-ext`

  Regrettably, the never type is one of those features which are
  unlikely to be stabilised anytime soon. We alias `Void` to
  `Infallible` however, so in case it _does_ get stabilised we'll get
  the actual thing and not an incompatible type.

- our `rustfmt` rules require nightly

  Build scripts have been adjusted to accomodate for that, but note that
  editor hooks and such may need to be adjusted by contributors.

- stable clippy has very different opinions

  Sorry for the noise.

- specifically, box patterns is marked "perma-unstable"

  I have thus opted to ignore all lints about large enum variants for
  error types and use unboxed values. Pattern matching on boxes is
  rather painful, so it might be good to review errors for whether they
  are actually meant to be scrutinized, and convert variants which
  aren't to trait objects.

Fixes #476
Signed-off-by: Kim Altintop <kim@eagain.st>
---

The Fed recently raised the interest rate on novelty budgets in expectation of
inflation. In other news Amazon hired Guy Steele to fix the distateful syntax of
Rust by requiring source code to be typeset in LaTeX.

Published-As: https://git.sr.ht/~kim/radicle-link/refs/patches/stable-rust/v1

 .builds/linux-x86_64.yml                      |   8 +-
 .github/workflows/ci.yaml                     |  42 ++++-
 cob/Cargo.toml                                |   5 -
 cob/src/lib.rs                                |   4 +-
 cob/src/refs_storage.rs                       |  10 +-
 daemon/src/lib.rs                             |   1 -
 daemon/src/peer.rs                            |   2 +-
 daemon/src/peer/run_state.rs                  |   2 +-
 daemon/src/peer/run_state/input.rs            |   3 +-
 daemon/src/request/waiting_room.rs            |   5 +-
 daemon/src/state.rs                           |   4 +-
 e2e/Cargo.toml                                |   3 +
 e2e/src/bin/ephemeral-peer.rs                 |   7 +-
 git-helpers/src/remote_helper.rs              |   7 +-
 librad/Cargo.toml                             |   5 -
 librad/src/git/fetch/specs.rs                 |   2 +-
 librad/src/git/identities/any.rs              |   3 +-
 librad/src/git/identities/relations.rs        |   1 +
 librad/src/git/include.rs                     |   1 +
 librad/src/git/storage.rs                     |   3 +-
 librad/src/git/storage/config.rs              |   6 +-
 librad/src/git/storage/pool.rs                |   3 +-
 librad/src/git/storage/read.rs                |   4 +-
 librad/src/lib.rs                             |  17 +-
 librad/src/net/peer.rs                        |  22 ++-
 librad/src/net/peer/storage.rs                |  10 +-
 librad/src/net/protocol.rs                    |   9 +-
 librad/src/net/protocol/cache.rs              |   7 +-
 librad/src/net/protocol/event.rs              |   4 +-
 librad/src/net/protocol/io/connections.rs     |  16 +-
 librad/src/net/protocol/state.rs              |   3 +-
 librad/src/net/quic/endpoint.rs               |   4 +-
 librad/src/net/replication/v3/context.rs      |  60 +++---
 link-async/Cargo.toml                         |  11 +-
 link-async/src/lib.rs                         |   5 +-
 link-async/src/tasks.rs                       |  13 +-
 link-canonical-derive/Cargo.toml              |   3 -
 link-crypto/Cargo.toml                        |   2 +-
 link-crypto/src/lib.rs                        |   1 -
 link-crypto/src/signer.rs                     |  15 +-
 link-git/src/lib.rs                           |   2 -
 link-identities/src/delegation/direct.rs      |   3 +-
 link-identities/src/lib.rs                    |   5 +-
 link-identities/src/urn.rs                    |   4 +-
 link-replication/Cargo.toml                   |   3 +
 link-replication/src/eval/rad.rs              |   2 +-
 link-replication/src/fetch.rs                 |   2 +-
 link-replication/src/io/refdb.rs              |  36 ++--
 link-replication/src/lib.rs                   |   9 +-
 link-replication/src/peek/clone.rs            |   4 +-
 link-replication/src/refdb.rs                 |  21 ++-
 link-replication/src/refdb/mem.rs             |  45 ++---
 link-replication/src/state.rs                 |  32 ++--
 link-replication/src/transmit.rs              |   1 +
 link-replication/src/validation.rs            |  19 +-
 macros/Cargo.toml                             |   1 +
 macros/src/lib.rs                             |  20 +-
 node-lib/src/lib.rs                           |   2 -
 node-lib/src/protocol.rs                      |   2 +-
 node-lib/src/tracking.rs                      |  79 ++++----
 rad-clib/Cargo.toml                           |   1 -
 rad-exe/src/cli/main.rs                       |   5 +-
 rad-exe/src/lib.rs                            |   2 -
 rad-identities/Cargo.toml                     |   3 +
 rad-identities/src/git/existing.rs            |   3 +-
 rad-identities/src/git/include.rs             |   1 +
 rad-identities/src/git/new.rs                 |   6 +-
 rad-identities/src/lib.rs                     |   6 +-
 rad-identities/src/rad_refs.rs                |   1 +
 rad-identities/src/tracking.rs                |   1 +
 rust-toolchain                                |   1 -
 scripts/ci/advisory                           |  11 +-
 scripts/ci/build-bins                         |   3 +-
 scripts/ci/build-test                         |   6 +-
 scripts/ci/clippy                             |  11 --
 scripts/ci/docs                               |   5 +-
 scripts/ci/fmt                                |   4 +
 scripts/ci/lint                               |  10 +
 scripts/ci/run                                |   3 +-
 scripts/ci/test-fast                          |   5 +-
 std-ext/Cargo.toml                            |   6 +-
 std-ext/src/iter.rs                           |  59 ------
 std-ext/src/lib.rs                            |  15 +-
 std-ext/src/ops.rs                            | 173 ++++++++++++++++++
 test/Cargo.toml                               |   5 +-
 test/src/lib.rs                               |   9 +-
 test/src/librad/git.rs                        |   6 +-
 test/src/ssh.rs                               |   6 +-
 test/src/test/integration/daemon/gossip.rs    |  20 +-
 .../test/integration/daemon/replication.rs    |   1 -
 .../test/integration/daemon/working_copy.rs   |   4 +-
 .../librad/scenario/collaboration.rs          |   2 +-
 .../librad/scenario/collaborative_objects.rs  |   2 +-
 .../integration/librad/scenario/menage.rs     |   4 +-
 .../librad/scenario/tracked_references.rs     |   2 +-
 .../librad/scenario/updated_delegate.rs       |   2 +-
 .../librad/scenario/working_copy.rs           |   2 +-
 .../test/integration/librad/smoke/clone.rs    |   4 +-
 .../test/integration/librad/smoke/gossip.rs   |   4 +-
 .../integration/librad/smoke/interrogation.rs |   2 +-
 .../integration/librad/smoke/regression.rs    |   2 +-
 .../properties/librad/identities/generic.rs   |   8 +-
 .../unit/librad/identities/git/project.rs     |   4 +-
 test/src/test/unit/librad/net/upgrade.rs      |   1 -
 .../test/unit/rad_identities/git/checkout.rs  |   2 +-
 105 files changed, 584 insertions(+), 474 deletions(-)
 delete mode 100644 rust-toolchain
 delete mode 100755 scripts/ci/clippy
 create mode 100755 scripts/ci/fmt
 create mode 100755 scripts/ci/lint
 delete mode 100644 std-ext/src/iter.rs
 create mode 100644 std-ext/src/ops.rs

diff --git a/.builds/linux-x86_64.yml b/.builds/linux-x86_64.yml
index 98b345a4..f43f2bf8 100644
--- a/.builds/linux-x86_64.yml
+++ b/.builds/linux-x86_64.yml
@@ -6,8 +6,7 @@ sources:
   - https://git.sr.ht/~radicle-link/radicle-link
 tasks:
   - setup: |
-      toolchain=$(cat radicle-link/rust-toolchain)
-      rustup toolchain install "$toolchain" \
+      rustup toolchain install stable nightly \
           --profile minimal --component clippy --component rustfmt

       deny_version="0.11.0"
@@ -25,9 +24,12 @@ tasks:

       cd radicle-link/
       cargo fetch
+  - fmt: |
+      cd radicle-link/
+      ./scripts/ci/fmt
   - lint: |
       cd radicle-link/
-      ./scripts/ci/clippy
+      ./scripts/ci/lint
   - advisories: |
       cd radicle-link/
       cargo deny check advisories ||:
diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml
index 21c74653..38666176 100644
--- a/.github/workflows/ci.yaml
+++ b/.github/workflows/ci.yaml
@@ -1,6 +1,19 @@
 name: ci
 on: [push, pull_request]
 jobs:
+  fmt:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: nightly
+          components: rustfmt
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/fmt
+        shell: bash
+
   lint:
     runs-on: ubuntu-latest
     steps:
@@ -8,9 +21,22 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
+          components: clippy
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/lint
+        shell: bash
+
+  docs:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
-      - run: ./scripts/ci/clippy
+      - run: ./scripts/ci/docs
         shell: bash

   cargo-deny:
@@ -29,12 +55,18 @@ jobs:

   linux:
     runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        toolchain:
+          - stable
+          - nightly
+    continue-on-error: ${{ matrix.toolchain == 'nightly' }}
     steps:
       - uses: actions/checkout@master
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: ${{ matrix.toolchain }}
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -48,7 +80,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -63,7 +95,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/test-fast
         shell: bash
diff --git a/cob/Cargo.toml b/cob/Cargo.toml
index 47aacac9..70867d03 100644
--- a/cob/Cargo.toml
+++ b/cob/Cargo.toml
@@ -51,8 +51,3 @@ path = "../git-ext"
 [dependencies.automerge]
 git = "https://github.com/automerge/automerge-rs.git"
 rev = "e72571962b51c2f0726fb534890ef3b4f7c74dfc"
-
-
-[dev-dependencies]
-rand = "0.8"
-env_logger = "0"
diff --git a/cob/src/lib.rs b/cob/src/lib.rs
index 9e58dfce..d19d0976 100644
--- a/cob/src/lib.rs
+++ b/cob/src/lib.rs
@@ -170,7 +170,7 @@ impl TypeName {
     /// A string representation of the typename which will match the typename in
     /// regular expressions. This primarily escapes periods
     pub fn regex_safe_string(&self) -> String {
-        self.0.replace(".", "\\.")
+        self.0.replace('.', "\\.")
     }
 }

@@ -265,6 +265,7 @@ impl From<&git2::Oid> for ObjectId {
 pub struct CollaborativeObject {
     /// The identity (person or project) this collaborative object is authorized
     /// with respect to
+    #[allow(unused)]
     authorizing_identity_urn: Urn,
     /// The typename of this object
     typename: TypeName,
@@ -273,6 +274,7 @@ pub struct CollaborativeObject {
     /// The id of the object
     id: ObjectId,
     /// The schema any changes to this object must respect
+    #[allow(unused)]
     schema: Schema,
 }

diff --git a/cob/src/refs_storage.rs b/cob/src/refs_storage.rs
index ee9786fe..ef775363 100644
--- a/cob/src/refs_storage.rs
+++ b/cob/src/refs_storage.rs
@@ -11,6 +11,7 @@ use git2::Reference;
 use link_identities::git::Urn;

 /// References to the tips of a collaborative object
+#[derive(Default)]
 pub struct ObjectRefs<'a> {
     /// The reference (if any) which represents the tip of the changes authored
     /// by the identity which owns the underlying storage
@@ -19,15 +20,6 @@ pub struct ObjectRefs<'a> {
     pub remote: Vec<Reference<'a>>,
 }

-impl<'a> Default for ObjectRefs<'a> {
-    fn default() -> Self {
-        ObjectRefs {
-            local: None,
-            remote: Vec::new(),
-        }
-    }
-}
-
 impl<'a> std::fmt::Debug for ObjectRefs<'a> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         let local_dbg = self
diff --git a/daemon/src/lib.rs b/daemon/src/lib.rs
index 7f0a4c2d..dd9b1162 100644
--- a/daemon/src/lib.rs
+++ b/daemon/src/lib.rs
@@ -27,7 +27,6 @@
     clippy::similar_names,
     clippy::too_many_lines
 )]
-#![feature(hash_set_entry, never_type, backtrace)]

 #[cfg(test)]
 extern crate assert_matches;
diff --git a/daemon/src/peer.rs b/daemon/src/peer.rs
index eabfc760..81392b1f 100644
--- a/daemon/src/peer.rs
+++ b/daemon/src/peer.rs
@@ -234,7 +234,7 @@ where
                                 Err(error) => {
                                     tracing::error!(?error, "accept error");
                                 },
-                                Ok(never) => never,
+                                Ok(never) => unreachable!("absurd: {}", never),
                             };
                         },
                         Err(e) => {
diff --git a/daemon/src/peer/run_state.rs b/daemon/src/peer/run_state.rs
index d5a4d276..e1024f13 100644
--- a/daemon/src/peer/run_state.rs
+++ b/daemon/src/peer/run_state.rs
@@ -213,7 +213,7 @@ impl RunState {
                 if !self.stats.connected_peers.is_empty() && self.stats.membership_active > 0 =>
             {
                 vec![Command::Announce]
-            }
+            },
             _ => vec![],
         }
     }
diff --git a/daemon/src/peer/run_state/input.rs b/daemon/src/peer/run_state/input.rs
index 185718ae..5b4234c2 100644
--- a/daemon/src/peer/run_state/input.rs
+++ b/daemon/src/peer/run_state/input.rs
@@ -5,9 +5,8 @@

 use std::{net::SocketAddr, time::SystemTime};

-use tokio::sync::oneshot;
-
 use librad::{git::Urn, net, net::peer::ProtocolEvent, PeerId};
+use tokio::sync::oneshot;

 use crate::{
     peer::announcement,
diff --git a/daemon/src/request/waiting_room.rs b/daemon/src/request/waiting_room.rs
index abf636de..0b4df62e 100644
--- a/daemon/src/request/waiting_room.rs
+++ b/daemon/src/request/waiting_room.rs
@@ -330,11 +330,8 @@ impl<T, D> WaitingRoom<T, D> {
         T: Clone,
     {
         #[allow(clippy::non_ascii_literal)]
-        let mut reason_str = anyhow::Chain::new(reason.as_ref())
+        let reason_str = anyhow::Chain::new(reason.as_ref())
             .fold("".to_string(), |acc, e| format!("{} той {}", acc, e));
-        if let Some(bt) = reason.backtrace() {
-            reason_str.push_str(&bt.to_string());
-        }
         self.transition(
             |request| match request {
                 SomeRequest::Cloning(request) => Some(request),
diff --git a/daemon/src/state.rs b/daemon/src/state.rs
index dbcd6815..9ab2fb3d 100644
--- a/daemon/src/state.rs
+++ b/daemon/src/state.rs
@@ -80,9 +80,7 @@ pub async fn default_owner<S>(peer: &Peer<S>) -> Result<Option<LocalIdentity>, E
 where
     S: Clone + Signer,
 {
-    Ok(peer
-        .using_storage(move |store| local::default(store))
-        .await??)
+    Ok(peer.using_storage(local::default).await??)
 }

 /// Set the default owner for this `PeerApi`.
diff --git a/e2e/Cargo.toml b/e2e/Cargo.toml
index 9de75e70..ea4cdf27 100644
--- a/e2e/Cargo.toml
+++ b/e2e/Cargo.toml
@@ -22,6 +22,9 @@ tracing = "0.1"
 [dependencies.librad]
 path = "../librad"

+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.1"
 features = ["rt-multi-thread", "macros"]
diff --git a/e2e/src/bin/ephemeral-peer.rs b/e2e/src/bin/ephemeral-peer.rs
index 09b53520..0c5298c5 100644
--- a/e2e/src/bin/ephemeral-peer.rs
+++ b/e2e/src/bin/ephemeral-peer.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(never_type)]
-
 use std::{
     net::{SocketAddr, ToSocketAddrs},
     panic,
@@ -33,6 +31,7 @@ use librad::{
     SecretKey,
 };
 use radicle_link_e2e::logging;
+use radicle_std_ext::Void;
 use tempfile::tempdir;
 use tokio::task::JoinError;

@@ -201,7 +200,7 @@ where
     }
 }

-async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
+async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<Void> {
     loop {
         tokio::time::sleep(Duration::from_secs(10)).await;
         let stats = peer.stats().await;
@@ -209,7 +208,7 @@ async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
     }
 }

-async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<!> {
+async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<Void> {
     tracing::debug!("stats collector");

     let peer_id_str = peer.peer_id().to_string();
diff --git a/git-helpers/src/remote_helper.rs b/git-helpers/src/remote_helper.rs
index 68e25820..067ee597 100644
--- a/git-helpers/src/remote_helper.rs
+++ b/git-helpers/src/remote_helper.rs
@@ -30,17 +30,12 @@ use librad::{

 use crate::credential;

+#[derive(Default)]
 pub struct Config {
     /// Signer for radicle artifacts created by pushes.
     pub signer: Option<BoxedSigner>,
 }

-impl Default for Config {
-    fn default() -> Self {
-        Self { signer: None }
-    }
-}
-
 // FIXME: this should be defined elsewhere to be consistent between applications
 const SECRET_KEY_FILE: &str = "librad.key";

diff --git a/librad/Cargo.toml b/librad/Cargo.toml
index 7de4f51c..cd09a9f2 100644
--- a/librad/Cargo.toml
+++ b/librad/Cargo.toml
@@ -45,7 +45,6 @@ percent-encoding = "2"
 picky-asn1 = "0.3.2"
 picky-asn1-der = "0.2.5"
 picky-asn1-x509 = "0.6.0"
-priority-queue = "1.0"
 rand = "0.8"
 rand_pcg = "0.3.1"
 regex = "1.3"
@@ -142,10 +141,6 @@ features = ["derive"]
 version = "1.13.1"
 features = ["rt-multi-thread", "net", "time"]

-[dependencies.tokio-util]
-version = "0.6"
-features = ["compat"]
-
 [dependencies.url]
 version = "2.1"
 features = ["serde"]
diff --git a/librad/src/git/fetch/specs.rs b/librad/src/git/fetch/specs.rs
index e0b220fa..8f05f4d4 100644
--- a/librad/src/git/fetch/specs.rs
+++ b/librad/src/git/fetch/specs.rs
@@ -346,7 +346,7 @@ pub mod refspecs {
                     }
                 };

-                targets_match.then_some({
+                targets_match.then(|| {
                     let dst = Reference {
                         remote: Some(tracked_peer.clone()),
                         category,
diff --git a/librad/src/git/identities/any.rs b/librad/src/git/identities/any.rs
index ecaee69f..5525dcb2 100644
--- a/librad/src/git/identities/any.rs
+++ b/librad/src/git/identities/any.rs
@@ -7,6 +7,7 @@ use std::convert::TryFrom;

 use git_ext::is_not_found_err;
 use itertools::Itertools as _;
+use std_ext::Void;

 use super::{
     super::{
@@ -102,7 +103,7 @@ where
     Xor::try_from_iter(list_urns(storage)?.map_ok(SomeUrn::from))
 }

-fn identities<S>(storage: &S) -> Identities<!>
+fn identities<S>(storage: &S) -> Identities<Void>
 where
     S: AsRef<storage::ReadOnly>,
 {
diff --git a/librad/src/git/identities/relations.rs b/librad/src/git/identities/relations.rs
index fa2621bf..0e23c288 100644
--- a/librad/src/git/identities/relations.rs
+++ b/librad/src/git/identities/relations.rs
@@ -23,6 +23,7 @@ use crate::{
 };

 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/librad/src/git/include.rs b/librad/src/git/include.rs
index e67dcdf2..8384ce6e 100644
--- a/librad/src/git/include.rs
+++ b/librad/src/git/include.rs
@@ -24,6 +24,7 @@ pub const GIT_CONFIG_PATH_KEY: &str = "include.path";

 #[derive(Debug, thiserror::Error)]
 #[non_exhaustive]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Io(#[from] io::Error),
diff --git a/librad/src/git/storage.rs b/librad/src/git/storage.rs
index 5fb93956..de021b16 100644
--- a/librad/src/git/storage.rs
+++ b/librad/src/git/storage.rs
@@ -14,6 +14,7 @@ use std::{
 use crypto::{BoxedSigner, SomeSigner};
 use git2::string_array::StringArray;
 use git_ext::{self as ext, is_not_found_err};
+use std_ext::Void;

 use crate::{
     collaborative_objects::CollaborativeObjects,
@@ -178,7 +179,7 @@ impl Storage {
         Config::try_from(self)
     }

-    pub fn config_readonly(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config_readonly(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(self.as_raw())?)
     }

diff --git a/librad/src/git/storage/config.rs b/librad/src/git/storage/config.rs
index e2d1711f..a0ba66ce 100644
--- a/librad/src/git/storage/config.rs
+++ b/librad/src/git/storage/config.rs
@@ -9,7 +9,7 @@ use std::{convert::TryFrom, io, marker::PhantomData, path::PathBuf};

 use crypto::BoxedSigner;
 use git_ext::{self as ext, is_not_found_err};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;
 use thiserror::Error;

 use super::{super::identities::local::LocalIdentity, Storage};
@@ -73,7 +73,7 @@ impl<'a> TryFrom<&'a Storage> for Config<'a, BoxedSigner> {
     }
 }

-impl TryFrom<&git2::Repository> for Config<'_, PhantomData<!>> {
+impl TryFrom<&git2::Repository> for Config<'_, PhantomData<Void>> {
     type Error = git2::Error;

     fn try_from(repo: &git2::Repository) -> Result<Self, Self::Error> {
@@ -210,7 +210,7 @@ impl<S> Config<'_, S> {
     }
 }

-impl Config<'_, PhantomData<!>> {
+impl Config<'_, PhantomData<Void>> {
     pub fn readonly(repo: &git2::Repository) -> Result<Self, git2::Error> {
         Self::try_from(repo)
     }
diff --git a/librad/src/git/storage/pool.rs b/librad/src/git/storage/pool.rs
index 32a9e8e4..77faa8d4 100644
--- a/librad/src/git/storage/pool.rs
+++ b/librad/src/git/storage/pool.rs
@@ -11,6 +11,7 @@ use std::{

 use deadpool::managed::{self, Manager, Object, RecycleResult};
 use parking_lot::RwLock;
+use std_ext::Void;
 use thiserror::Error;

 use super::{error, read, ReadOnly, Storage};
@@ -105,7 +106,7 @@ pub struct Config<W> {
     write: W,
 }

-pub type ReadConfig = Config<PhantomData<!>>;
+pub type ReadConfig = Config<PhantomData<Void>>;
 pub type ReadWriteConfig<S> = Config<Write<S>>;

 impl ReadConfig {
diff --git a/librad/src/git/storage/read.rs b/librad/src/git/storage/read.rs
index 39a33cdb..38dec400 100644
--- a/librad/src/git/storage/read.rs
+++ b/librad/src/git/storage/read.rs
@@ -10,7 +10,7 @@ use thiserror::Error;

 use git2::string_array::StringArray;
 use git_ext::{self as ext, blob, is_not_found_err, RefLike, RefspecPattern};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;

 use crate::{
     git::types::{reference, Many, One, Reference},
@@ -196,7 +196,7 @@ impl ReadOnly {
     /// 3. The SHA of the tag was not the same as the resolved reference
     /// 4. The `oid` was the [`zero`][`git2::Oid::zero`] SHA.

-    pub fn config(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(&self.backend)?)
     }

diff --git a/librad/src/lib.rs b/librad/src/lib.rs
index 92b7a65f..513abb28 100644
--- a/librad/src/lib.rs
+++ b/librad/src/lib.rs
@@ -3,22 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![allow(private_intra_doc_links)]
-#![allow(incomplete_features)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]
-#![feature(backtrace)]
-#![feature(bool_to_option)]
-#![feature(box_patterns)]
-#![feature(btree_drain_filter)]
-#![feature(control_flow_enum)]
-#![feature(core_intrinsics)]
-#![feature(drain_filter)]
-#![feature(generic_associated_types)]
-#![feature(ip)]
-#![feature(never_type)]
-#![feature(try_trait_v2)]
+#![deny(rustdoc::broken_intra_doc_links)]

 #[macro_use]
 extern crate async_trait;
diff --git a/librad/src/net/peer.rs b/librad/src/net/peer.rs
index 6ca2b3b8..a9af048e 100644
--- a/librad/src/net/peer.rs
+++ b/librad/src/net/peer.rs
@@ -131,6 +131,7 @@ where
             pool,
             caches.urns.clone(),
             repl.clone(),
+            #[cfg(feature = "replication-v3")]
             phone.clone(),
         );
         let user_store = git::storage::Pool::new(
@@ -192,15 +193,17 @@ where
                     .map_err(|_| "network reconnect")
                     .try_filter_map(move |event| {
                         let provider = match event {
-                            Upstream::Gossip(box Gossip::Put {
-                                provider,
-                                payload:
-                                    gossip::Payload {
-                                        urn: payload_urn, ..
-                                    },
-                                ..
-                            }) if payload_urn == urn => Some(provider),
-
+                            Upstream::Gossip(gossip) => match *gossip {
+                                Gossip::Put {
+                                    provider,
+                                    payload:
+                                        gossip::Payload {
+                                            urn: payload_urn, ..
+                                        },
+                                    ..
+                                } if payload_urn == urn => Some(provider),
+                                _ => None,
+                            },
                             _ => None,
                         };
                         future::ok(provider)
@@ -346,7 +349,6 @@ where
             self.phone.clone(),
             self.config.protocol.clone(),
             self.config.signer.clone(),
-            self.repl.clone(),
             self.peer_store.clone(),
             self.caches.clone(),
         )
diff --git a/librad/src/net/peer/storage.rs b/librad/src/net/peer/storage.rs
index f176926b..12b97c56 100644
--- a/librad/src/net/peer/storage.rs
+++ b/librad/src/net/peer/storage.rs
@@ -14,6 +14,8 @@ use link_async::Spawner;
 use nonzero_ext::nonzero;
 use parking_lot::RwLock;

+#[cfg(feature = "replication-v3")]
+use crate::net::protocol::TinCans;
 use crate::{
     git::{
         storage::{self, Pool, PoolError, PooledRef, ReadOnlyStorage as _},
@@ -22,7 +24,7 @@ use crate::{
     },
     identities::urn,
     net::{
-        protocol::{broadcast, cache, gossip, TinCans},
+        protocol::{broadcast, cache, gossip},
         replication::{self, Replication},
     },
     rate_limit::{Keyed, RateLimiter},
@@ -41,13 +43,13 @@ type SeenFilter = StableBloomFilter<DefaultBuildHashKernels<RandomState>>;

 #[derive(Clone)]
 pub struct Storage {
-    conf: Config,
     pool: Pool<storage::Storage>,
     urns: cache::urns::Filter,
     seen: Arc<RwLock<SeenFilter>>,
     rate: Arc<RateLimiter<Keyed<(PeerId, Urn)>>>,
     exec: Arc<Spawner>,
     repl: Replication,
+    #[cfg(feature = "replication-v3")]
     tins: TinCans,
 }

@@ -58,10 +60,9 @@ impl Storage {
         pool: Pool<storage::Storage>,
         urns: cache::urns::Filter,
         repl: Replication,
-        tins: TinCans,
+        #[cfg(feature = "replication-v3")] tins: TinCans,
     ) -> Self {
         Self {
-            conf,
             pool,
             urns,
             // TODO: parameters pulled out of thin air
@@ -77,6 +78,7 @@ impl Storage {
             )),
             exec,
             repl,
+            #[cfg(feature = "replication-v3")]
             tins,
         }
     }
diff --git a/librad/src/net/protocol.rs b/librad/src/net/protocol.rs
index 8b5c1699..c35732d6 100644
--- a/librad/src/net/protocol.rs
+++ b/librad/src/net/protocol.rs
@@ -11,6 +11,7 @@ use link_async::Spawner;
 use nonempty::NonEmpty;
 use nonzero_ext::nonzero;
 use rand_pcg::Pcg64Mcg;
+use std_ext::Void;
 use tracing::Instrument as _;

 use super::{
@@ -21,7 +22,7 @@ use super::{
 };
 use crate::{
     git::storage,
-    net::replication::{self, Replication},
+    net::replication,
     paths::Paths,
     rate_limit::RateLimiter,
     PeerId,
@@ -122,7 +123,7 @@ impl<S> Bound<S> {
         disco: D,
     ) -> (
         impl FnOnce(),
-        impl Future<Output = Result<!, io::error::Accept>>,
+        impl Future<Output = Result<Void, io::error::Accept>>,
     )
     where
         S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
@@ -151,7 +152,6 @@ pub async fn bind<Sign, Store>(
     phone: TinCans,
     config: Config,
     signer: Sign,
-    replication: Replication,
     storage: Store,
     caches: cache::Caches,
 ) -> Result<Bound<Store>, error::Bootstrap>
@@ -186,7 +186,6 @@ where
         endpoint,
         membership,
         storage,
-        replication,
         phone: phone.clone(),
         config: StateConfig {
             paths: Arc::new(config.paths),
@@ -218,7 +217,7 @@ pub fn accept<Store, Disco>(
     disco: Disco,
 ) -> (
     impl FnOnce(),
-    impl Future<Output = Result<!, io::error::Accept>>,
+    impl Future<Output = Result<Void, io::error::Accept>>,
 )
 where
     Store: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
diff --git a/librad/src/net/protocol/cache.rs b/librad/src/net/protocol/cache.rs
index d42a37f2..93c0205b 100644
--- a/librad/src/net/protocol/cache.rs
+++ b/librad/src/net/protocol/cache.rs
@@ -31,6 +31,7 @@ pub mod urns {

     #[derive(Debug, Error)]
     #[non_exhaustive]
+    #[allow(clippy::large_enum_variant)]
     pub enum Error {
         #[error(transparent)]
         Build(#[from] xor::BuildError<identities::Error>),
@@ -61,7 +62,7 @@ pub mod urns {
     #[derive(Clone)]
     pub struct Filter {
         inner: Arc<RwLock<FilterInner>>,
-        watch: storage::Watcher,
+        _watch: storage::Watcher,
     }

     struct FilterInner {
@@ -85,13 +86,13 @@ pub mod urns {
                 Arc::new(RwLock::new(inner))
             };

-            let (watch, events) = storage.watch().namespaces()?;
+            let (_watch, events) = storage.watch().namespaces()?;
             thread::spawn({
                 let filter = Arc::clone(&inner);
                 move || recache_thread(storage, filter, events, observe)
             });

-            Ok(Self { inner, watch })
+            Ok(Self { inner, _watch })
         }

         pub fn contains(&self, urn: &SomeUrn) -> bool {
diff --git a/librad/src/net/protocol/event.rs b/librad/src/net/protocol/event.rs
index 282ff002..24b98d3b 100644
--- a/librad/src/net/protocol/event.rs
+++ b/librad/src/net/protocol/event.rs
@@ -196,7 +196,9 @@ pub mod upstream {

         pub fn gossip_from(peer: PeerId) -> impl Fn(&Upstream) -> bool {
             move |event| match event {
-                Upstream::Gossip(box Gossip::Put { provider, .. }) => provider.peer_id == peer,
+                Upstream::Gossip(gossip) => match gossip.as_ref() {
+                    Gossip::Put { provider, .. } => provider.peer_id == peer,
+                },
                 _ => false,
             }
         }
diff --git a/librad/src/net/protocol/io/connections.rs b/librad/src/net/protocol/io/connections.rs
index ee05fdc7..35d7c038 100644
--- a/librad/src/net/protocol/io/connections.rs
+++ b/librad/src/net/protocol/io/connections.rs
@@ -3,7 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-use std::net::SocketAddr;
+use std::net::{IpAddr, SocketAddr};

 use either::Either;
 use futures::{
@@ -11,6 +11,7 @@ use futures::{
     stream::{Stream, StreamExt as _},
 };
 use indexmap::IndexSet;
+use std_ext::Void;

 pub use super::error;
 use super::streams;
@@ -31,7 +32,7 @@ use crate::{
 pub(in crate::net::protocol) async fn incoming<S, I>(
     state: State<S>,
     ingress: I,
-) -> Result<!, error::Accept>
+) -> Result<Void, error::Accept>
 where
     S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
     I: futures::Stream<
@@ -85,7 +86,16 @@ where
 {
     fn routable(addr: &SocketAddr) -> bool {
         let ip = addr.ip();
-        !(ip.is_unspecified() || ip.is_documentation() || ip.is_multicast())
+        !(ip.is_unspecified()
+            || ip.is_multicast()
+            || match ip {
+                IpAddr::V4(ipv4) => ipv4.is_documentation(),
+                IpAddr::V6(ipv6) =>
+                // ipv6.is_documentation() requires !#[feature(ip)]
+                {
+                    (ipv6.segments()[0] == 0x2001) && (ipv6.segments()[1] == 0xdb8)
+                },
+            })
     }

     let addrs = addrs.into_iter().filter(routable).collect::<IndexSet<_>>();
diff --git a/librad/src/net/protocol/state.rs b/librad/src/net/protocol/state.rs
index 2119f362..dce707e2 100644
--- a/librad/src/net/protocol/state.rs
+++ b/librad/src/net/protocol/state.rs
@@ -24,7 +24,7 @@ use super::{
 };
 use crate::{
     git::storage::{self, PoolError, PooledRef},
-    net::{quic, replication::Replication},
+    net::quic,
     paths::Paths,
     rate_limit::{self, Direct, Keyed, RateLimiter},
     PeerId,
@@ -44,7 +44,6 @@ pub(super) struct State<S> {
     pub endpoint: Endpoint,
     pub membership: membership::Hpv<Pcg64Mcg, SocketAddr>,
     pub storage: Storage<S>,
-    pub replication: Replication,
     pub phone: TinCans,
     pub config: StateConfig,
     pub caches: cache::Caches,
diff --git a/librad/src/net/quic/endpoint.rs b/librad/src/net/quic/endpoint.rs
index c8d29154..e154a40e 100644
--- a/librad/src/net/quic/endpoint.rs
+++ b/librad/src/net/quic/endpoint.rs
@@ -63,7 +63,7 @@ pub struct Endpoint<const R: usize> {
     endpoint: quinn::Endpoint,
     listen_addrs: Arc<RwLock<BTreeSet<SocketAddr>>>,
     conntrack: Conntrack,
-    refcount: Arc<()>,
+    _refcount: Arc<()>,
 }

 impl<const R: usize> Endpoint<R> {
@@ -101,7 +101,7 @@ impl<const R: usize> Endpoint<R> {
             endpoint,
             listen_addrs: addrs,
             conntrack: conntrack.clone(),
-            refcount: Arc::new(()),
+            _refcount: Arc::new(()),
         };
         let incoming = incoming
             .map(Ok)
diff --git a/librad/src/net/replication/v3/context.rs b/librad/src/net/replication/v3/context.rs
index d9658d32..62efc3f4 100644
--- a/librad/src/net/replication/v3/context.rs
+++ b/librad/src/net/replication/v3/context.rs
@@ -25,6 +25,7 @@ use link_replication::{
     Negotiation,
     Net,
     ObjectId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -34,6 +35,7 @@ use link_replication::{
     VerifiedIdentity,
 };
 use multihash::Multihash;
+use std_ext::Void;

 use crate::{
     git::{self, refs, storage::Storage, tracking},
@@ -58,6 +60,7 @@ pub mod error {
     use thiserror::Error;

     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Verification {
         #[error("unknown identity kind")]
         UnknownIdentityKind(Box<SomeIdentity>),
@@ -66,16 +69,16 @@ pub mod error {
         MissingDelegate(identities::git::Urn),

         #[error(transparent)]
-        Person(#[from] Box<identities::error::VerifyPerson>),
+        Person(#[from] identities::error::VerifyPerson),

         #[error(transparent)]
-        Project(#[from] Box<identities::error::VerifyProject>),
+        Project(#[from] identities::error::VerifyProject),

         #[error(transparent)]
-        Load(#[from] Box<identities::error::Load>),
+        Load(#[from] identities::error::Load),

         #[error(transparent)]
-        Git(#[from] Box<git::identities::Error>),
+        Git(#[from] git::identities::Error),
     }

     #[derive(Debug, Error)]
@@ -88,6 +91,7 @@ pub mod error {
     }

     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Connection {
         #[error(transparent)]
         Upgrade(#[from] upgrade::Error<quic::BidiStream>),
@@ -95,25 +99,6 @@ pub mod error {
         #[error(transparent)]
         Quic(#[from] quic::Error),
     }
-
-    macro_rules! from_unboxed {
-        ($($t:path)*) => {
-            $(
-                impl From<$t> for Verification {
-                    fn from(e: $t) -> Self {
-                        Self::from(Box::new(e))
-                    }
-                }
-            )*
-        };
-    }
-
-    from_unboxed! {
-        identities::error::VerifyPerson
-        identities::error::VerifyProject
-        identities::error::Load
-        git::identities::Error
-    }
 }

 type Network = io::Network<Urn, io::Refdb<io::Odb>, io::Odb, quic::Connection>;
@@ -294,7 +279,7 @@ impl Identities for Context<'_> {
         let id = self
             .store
             .read_only()
-            .identities::<!>()
+            .identities::<Void>()
             .some_identity(*git_ext::Oid::from(head.as_ref().to_owned()))?;
         self.verify(id, resolve)
     }
@@ -442,13 +427,10 @@ impl Iterator for Tracked {
     }
 }

-impl Refdb for Context<'_> {
+impl<'c> Refdb for Context<'c> {
     type Oid = <io::Refdb<io::Odb> as Refdb>::Oid;

-    type Scan<'a> = <io::Refdb<io::Odb> as Refdb>::Scan<'a>;
-
     type FindError = <io::Refdb<io::Odb> as Refdb>::FindError;
-    type ScanError = <io::Refdb<io::Odb> as Refdb>::ScanError;
     type TxError = <io::Refdb<io::Odb> as Refdb>::TxError;
     type ReloadError = <io::Refdb<io::Odb> as Refdb>::ReloadError;

@@ -459,14 +441,6 @@ impl Refdb for Context<'_> {
         self.refdb.refname_to_id(refname)
     }

-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.refdb.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -479,6 +453,20 @@ impl Refdb for Context<'_> {
     }
 }

+impl<'a> RefScan for &'a Context<'_> {
+    type Oid = <&'a io::Refdb<io::Odb> as RefScan>::Oid;
+    type Scan = <&'a io::Refdb<io::Odb> as RefScan>::Scan;
+    type Error = <&'a io::Refdb<io::Odb> as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        self.refdb.scan(prefix)
+    }
+}
+
 #[async_trait(?Send)]
 impl Net for Context<'_> {
     type Error = <Network as Net>::Error;
diff --git a/link-async/Cargo.toml b/link-async/Cargo.toml
index 7190cfb9..641f5768 100644
--- a/link-async/Cargo.toml
+++ b/link-async/Cargo.toml
@@ -9,6 +9,10 @@ license = "GPL-3.0-or-later"
 doctest = false
 test = false

+[features]
+default = []
+nightly = []
+
 [dependencies]
 blocking = "1.0"
 futures = "0.3"
@@ -17,10 +21,9 @@ rand = "0.8"
 thiserror = "1.0"
 tracing = "0.1"

+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.13.1"
 features = ["time"]
-
-[dependencies.tokio-stream]
-version = "0.1.8"
-features = ["time"]
diff --git a/link-async/src/lib.rs b/link-async/src/lib.rs
index 504cf480..2625a6bc 100644
--- a/link-async/src/lib.rs
+++ b/link-async/src/lib.rs
@@ -3,8 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(try_trait_v2)]
-#![feature(min_type_alias_impl_trait)]
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+extern crate radicle_std_ext as std_ext;

 mod spawn;
 pub use spawn::{Cancelled, JoinError, Spawner, Stats, Task};
diff --git a/link-async/src/tasks.rs b/link-async/src/tasks.rs
index 0a4418bb..ded71063 100644
--- a/link-async/src/tasks.rs
+++ b/link-async/src/tasks.rs
@@ -3,20 +3,15 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-use core::time::Duration;
+use std::{marker::PhantomData, ops::ControlFlow, panic, pin::Pin, task::Poll, time::Duration};
+
 use futures::{
     stream::{FuturesUnordered, StreamExt},
     Future,
     FutureExt,
     Stream,
 };
-use std::{
-    marker::PhantomData,
-    ops::{ControlFlow, Try},
-    panic,
-    pin::Pin,
-    task::Poll,
-};
+use std_ext::ops::Try;

 /// Run tasks from a stream of tasks but terminate if the stream is idle for
 /// `idle_timeout`. The idle timeout starts when there are no tasks running and
@@ -166,7 +161,7 @@ struct ReturnRemainingTasks<T: Try> {
 impl<T: Try> Unpin for ReturnRemainingTasks<T> {}

 impl<T: Try> OnErrorPolicy<T> for ReturnRemainingTasks<T> {
-    type Output = Result<(), (T::Residual, impl Stream<Item = Result<T, crate::JoinError>>)>;
+    type Output = Result<(), (T::Residual, FuturesUnordered<crate::Task<T>>)>;
     type Err = T::Residual;

     fn extract_err(result: T) -> Option<Self::Err> {
diff --git a/link-canonical-derive/Cargo.toml b/link-canonical-derive/Cargo.toml
index c2828939..a6c6adb9 100644
--- a/link-canonical-derive/Cargo.toml
+++ b/link-canonical-derive/Cargo.toml
@@ -13,6 +13,3 @@ convert_case = "0.4"
 proc-macro2 = "1.0"
 quote = "1.0"
 syn = { version = "1.0", features = [ "full" ] }
-
-[dev-dependencies.link-canonical]
-path = "../link-canonical"
\ No newline at end of file
diff --git a/link-crypto/Cargo.toml b/link-crypto/Cargo.toml
index 10941ba4..ad8e9fcd 100644
--- a/link-crypto/Cargo.toml
+++ b/link-crypto/Cargo.toml
@@ -31,7 +31,7 @@ features = ["serde", "minicbor"]

 [dependencies.radicle-keystore]
 git = "https://github.com/radicle-dev/radicle-keystore"
-rev = "00f8fb6135f8e4cd097a48e6f0700e08ce4abb04"
+rev = "293ef5d076b27ae3d8f9cff7fd8a5234b2604199"
 features = [ "ssh-agent" ]

 [dependencies.serde]
diff --git a/link-crypto/src/lib.rs b/link-crypto/src/lib.rs
index dc34c072..4a2279e5 100644
--- a/link-crypto/src/lib.rs
+++ b/link-crypto/src/lib.rs
@@ -6,7 +6,6 @@
 #![allow(private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
 #![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]

 #[macro_use]
 extern crate async_trait;
diff --git a/link-crypto/src/signer.rs b/link-crypto/src/signer.rs
index 43120afa..d4577fb8 100644
--- a/link-crypto/src/signer.rs
+++ b/link-crypto/src/signer.rs
@@ -14,24 +14,13 @@ use crate::{keys, peer::PeerId};

 /// A blanket trait over [`sign::Signer`] that can be shared safely among
 /// threads.
-pub trait Signer:
-    sign::Signer<Error: std::error::Error + Send + Sync + 'static>
-    + Send
-    + Sync
-    + dyn_clone::DynClone
-    + 'static
-{
+pub trait Signer: sign::Signer + Send + Sync + dyn_clone::DynClone + 'static {
     fn sign_blocking(&self, data: &[u8]) -> Result<sign::Signature, <Self as sign::Signer>::Error> {
         block_on(self.sign(data))
     }
 }

-impl<T> Signer for T
-where
-    T: sign::Signer + Send + Sync + Clone + 'static,
-    <T as sign::Signer>::Error: std::error::Error + Send + Sync + 'static,
-{
-}
+impl<T> Signer for T where T: sign::Signer + Send + Sync + Clone + 'static {}

 // Here be Dragons...

diff --git a/link-git/src/lib.rs b/link-git/src/lib.rs
index d190079e..b397c101 100644
--- a/link-git/src/lib.rs
+++ b/link-git/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(array_map, never_type)]
-
 #[macro_use]
 extern crate async_trait;

diff --git a/link-identities/src/delegation/direct.rs b/link-identities/src/delegation/direct.rs
index aa64ecf2..516a10c8 100644
--- a/link-identities/src/delegation/direct.rs
+++ b/link-identities/src/delegation/direct.rs
@@ -9,6 +9,7 @@ use thiserror::Error;

 use crypto::PublicKey;
 use data::{nonempty::Set as _, NonEmptyOrderedSet};
+use std_ext::Void;

 use super::Delegations;
 use crate::{payload, sealed};
@@ -59,7 +60,7 @@ impl Direct {
 }

 impl Delegations for Direct {
-    type Error = !;
+    type Error = Void;

     fn eligible(&self, votes: BTreeSet<&PublicKey>) -> Result<BTreeSet<&PublicKey>, Self::Error> {
         Ok(self.eligible(votes))
diff --git a/link-identities/src/lib.rs b/link-identities/src/lib.rs
index fff7a24b..d2b22706 100644
--- a/link-identities/src/lib.rs
+++ b/link-identities/src/lib.rs
@@ -3,10 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![allow(private_intra_doc_links)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(bool_to_option, never_type)]
+#![deny(rustdoc::broken_intra_doc_links)]

 use std::fmt::{self, Display};

diff --git a/link-identities/src/urn.rs b/link-identities/src/urn.rs
index 69950aa1..b6dade6b 100644
--- a/link-identities/src/urn.rs
+++ b/link-identities/src/urn.rs
@@ -266,7 +266,7 @@ where
             .ok_or(Self::Err::Missing("namespace"))
             .and_then(|nid| {
                 (nid == "rad")
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidNID(nid.to_string()))
             })?;

@@ -275,7 +275,7 @@ where
             .ok_or(Self::Err::Missing("protocol"))
             .and_then(|proto| {
                 (R::PROTOCOL == proto)
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidProto(proto.to_string()))
             })?;

diff --git a/link-replication/Cargo.toml b/link-replication/Cargo.toml
index bc13b1a8..1193b548 100644
--- a/link-replication/Cargo.toml
+++ b/link-replication/Cargo.toml
@@ -33,3 +33,6 @@ features = ["git2"]

 [dependencies.radicle-data]
 path = "../data"
+
+[dependencies.radicle-std-ext]
+path = "../std-ext"
diff --git a/link-replication/src/eval/rad.rs b/link-replication/src/eval/rad.rs
index fe8037b9..327148f7 100644
--- a/link-replication/src/eval/rad.rs
+++ b/link-replication/src/eval/rad.rs
@@ -137,7 +137,7 @@ where
             else {
                 Ok(Ok(Left(newer)))
             }
-        }
+        },
         // Otherwise, theirs:
         //
         // * `rad/id` does not exist, so no other choice
diff --git a/link-replication/src/fetch.rs b/link-replication/src/fetch.rs
index 51b427a2..c1400bba 100644
--- a/link-replication/src/fetch.rs
+++ b/link-replication/src/fetch.rs
@@ -151,7 +151,7 @@ impl<T: AsRef<oid>> Negotiation for Fetch<T> {
             let want: Option<&oid> = self
                 .signed(&r.remote_id, &refname_no_remote)
                 .map(|s| s.as_ref())
-                .or_else(|| self.is_tracked(&r.remote_id).then_some(&r.tip));
+                .or_else(|| self.is_tracked(&r.remote_id).then(|| r.tip.as_ref()));

             match (want, have) {
                 (Some(want), Some(have)) if want == have.as_ref() => {
diff --git a/link-replication/src/io/refdb.rs b/link-replication/src/io/refdb.rs
index dfdaba86..09bf9c37 100644
--- a/link-replication/src/io/refdb.rs
+++ b/link-replication/src/io/refdb.rs
@@ -43,6 +43,7 @@ pub mod error {
     use thiserror::Error;

     #[derive(Debug, Error)]
+    #[allow(clippy::enum_variant_names)]
     pub enum Find {
         #[error(transparent)]
         Refname(#[from] refs::name::Error),
@@ -415,24 +416,12 @@ impl<D: Odb> Refdb<D> {
     }
 }

-impl<D: Odb> refdb::Refdb for Refdb<D> {
+impl<'a, D> refdb::RefScan for &'a Refdb<D> {
     type Oid = ObjectId;
+    type Scan = Scan<'a>;
+    type Error = error::Scan;

-    type Scan<'a> = Scan<'a>;
-
-    type FindError = error::Find;
-    type ScanError = error::Scan;
-    type TxError = error::Tx;
-    type ReloadError = error::Reload;
-
-    fn refname_to_id(
-        &self,
-        refname: impl AsRef<BStr>,
-    ) -> Result<Option<Self::Oid>, Self::FindError> {
-        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
-    }
-
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
     where
         O: Into<Option<P>>,
         P: AsRef<str>,
@@ -451,6 +440,21 @@ impl<D: Odb> refdb::Refdb for Refdb<D> {
             inner,
         })
     }
+}
+
+impl<D: Odb> refdb::Refdb for Refdb<D> {
+    type Oid = ObjectId;
+
+    type FindError = error::Find;
+    type TxError = error::Tx;
+    type ReloadError = error::Reload;
+
+    fn refname_to_id(
+        &self,
+        refname: impl AsRef<BStr>,
+    ) -> Result<Option<Self::Oid>, Self::FindError> {
+        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
+    }

     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
diff --git a/link-replication/src/lib.rs b/link-replication/src/lib.rs
index 05b81791..4ae9dc69 100644
--- a/link-replication/src/lib.rs
+++ b/link-replication/src/lib.rs
@@ -6,12 +6,6 @@
 #![allow(private_intra_doc_links, incomplete_features)]
 #![warn(clippy::extra_unused_lifetimes)]
 #![deny(broken_intra_doc_links)]
-#![feature(
-    bool_to_option,
-    generic_associated_types,
-    never_type,
-    unwrap_infallible
-)]

 use std::fmt::Debug;

@@ -21,6 +15,7 @@ extern crate async_trait;
 extern crate tracing;

 use link_crypto::PeerId;
+use radicle_std_ext::prelude::*;

 pub mod error;
 pub use error::Error;
@@ -40,7 +35,7 @@ mod odb;
 pub use odb::Odb;

 mod refdb;
-pub use refdb::{Applied, Policy, Refdb, SymrefTarget, Update, Updated};
+pub use refdb::{Applied, Policy, RefScan, Refdb, SymrefTarget, Update, Updated};

 mod sigrefs;
 pub use sigrefs::{SignedRefs, Sigrefs};
diff --git a/link-replication/src/peek/clone.rs b/link-replication/src/peek/clone.rs
index d21653fd..6d89cb04 100644
--- a/link-replication/src/peek/clone.rs
+++ b/link-replication/src/peek/clone.rs
@@ -47,9 +47,7 @@ impl Negotiation for ForClone {

         let (name, tip) = refs::into_unpacked(r);
         match refs::parse::<Identity>(name.as_bstr())? {
-            parsed
-            @
-            refs::Parsed {
+            parsed @ refs::Parsed {
                 remote: None,
                 inner: Left(_),
             } => Some(FilteredRef::new(name, tip, &self.remote_id, parsed)),
diff --git a/link-replication/src/refdb.rs b/link-replication/src/refdb.rs
index 1aa60962..91565fed 100644
--- a/link-replication/src/refdb.rs
+++ b/link-replication/src/refdb.rs
@@ -16,10 +16,7 @@ pub use mem::Mem;
 pub trait Refdb {
     type Oid: AsRef<oid> + Into<ObjectId>;

-    type Scan<'a>: IntoIterator<Item = Result<(BString, Self::Oid), Self::ScanError>> + 'a;
-
     type FindError: std::error::Error + Send + Sync + 'static;
-    type ScanError: std::error::Error + Send + Sync + 'static;
     type TxError: std::error::Error + Send + Sync + 'static;
     type ReloadError: std::error::Error + Send + Sync + 'static;

@@ -32,12 +29,6 @@ pub trait Refdb {
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError>;

-    /// Traverse all refs in the current namespace matching `predicate`.
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>;
-
     /// Apply the provided ref updates.
     ///
     /// This should be a transaction: either all updates (modulo the ones
@@ -57,6 +48,18 @@ pub trait Refdb {
     fn reload(&mut self) -> Result<(), Self::ReloadError>;
 }

+pub trait RefScan {
+    type Oid: AsRef<oid> + Into<ObjectId>;
+    type Scan: Iterator<Item = Result<(BString, Self::Oid), Self::Error>>;
+    type Error: std::error::Error + Send + Sync + 'static;
+
+    /// Traverse all refs in the current namespace matching `prefix`.
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>;
+}
+
 #[derive(Clone, Debug)]
 pub enum Update<'a> {
     Direct {
diff --git a/link-replication/src/refdb/mem.rs b/link-replication/src/refdb/mem.rs
index d767325e..b69b0f44 100644
--- a/link-replication/src/refdb/mem.rs
+++ b/link-replication/src/refdb/mem.rs
@@ -7,8 +7,8 @@ use std::collections::{hash_map, HashMap};

 use bstr::{BStr, BString};

-use super::{Applied, Refdb, Update, Updated};
-use crate::ObjectId;
+use super::{Applied, RefScan, Refdb, Update, Updated};
+use crate::{ObjectId, Void};

 /// A very simple in-memory [`Refdb`].
 ///
@@ -28,12 +28,9 @@ impl From<HashMap<BString, ObjectId>> for Mem {
 impl Refdb for Mem {
     type Oid = ObjectId;

-    type Scan<'a> = Scan<'a, ObjectId>;
-
-    type FindError = !;
-    type ScanError = !;
-    type TxError = !;
-    type ReloadError = !;
+    type FindError = Void;
+    type TxError = Void;
+    type ReloadError = Void;

     fn refname_to_id(
         &self,
@@ -42,18 +39,6 @@ impl Refdb for Mem {
         Ok(self.refs.get(refname.as_ref()).map(Clone::clone))
     }

-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        let prefix = prefix.into();
-        Ok(Scan {
-            pref: prefix.map(|p| p.as_ref().to_owned()),
-            iter: self.refs.iter(),
-        })
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -93,6 +78,24 @@ impl Refdb for Mem {
     }
 }

+impl<'a> RefScan for &'a Mem {
+    type Oid = ObjectId;
+    type Scan = Scan<'a, Self::Oid>;
+    type Error = Void;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        let prefix = prefix.into();
+        Ok(Scan {
+            pref: prefix.map(|p| p.as_ref().to_owned()),
+            iter: self.refs.iter(),
+        })
+    }
+}
+
 pub struct Scan<'a, Oid> {
     pref: Option<String>,
     iter: hash_map::Iter<'a, BString, Oid>,
@@ -102,7 +105,7 @@ impl<'a, Oid> Iterator for Scan<'a, Oid>
 where
     Oid: Clone + 'a,
 {
-    type Item = Result<(BString, Oid), !>;
+    type Item = Result<(BString, Oid), Void>;

     fn next(&mut self) -> Option<Self::Item> {
         let next = self.iter.next().and_then(|(k, v)| match &self.pref {
diff --git a/link-replication/src/state.rs b/link-replication/src/state.rs
index 296787bc..c5a2e186 100644
--- a/link-replication/src/state.rs
+++ b/link-replication/src/state.rs
@@ -23,6 +23,7 @@ use crate::{
     Net,
     ObjectId,
     PeerId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -165,7 +166,7 @@ where
         let mut ap = Applied::default();
         for up in other {
             self.tips.push(up.clone().into_owned());
-            ap.append(&mut self.refs.update(Some(up)).into_ok());
+            ap.append(&mut self.refs.update(Some(up)).expect("absurd"));
         }
         ap
     }
@@ -187,17 +188,14 @@ pub(crate) struct Shim<'a, T, U> {
     fetch: &'a mut FetchState<U>,
 }

-impl<T, U> Refdb for Shim<'_, T, U>
+impl<'s, T, U> Refdb for Shim<'s, T, U>
 where
     T: Refdb,
     U: Ord,
 {
     type Oid = <refdb::Mem as Refdb>::Oid;

-    type Scan<'a> = <refdb::Mem as Refdb>::Scan<'a>;
-
     type FindError = <T as Refdb>::FindError;
-    type ScanError = <refdb::Mem as Refdb>::ScanError;
     type TxError = <refdb::Mem as Refdb>::TxError;
     type ReloadError = <refdb::Mem as Refdb>::ReloadError;

@@ -205,7 +203,7 @@ where
         &self,
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError> {
-        let cached = self.fetch.refs.refname_to_id(&refname).into_ok();
+        let cached = self.fetch.refs.refname_to_id(&refname).expect("absurd");
         if cached.is_some() {
             Ok(cached)
         } else {
@@ -215,14 +213,6 @@ where
         }
     }

-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.fetch.refs.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -235,6 +225,20 @@ where
     }
 }

+impl<'a, T, U> RefScan for &'a Shim<'_, T, U> {
+    type Oid = <&'a refdb::Mem as RefScan>::Oid;
+    type Scan = <&'a refdb::Mem as RefScan>::Scan;
+    type Error = <&'a refdb::Mem as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        RefScan::scan(&self.fetch.refs, prefix)
+    }
+}
+
 impl<T, U> SignedRefs for Shim<'_, T, U>
 where
     T: SignedRefs,
diff --git a/link-replication/src/transmit.rs b/link-replication/src/transmit.rs
index 5ab4eaed..fc524dcf 100644
--- a/link-replication/src/transmit.rs
+++ b/link-replication/src/transmit.rs
@@ -79,6 +79,7 @@ pub struct FilteredRef<T: ?Sized> {
 }

 impl<T> FilteredRef<T> {
+    #[allow(clippy::unnecessary_lazy_evaluations)]
     pub fn new(
         name: BString,
         tip: ObjectId,
diff --git a/link-replication/src/validation.rs b/link-replication/src/validation.rs
index 3991bb5d..ed565ec6 100644
--- a/link-replication/src/validation.rs
+++ b/link-replication/src/validation.rs
@@ -17,16 +17,17 @@ use crate::{
     refs,
     sigrefs,
     LocalPeer,
-    Refdb,
+    RefScan,
 };

 #[tracing::instrument(level = "debug", skip(cx, sigrefs), err)]
-pub fn validate<C, Oid>(
-    cx: &C,
-    sigrefs: &sigrefs::Combined<Oid>,
-) -> Result<Vec<error::Validation>, C::ScanError>
+pub fn validate<'a, C, Oid>(
+    cx: &'a C,
+    sigrefs: &'a sigrefs::Combined<Oid>,
+) -> Result<Vec<error::Validation>, <&'a C as RefScan>::Error>
 where
-    C: LocalPeer + Refdb,
+    C: LocalPeer,
+    &'a C: RefScan,
     Oid: Debug + AsRef<oid>,
 {
     use refs::component::*;
@@ -50,7 +51,7 @@ where
         let prefix = format!("refs/remotes/{}", peer);
         info!("scanning {} for signed refs", prefix);

-        for item in Refdb::scan(cx, prefix)? {
+        for item in RefScan::scan(cx, prefix)? {
             let (name, oid) = item?;

             trace!("{}", name);
@@ -121,7 +122,7 @@ where
             let prefix = format!("refs/remotes/{}", peer);
             info!(%prefix, "scanning for unsigned trackings");

-            for item in Refdb::scan(cx, prefix)? {
+            for item in RefScan::scan(cx, prefix)? {
                 let (name, _oid) = item?;

                 trace!("{}", name);
@@ -182,7 +183,7 @@ where

         info!(?pids, "scanning for orphans and strange refs");

-        for item in Refdb::scan::<_, String>(cx, None)? {
+        for item in RefScan::scan::<_, String>(cx, None)? {
             let (name, _oid) = item?;

             trace!("{}", name);
diff --git a/macros/Cargo.toml b/macros/Cargo.toml
index 2d089e05..ffa7347f 100644
--- a/macros/Cargo.toml
+++ b/macros/Cargo.toml
@@ -12,6 +12,7 @@ proc-macro = true
 test = false

 [dependencies]
+proc-macro-error = "1.0.4"
 quote = "1"
 syn = "1"

diff --git a/macros/src/lib.rs b/macros/src/lib.rs
index a5d1bacb..343129bd 100644
--- a/macros/src/lib.rs
+++ b/macros/src/lib.rs
@@ -3,11 +3,13 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(proc_macro_diagnostic)]
+#[macro_use]
+extern crate proc_macro_error;

 use std::convert::TryFrom;

 use proc_macro::TokenStream;
+use proc_macro_error::abort;
 use quote::quote;
 use syn::{parse_macro_input, LitStr};

@@ -23,6 +25,7 @@ use radicle_git_ext::reference::name::{RefLike, RefspecPattern};
 ///
 /// assert_eq!("lolek/bolek", reflike!("lolek/bolek").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn reflike(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -35,12 +38,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
         },

         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefLike literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefLike literal: {}", e);
         },
     }
 }
@@ -55,6 +53,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
 ///
 /// assert_eq!("refs/heads/*", refspec_pattern!("refs/heads/*").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn refspec_pattern(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -67,12 +66,7 @@ pub fn refspec_pattern(input: TokenStream) -> TokenStream {
         },

         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefspecPattern literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefspecPattern literal: {}", e);
         },
     }
 }
diff --git a/node-lib/src/lib.rs b/node-lib/src/lib.rs
index 4efe3409..9d65c1f4 100644
--- a/node-lib/src/lib.rs
+++ b/node-lib/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(box_patterns)]
-
 pub mod args;

 mod cfg;
diff --git a/node-lib/src/protocol.rs b/node-lib/src/protocol.rs
index 588e7242..c26f5e6b 100644
--- a/node-lib/src/protocol.rs
+++ b/node-lib/src/protocol.rs
@@ -50,7 +50,7 @@ where
                     Err(err) => {
                         error!(?err, "accept error");
                     },
-                    Ok(never) => never,
+                    Ok(never) => unreachable!("absurd: {}", never),
                 }
             },
             Err(err) => {
diff --git a/node-lib/src/tracking.rs b/node-lib/src/tracking.rs
index 724410e5..b2088b7e 100644
--- a/node-lib/src/tracking.rs
+++ b/node-lib/src/tracking.rs
@@ -48,49 +48,52 @@ where
     pin_mut!(events);

     while let Some(res) = events.next().await {
-        if let Err(err) = res {
-            error!(?err, "event error");
-            continue;
-        }
+        match res {
+            Ok(ProtocolEvent::Gossip(gossip)) => {
+                let Gossip::Put {
+                    payload: Payload { urn, .. },
+                    provider:
+                        PeerInfo {
+                            peer_id,
+                            seen_addrs,
+                            ..
+                        },
+                    result,
+                } = *gossip;

-        if let ProtocolEvent::Gossip(box Gossip::Put {
-            payload: Payload { urn, .. },
-            provider:
-                PeerInfo {
-                    peer_id,
-                    seen_addrs,
-                    ..
-                },
-            result: Uninteresting,
-        }) = res.unwrap()
-        {
-            if !tracker.is_tracked(&peer_id, &urn) {
-                continue;
-            }
+                if result != Uninteresting || !tracker.is_tracked(&peer_id, &urn) {
+                    continue;
+                }

-            let go = async {
-                let updated = peer
-                    .using_storage({
-                        let urn = urn.clone();
-                        move |storage| tracking::track(storage, &urn, peer_id)
-                    })
-                    .await??;
+                let go = async {
+                    let updated = peer
+                        .using_storage({
+                            let urn = urn.clone();
+                            move |storage| tracking::track(storage, &urn, peer_id)
+                        })
+                        .await??;

-                // Skip explicit replication if the peer is already tracked.
-                if updated {
-                    let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
-                    peer.replicate((peer_id, addr_hints), urn.clone(), None)
-                        .await?;
-                }
+                    // Skip explicit replication if the peer is already tracked.
+                    if updated {
+                        let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
+                        peer.replicate((peer_id, addr_hints), urn.clone(), None)
+                            .await?;
+                    }

-                Ok::<_, anyhow::Error>(updated)
-            };
+                    Ok::<_, anyhow::Error>(updated)
+                };
+
+                match go.await {
+                    Ok(true) => info!("tracked project {} from {}", urn, peer_id),
+                    Ok(false) => info!("already tracked {} from {}", urn, peer_id),
+                    Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
+                }
+            },

-            match go.await {
-                Ok(true) => info!("tracked project {} from {}", urn, peer_id),
-                Ok(false) => info!("already tracked {} from {}", urn, peer_id),
-                Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
-            }
+            Ok(_) => {},
+            Err(err) => {
+                error!(?err, "event error");
+            },
         }
     }

diff --git a/rad-clib/Cargo.toml b/rad-clib/Cargo.toml
index 36a5bce9..884d68b1 100644
--- a/rad-clib/Cargo.toml
+++ b/rad-clib/Cargo.toml
@@ -13,7 +13,6 @@ test = false
 unsafe = []

 [dependencies]
-async-global-executor = "2.0.2"
 futures-lite = "1.12.0"
 once_cell = "1.8"
 serde_json = "1.0"
diff --git a/rad-exe/src/cli/main.rs b/rad-exe/src/cli/main.rs
index f0e56196..cbcf559c 100644
--- a/rad-exe/src/cli/main.rs
+++ b/rad-exe/src/cli/main.rs
@@ -26,7 +26,10 @@ pub fn main() -> anyhow::Result<()> {
                     let exe = format!("rad-{}", exe);
                     let status = Command::new(exe.clone()).args(&external[1..]).status();
                     match status {
-                        Ok(status) => Ok(status.exit_ok()?),
+                        Ok(status) => {
+                            anyhow::ensure!(status.success(), status);
+                            Ok(())
+                        },
                         Err(err) => {
                             if let ErrorKind::NotFound = err.kind() {
                                 eprintln!("{} not found", exe);
diff --git a/rad-exe/src/lib.rs b/rad-exe/src/lib.rs
index 05217dab..d26f893e 100644
--- a/rad-exe/src/lib.rs
+++ b/rad-exe/src/lib.rs
@@ -3,6 +3,4 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(exit_status_error)]
-
 pub mod cli;
diff --git a/rad-identities/Cargo.toml b/rad-identities/Cargo.toml
index 737dbd6d..c642860f 100644
--- a/rad-identities/Cargo.toml
+++ b/rad-identities/Cargo.toml
@@ -39,6 +39,9 @@ path = "../librad"
 [dependencies.radicle-git-ext]
 path = "../git-ext"

+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.serde]
 version = "1.0"
 features = [ "derive" ]
diff --git a/rad-identities/src/git/existing.rs b/rad-identities/src/git/existing.rs
index 56970bb8..702ec727 100644
--- a/rad-identities/src/git/existing.rs
+++ b/rad-identities/src/git/existing.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext,
     std_ext::result::ResultExt as _,
 };
+use std_ext::Void;

 use crate::{
     field::{HasBranch, HasName},
@@ -52,7 +53,7 @@ impl<V, P: HasName> Existing<V, P> {
     }
 }

-type Invalid = PhantomData<!>;
+type Invalid = PhantomData<Void>;

 impl<P: HasName + HasBranch> Existing<Invalid, P> {
     pub fn new(payload: P, path: PathBuf) -> Self {
diff --git a/rad-identities/src/git/include.rs b/rad-identities/src/git/include.rs
index 1c1e85cc..a4e64cc9 100644
--- a/rad-identities/src/git/include.rs
+++ b/rad-identities/src/git/include.rs
@@ -20,6 +20,7 @@ use librad::{
 use crate::field::HasUrn;

 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/git/new.rs b/rad-identities/src/git/new.rs
index fb9ccc01..758af792 100644
--- a/rad-identities/src/git/new.rs
+++ b/rad-identities/src/git/new.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext::OneLevel,
     identities::payload,
 };
+use std_ext::Void;

 use crate::{
     field::{HasBranch, HasName},
@@ -46,10 +47,11 @@ impl<V, P: HasName> New<V, P> {
     }
 }

-pub type Invalid = PhantomData<!>;
-pub type Valid = PhantomData<!>;
+pub type Invalid = PhantomData<Void>;
+pub type Valid = PhantomData<Void>;

 impl<P> New<Invalid, P> {
+    #[allow(clippy::self_named_constructors)]
     pub fn new(payload: P, path: PathBuf) -> Self {
         Self {
             payload,
diff --git a/rad-identities/src/lib.rs b/rad-identities/src/lib.rs
index 90f100a3..d3cdcfd3 100644
--- a/rad-identities/src/lib.rs
+++ b/rad-identities/src/lib.rs
@@ -3,16 +3,14 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(never_type)]
-
 #[macro_use]
 extern crate lazy_static;
+extern crate radicle_std_ext as std_ext;

 use std::fmt;

-use thiserror::Error;
-
 use librad::{git::Urn, PeerId};
+use thiserror::Error;

 pub mod cli;

diff --git a/rad-identities/src/rad_refs.rs b/rad-identities/src/rad_refs.rs
index 1a774bd1..705212ee 100644
--- a/rad-identities/src/rad_refs.rs
+++ b/rad-identities/src/rad_refs.rs
@@ -21,6 +21,7 @@ use librad::{
 };

 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/tracking.rs b/rad-identities/src/tracking.rs
index b670d4e1..f8920e06 100644
--- a/rad-identities/src/tracking.rs
+++ b/rad-identities/src/tracking.rs
@@ -14,6 +14,7 @@ use librad::{
 use crate::git::include;

 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Include(#[from] include::Error),
diff --git a/rust-toolchain b/rust-toolchain
deleted file mode 100644
index 8398865b..00000000
--- a/rust-toolchain
+++ /dev/null
@@ -1 +0,0 @@
-nightly-2021-06-17
diff --git a/scripts/ci/advisory b/scripts/ci/advisory
index baadc7c9..07e8c72e 100755
--- a/scripts/ci/advisory
+++ b/scripts/ci/advisory
@@ -1,17 +1,8 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail

-echo '--- deny: Version'
 cargo deny --version
-
-echo '--- deny: Advisories'
 cargo deny check advisories
-
-echo '--- deny: Licenses'
 cargo deny check licenses
-
-echo '--- deny: Bans'
 cargo deny check bans
-
-echo '--- deny: Sources'
 cargo deny check sources
diff --git a/scripts/ci/build-bins b/scripts/ci/build-bins
index 3a74fcad..4a4c7f8c 100755
--- a/scripts/ci/build-bins
+++ b/scripts/ci/build-bins
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail

-echo '--- Build'
 cd bins && cargo build --workspace --all-features
diff --git a/scripts/ci/build-test b/scripts/ci/build-test
index c8f22a13..af5330a9 100755
--- a/scripts/ci/build-test
+++ b/scripts/ci/build-test
@@ -1,11 +1,7 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail

-echo '--- Build'
 cargo build --workspace

-echo '--- Test (replication v2)'
 RUST_LOG=error ssh-agent cargo test --workspace
-
-echo '--- Test (replication v3)'
 RUST_LOG=error ssh-agent cargo test --workspace  --features replication-v3
diff --git a/scripts/ci/clippy b/scripts/ci/clippy
deleted file mode 100755
index c63ffe0c..00000000
--- a/scripts/ci/clippy
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env bash
-set -eou pipefail
-
-echo '--- Formatting'
-cargo fmt -- --check
-
-echo '--- Clippy'
-# Force clippy to consider all local sources
-# https://github.com/rust-lang/rust-clippy/issues/4612
-find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
-cargo clippy --all-targets --all-features -- -D warnings
diff --git a/scripts/ci/docs b/scripts/ci/docs
index 368e915f..256b3c86 100755
--- a/scripts/ci/docs
+++ b/scripts/ci/docs
@@ -1,6 +1,5 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail

-echo "--- Docs"
 RUSTDOCFLAGS="-D broken-intra-doc-links -D warnings" \
-cargo doc --no-deps --workspace --document-private-items --all-features
+cargo doc --no-deps --workspace --document-private-items
diff --git a/scripts/ci/fmt b/scripts/ci/fmt
new file mode 100755
index 00000000..698940b8
--- /dev/null
+++ b/scripts/ci/fmt
@@ -0,0 +1,4 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+cargo +nightly fmt -- --check
diff --git a/scripts/ci/lint b/scripts/ci/lint
new file mode 100755
index 00000000..2e206d75
--- /dev/null
+++ b/scripts/ci/lint
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+# Force clippy to consider all local sources
+# https://github.com/rust-lang/rust-clippy/issues/4612
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets -- -D warnings
+
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets --features replication-v3 -- -D warnings
diff --git a/scripts/ci/run b/scripts/ci/run
index 170e733d..228977be 100755
--- a/scripts/ci/run
+++ b/scripts/ci/run
@@ -1,7 +1,8 @@
 #!/usr/bin/env bash
 set -eou pipefail

-./scripts/ci/clippy
+./scripts/ci/fmt
+./scripts/ci/lint
 ./scripts/ci/build-test
 ./scripts/ci/docs
 ./scripts/ci/advisory
diff --git a/scripts/ci/test-fast b/scripts/ci/test-fast
index b1bc92d3..d0619af6 100755
--- a/scripts/ci/test-fast
+++ b/scripts/ci/test-fast
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail

-echo '--- Library tests'
-cargo test --lib --all-features unit
+cargo test --lib unit
diff --git a/std-ext/Cargo.toml b/std-ext/Cargo.toml
index 9750198f..766ba940 100644
--- a/std-ext/Cargo.toml
+++ b/std-ext/Cargo.toml
@@ -7,5 +7,9 @@ license = "GPL-3.0-or-later"
 description = "Monkey patches of std types"

 [lib]
-doctest = true
+doctest = false
 test = false
+
+[features]
+default = []
+unstable = []
diff --git a/std-ext/src/iter.rs b/std-ext/src/iter.rs
deleted file mode 100644
index 9754b401..00000000
--- a/std-ext/src/iter.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright ┬й 2019-2020 The Radicle Foundation <hello@radicle.foundation>
-//
-// This file is part of radicle-link, distributed under the GPLv3 with Radicle
-// Linking Exception. For full terms see the included LICENSE file.
-
-pub trait IteratorExt {
-    /// Converts an interator of triples into a triple of containers, analogous
-    /// to [`Iterator::unzip`].
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use radicle_std_ext::iter::IteratorExt as _;
-    ///
-    /// let a = [(1, 2, 3), (4, 5, 6)];
-    ///
-    /// let (left, middle, right): (Vec<_>, Vec<_>, Vec<_>) = a.iter().copied().unzip3();
-    ///
-    /// assert_eq!(left, [1, 4]);
-    /// assert_eq!(middle, [2, 5]);
-    /// assert_eq!(right, [3, 6]);
-    /// ```
-    fn unzip3<A, B, C, FromA, FromB, FromC>(self) -> (FromA, FromB, FromC)
-    where
-        FromA: Default + Extend<A>,
-        FromB: Default + Extend<B>,
-        FromC: Default + Extend<C>,
-        Self: Sized + Iterator<Item = (A, B, C)>,
-    {
-        fn extend<'a, A, B, C>(
-            ts: &'a mut impl Extend<A>,
-            us: &'a mut impl Extend<B>,
-            vs: &'a mut impl Extend<C>,
-        ) -> impl FnMut((), (A, B, C)) + 'a {
-            move |(), (t, u, v)| {
-                ts.extend_one(t);
-                us.extend_one(u);
-                vs.extend_one(v);
-            }
-        }
-
-        let mut ts: FromA = Default::default();
-        let mut us: FromB = Default::default();
-        let mut vs: FromC = Default::default();
-
-        let (lower_bound, _) = self.size_hint();
-        if lower_bound > 0 {
-            ts.extend_reserve(lower_bound);
-            us.extend_reserve(lower_bound);
-            vs.extend_reserve(lower_bound);
-        }
-
-        self.fold((), extend(&mut ts, &mut us, &mut vs));
-
-        (ts, us, vs)
-    }
-}
-
-impl<T> IteratorExt for T where T: Sized + Iterator {}
diff --git a/std-ext/src/lib.rs b/std-ext/src/lib.rs
index 563e2aba..55c47c42 100644
--- a/std-ext/src/lib.rs
+++ b/std-ext/src/lib.rs
@@ -3,6 +3,17 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(extend_one)]
-pub mod iter;
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+pub mod ops;
 pub mod result;
+
+pub type Void = std::convert::Infallible;
+
+pub mod prelude {
+    use super::*;
+
+    pub use super::Void;
+    pub use ops::{FromResidual, Try};
+    pub use result::ResultExt;
+}
diff --git a/std-ext/src/ops.rs b/std-ext/src/ops.rs
new file mode 100644
index 00000000..9dc48a5b
--- /dev/null
+++ b/std-ext/src/ops.rs
@@ -0,0 +1,173 @@
+// Copyright ┬й 2021 The Radicle Link Contributors
+//
+// This file is part of radicle-link, distributed under the GPLv3 with Radicle
+// Linking Exception. For full terms see the included LICENSE file.
+
+//! Provides Try-trait for stable rust
+//!
+//! Probably doesn't work with `?`-desugaring. If the `nightly` feature is
+//! enabled for this crate, the `std` version is enabled.
+
+#[cfg(not(feature = "nightly"))]
+pub use stable::{FromResidual, Try};
+#[cfg(feature = "nightly")]
+pub use std::ops::{FromResidual, Try};
+
+mod stable {
+    use std::{convert, ops::ControlFlow, task::Poll};
+
+    pub trait Try: FromResidual {
+        type Output;
+        type Residual;
+
+        fn from_output(output: Self::Output) -> Self;
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;
+    }
+
+    pub trait FromResidual<R = <Self as Try>::Residual> {
+        fn from_residual(residual: R) -> Self;
+    }
+
+    impl<B, C> Try for ControlFlow<B, C> {
+        type Output = C;
+        type Residual = ControlFlow<B, convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            ControlFlow::Continue(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                ControlFlow::Continue(c) => ControlFlow::Continue(c),
+                ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),
+            }
+        }
+    }
+
+    impl<B, C> FromResidual for ControlFlow<B, C> {
+        #[inline]
+        fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {
+            match residual {
+                ControlFlow::Break(b) => ControlFlow::Break(b),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T> Try for Option<T> {
+        type Output = T;
+        type Residual = Option<convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Some(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Some(v) => ControlFlow::Continue(v),
+                None => ControlFlow::Break(None),
+            }
+        }
+    }
+
+    impl<T> FromResidual for Option<T> {
+        #[inline]
+        fn from_residual(residual: Option<convert::Infallible>) -> Self {
+            match residual {
+                None => None,
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Result<T, E> {
+        type Output = T;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Ok(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Ok(v) => ControlFlow::Continue(v),
+                Err(e) => ControlFlow::Break(Err(e)),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
+        #[inline]
+        fn from_residual(residual: Result<convert::Infallible, E>) -> Self {
+            match residual {
+                Err(e) => Err(From::from(e)),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Option<Result<T, E>>> {
+        type Output = Poll<Option<T>>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(|x| x.map(Ok))
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),
+                Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),
+                Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Option<Result<T, F>>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Some(Err(From::from(e)))),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Result<T, E>> {
+        type Output = Poll<T>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(Ok)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),
+                Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Err(From::from(e))),
+                _ => unreachable!(),
+            }
+        }
+    }
+}
diff --git a/test/Cargo.toml b/test/Cargo.toml
index 4106f1fb..151eb9c8 100644
--- a/test/Cargo.toml
+++ b/test/Cargo.toml
@@ -14,7 +14,7 @@ replication-v3 = ["librad/replication-v3"]

 [dependencies]
 assert_cmd = "2"
-assert_matches = "1"
+assert_matches = "1.5.0"
 anyhow = "1"
 async-stream = "0.3"
 async-trait = "0"
@@ -112,6 +112,9 @@ path = "../git-ext"
 [dependencies.radicle-git-helpers]
 path = "../git-helpers"

+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.rand]
 version = "0.8"
 features = [ "small_rng" ]
diff --git a/test/src/lib.rs b/test/src/lib.rs
index 47ab36ce..15441c6c 100644
--- a/test/src/lib.rs
+++ b/test/src/lib.rs
@@ -3,11 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-#![feature(bool_to_option)]
-#![feature(never_type)]
-#![feature(assert_matches)]
-#![feature(path_try_exists)]
-
+#[cfg(test)]
+#[macro_use]
+extern crate assert_matches;
 #[macro_use]
 extern crate lazy_static;
 #[cfg(test)]
@@ -19,6 +17,7 @@ extern crate futures_await_test;
 #[cfg(test)]
 #[macro_use]
 extern crate link_canonical;
+extern crate radicle_std_ext as std_ext;

 #[macro_use]
 pub mod daemon;
diff --git a/test/src/librad/git.rs b/test/src/librad/git.rs
index d07a06c1..f9295e6f 100644
--- a/test/src/librad/git.rs
+++ b/test/src/librad/git.rs
@@ -7,12 +7,12 @@ use std::io;

 use anyhow::anyhow;
 use either::Either::*;
-
 use librad::{
     git::{identities, storage::Storage, Urn},
     identities::{payload, *},
     SecretKey,
 };
+use std_ext::Void;

 use crate::tempdir::WithTmpDir;

@@ -236,7 +236,7 @@ impl<'a> Project<'a> {

     pub fn verify<F>(&self, lookup: F) -> Result<VerifiedProject, error::VerifyProject>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         self.dev
             .git
@@ -246,7 +246,7 @@ impl<'a> Project<'a> {

     pub fn assert_verifies<F>(&self, lookup: F) -> anyhow::Result<()>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         let verified = self.verify(lookup)?.into_inner();
         anyhow::ensure!(
diff --git a/test/src/ssh.rs b/test/src/ssh.rs
index 239c46fc..5dc78f53 100644
--- a/test/src/ssh.rs
+++ b/test/src/ssh.rs
@@ -3,10 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-use std::{
-    fs,
-    process::{Command, Stdio},
-};
+use std::process::{Command, Stdio};

 use rad_clib::keys::ssh::SshAuthSock;

@@ -32,7 +29,6 @@ pub fn with_ssh_agent<F, T>(callback: F) -> anyhow::Result<T>
 where
     F: FnOnce(SshAuthSock) -> anyhow::Result<T>,
 {
-    fs::try_exists("ssh-agent").expect("`ssh-agent` was not found, it is needed to run this test");
     let sock = ssh_auth_sock();
     let path = match &*sock {
         SshAuthSock::Uds(path) => path,
diff --git a/test/src/test/integration/daemon/gossip.rs b/test/src/test/integration/daemon/gossip.rs
index d96fddc5..91ab1575 100644
--- a/test/src/test/integration/daemon/gossip.rs
+++ b/test/src/test/integration/daemon/gossip.rs
@@ -5,7 +5,6 @@

 use std::time::{Duration, SystemTime};

-use assert_matches::assert_matches;
 use futures::{future, StreamExt as _};
 use tokio::time::timeout;

@@ -188,18 +187,19 @@ fn can_ask_and_clone_project() -> Result<(), anyhow::Error> {

         let alice_tracked = state::tracked(&alice_peer.peer, urn.clone()).await?;

-        assert_matches!(
-            alice_tracked.first().unwrap(),
+        match alice_tracked.first().unwrap() {
             radicle_daemon::project::peer::Peer::Remote {
                 peer_id,
-                status: radicle_daemon::project::peer::Status::Replicated(
-                    radicle_daemon::project::peer::Replicated { role, .. }
-                ),
+                status:
+                    radicle_daemon::project::peer::Status::Replicated(
+                        radicle_daemon::project::peer::Replicated { role, .. },
+                    ),
             } => {
-                assert_eq!(*peer_id, bob_peer.peer_id);
-                assert_eq!(*role, radicle_daemon::project::peer::Role::Tracker);
-            }
-        );
+                assert_eq!(peer_id, &bob_peer.peer_id);
+                assert_eq!(role, &radicle_daemon::project::peer::Role::Tracker);
+            },
+            _ => unreachable!(),
+        }

         Ok(())
     })
diff --git a/test/src/test/integration/daemon/replication.rs b/test/src/test/integration/daemon/replication.rs
index c265892f..8cbf550b 100644
--- a/test/src/test/integration/daemon/replication.rs
+++ b/test/src/test/integration/daemon/replication.rs
@@ -5,7 +5,6 @@

 use std::convert::TryFrom;

-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;

 use librad::{
diff --git a/test/src/test/integration/daemon/working_copy.rs b/test/src/test/integration/daemon/working_copy.rs
index 3e2ea9ae..ac4aa7da 100644
--- a/test/src/test/integration/daemon/working_copy.rs
+++ b/test/src/test/integration/daemon/working_copy.rs
@@ -3,10 +3,8 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.

-use radicle_daemon::{project::checkout, state, RunConfig};
-
-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;
+use radicle_daemon::{project::checkout, state, RunConfig};

 use crate::{
     daemon::common::{blocking, shia_le_pathbuf, Harness},
diff --git a/test/src/test/integration/librad/scenario/collaboration.rs b/test/src/test/integration/librad/scenario/collaboration.rs
index 4eb34bd5..ec0a933f 100644
--- a/test/src/test/integration/librad/scenario/collaboration.rs
+++ b/test/src/test/integration/librad/scenario/collaboration.rs
@@ -35,7 +35,7 @@ fn can_add_maintainer() {

         let proj = {
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/collaborative_objects.rs b/test/src/test/integration/librad/scenario/collaborative_objects.rs
index 5ee0c2f6..51c3a75b 100644
--- a/test/src/test/integration/librad/scenario/collaborative_objects.rs
+++ b/test/src/test/integration/librad/scenario/collaborative_objects.rs
@@ -86,7 +86,7 @@ fn collab_object_crud() {
         let peer2 = net.peers().index(1);

         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/menage.rs b/test/src/test/integration/librad/scenario/menage.rs
index 0e4b7a6f..c4238a7e 100644
--- a/test/src/test/integration/librad/scenario/menage.rs
+++ b/test/src/test/integration/librad/scenario/menage.rs
@@ -84,7 +84,7 @@ fn a_trois() {
         let peer3 = net.peers().index(2);

         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -234,7 +234,7 @@ fn threes_a_crowd() {
         }

         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/tracked_references.rs b/test/src/test/integration/librad/scenario/tracked_references.rs
index 7ed57b63..d0593d63 100644
--- a/test/src/test/integration/librad/scenario/tracked_references.rs
+++ b/test/src/test/integration/librad/scenario/tracked_references.rs
@@ -58,7 +58,7 @@ fn can_see_tracked_references() {
         let peer2 = net.peers().index(1);

         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/updated_delegate.rs b/test/src/test/integration/librad/scenario/updated_delegate.rs
index 6733dafb..cfaf5c5b 100644
--- a/test/src/test/integration/librad/scenario/updated_delegate.rs
+++ b/test/src/test/integration/librad/scenario/updated_delegate.rs
@@ -39,7 +39,7 @@ fn can_replicate_with_updated_delegate() {

         let person = {
             let person = peer1
-                .using_storage(move |storage| TestPerson::create(storage))
+                .using_storage(TestPerson::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/working_copy.rs b/test/src/test/integration/librad/scenario/working_copy.rs
index cbaa0fa3..77e1e090 100644
--- a/test/src/test/integration/librad/scenario/working_copy.rs
+++ b/test/src/test/integration/librad/scenario/working_copy.rs
@@ -78,7 +78,7 @@ fn can_fetch() {
         let peer2_events = peer2.subscribe();

         let proj = peer1
-            .using_storage(move |store| TestProject::create(store))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/smoke/clone.rs b/test/src/test/integration/librad/smoke/clone.rs
index f67a8cbe..e6f3d87f 100644
--- a/test/src/test/integration/librad/smoke/clone.rs
+++ b/test/src/test/integration/librad/smoke/clone.rs
@@ -147,7 +147,7 @@ struct Host<'a> {
 impl<'a> Host<'a> {
     async fn init(peer: &'a RunningTestPeer) -> Host<'a> {
         let project = peer
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -170,7 +170,7 @@ impl Leecher<'_> {
                 (
                     host_peer,
                     supply_addr_hints
-                        .then_some(host_addrs)
+                        .then(|| host_addrs)
                         .into_iter()
                         .flatten()
                         .collect(),
diff --git a/test/src/test/integration/librad/smoke/gossip.rs b/test/src/test/integration/librad/smoke/gossip.rs
index fdf169de..c06a4983 100644
--- a/test/src/test/integration/librad/smoke/gossip.rs
+++ b/test/src/test/integration/librad/smoke/gossip.rs
@@ -60,7 +60,7 @@ fn fetches_on_gossip_notify() {
         let peer1 = net.peers().index(0);
         let peer2 = net.peers().index(1);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -201,7 +201,7 @@ fn ask_and_clone() {
         let proj = {
             let events = peer1.subscribe();
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/interrogation.rs b/test/src/test/integration/librad/smoke/interrogation.rs
index 617daae9..227496b1 100644
--- a/test/src/test/integration/librad/smoke/interrogation.rs
+++ b/test/src/test/integration/librad/smoke/interrogation.rs
@@ -38,7 +38,7 @@ fn responds() {
         let TestProject { project, owner } = {
             let events = responder.subscribe();
             let proj = responder
-                .using_storage(move |s| TestProject::create(s))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/regression.rs b/test/src/test/integration/librad/smoke/regression.rs
index 3b85c15a..9600d8a0 100644
--- a/test/src/test/integration/librad/smoke/regression.rs
+++ b/test/src/test/integration/librad/smoke/regression.rs
@@ -31,7 +31,7 @@ fn list_identities_returns_only_local_projects() {
         let peer2 = net.peers().index(1);
         let peer3 = net.peers().index(2);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/properties/librad/identities/generic.rs b/test/src/test/properties/librad/identities/generic.rs
index c21d488d..b5a2edfb 100644
--- a/test/src/test/properties/librad/identities/generic.rs
+++ b/test/src/test/properties/librad/identities/generic.rs
@@ -5,15 +5,15 @@

 use std::collections::BTreeMap;

-use nonempty::NonEmpty;
-use proptest::prelude::*;
-
 use librad::identities::{
     delegation::Delegations,
     generic::{error, Doc, Identity},
     sign::Signatures,
     Verifying,
 };
+use nonempty::NonEmpty;
+use proptest::prelude::*;
+use std_ext::Void;

 use crate::librad::identities::generic::*;

@@ -175,7 +175,7 @@ proptest! {
             tail[tail.len() - 1].clone()
         };
         let folded = root
-            .verify(tail.into_iter().map(|x| Ok::<_, !>(Verifying::from(x))))
+            .verify(tail.into_iter().map(|x| Ok::<_, Void>(Verifying::from(x))))
             .unwrap();

         assert_eq!(folded.head.into_inner(), expected)
diff --git a/test/src/test/unit/librad/identities/git/project.rs b/test/src/test/unit/librad/identities/git/project.rs
index 0dfef7ea..0be415fd 100644
--- a/test/src/test/unit/librad/identities/git/project.rs
+++ b/test/src/test/unit/librad/identities/git/project.rs
@@ -6,7 +6,6 @@
 use std::collections::BTreeMap;

 use either::Either::*;
-
 use librad::{
     git::Urn,
     identities::{
@@ -19,6 +18,7 @@ use librad::{
     },
     SecretKey,
 };
+use std_ext::Void;

 use crate::librad::git::{repo, Device, Project};

@@ -354,6 +354,6 @@ fn current_heads_from<'a>(
         .collect()
 }

-fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, !> + '_ {
+fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, Void> + '_ {
     move |urn| Ok(*map.get(&urn).unwrap())
 }
diff --git a/test/src/test/unit/librad/net/upgrade.rs b/test/src/test/unit/librad/net/upgrade.rs
index 715df4d5..90b88204 100644
--- a/test/src/test/unit/librad/net/upgrade.rs
+++ b/test/src/test/unit/librad/net/upgrade.rs
@@ -4,7 +4,6 @@
 // Linking Exception. For full terms see the included LICENSE file.

 use futures::try_join;
-
 use librad::{
     net::upgrade::{
         upgrade,
diff --git a/test/src/test/unit/rad_identities/git/checkout.rs b/test/src/test/unit/rad_identities/git/checkout.rs
index 9ce01c03..f2b39a9f 100644
--- a/test/src/test/unit/rad_identities/git/checkout.rs
+++ b/test/src/test/unit/rad_identities/git/checkout.rs
@@ -67,7 +67,7 @@ fn remote_checkout() {
         let temp = tempdir().unwrap();

         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
--
2.34.1


From kim@eagain.st Mon Dec 13 16:02:56 2021
Delivered-To: alex@memoryandthought.me
Received: by 2002:a02:a1cd:0:0:0:0:0 with SMTP id o13csp5558632jah;
        Mon, 13 Dec 2021 08:03:15 -0800 (PST)
X-Google-Smtp-Source: ABdhPJzXY+uw9TNQqhafVtt/c3PrRdsCRyrWFQAd6NMrIYY5mXPGFJxnwhIcBECejncDekCP6ea/
X-Received: by 2002:ad4:5966:: with SMTP id eq6mr43533066qvb.14.1639411394110;
        Mon, 13 Dec 2021 08:03:14 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1639411394; cv=none;
        d=google.com; s=arc-20160816;
        b=GUV+tM1v39UrtTYqHatol5D1arjI2RrKYFPUIshAP10rneCw0dc8RbabPXoLavSQuS
         cX4qsZnUMk4NGRUb+Q13dVJyOs8KFzq8oq9gtoG4K2BwuRhEoTWWrBpifQCDAzvxLSfZ
         ZNbtNZUhgpYgHdrOWViTrvUwYd1mJBK5KpnmXFp46Rp8KnDj9lC6UcSNULQXVLsHy3Tu
         2RVnfmCs+huYOiHRpSfNHQQPbDbeDwSvCM7NJb24ijSmuPT1WVoKuQO9nEtqgterl/IK
         vdovEUrLuykUZ/SLcxL0uU9PZt4+NSIJjSwLYPsCLbtkVXG/HkL6L4zlkBXtjUOKuA9q
         rAUQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=sender:list-id:list-post:archived-at:list-archive:list-subscribe
         :list-unsubscribe:content-transfer-encoding:mime-version:references
         :in-reply-to:message-id:date:subject:cc:to:from:dkim-signature
         :dkim-signature;
        bh=LslTIs6IgK7GWLur7Ec/3nbV+mwR7cjd/6aEBGn+Rzg=;
        b=IC0I9dD49sqw5M+MtlYzeY5CDyid0w9b5wOzdfiyXA/6NaidcJcBxzhBIUCpbtM9xS
         ++/+osgrUpIO5FaqGXtIUGulAZcJ9lqzLW6RPbx/6tgyri4jYXhRU58Uuhi5FMiCYz1I
         AWbOF0kYS+rkJEjBQo9Sqwnm9lJZjXgQd4yWxJxENhyGD8v21lPu9cEqEfIYmEYZ+Hai
         TRDPMkPLaBSd9MHNg1ZXO5mQ1Z8QbPnGSzpJCQqu6UpJ2LexE7sIoSLAKpw0ExzgamZs
         hbchqmkLUGC5O6bmLbk7r80E6ngnF/IfW17tDcKfL7HAvvjaR7sf1YH7IwrtqNnQ3qFH
         TrLg==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=DVUVLUtH;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=NB9zYuja;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Return-Path: <lists@sr.ht>
Received: from mail-b.sr.ht (mail-b.sr.ht. [173.195.146.151])
        by mx.google.com with ESMTPS id t7si12244888qtw.0.2021.12.13.08.03.13
        for <alex@memoryandthought.me>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Mon, 13 Dec 2021 08:03:14 -0800 (PST)
Received-SPF: pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) client-ip=173.195.146.151;
Authentication-Results: mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=DVUVLUtH;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=NB9zYuja;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Authentication-Results: mail-b.sr.ht; dkim=pass header.d=eagain.st header.i=@eagain.st
DKIM-Signature: a=rsa-sha256; bh=CWyMLvdFVnxtB+4oua2P3EHGtq/GVS5m2jQuf2/UxzU=;
 c=simple/simple; d=lists.sr.ht;
 h=From:To:Cc:Subject:Date:In-Reply-To:References:List-Unsubscribe:List-Subscribe:List-Archive:List-Post:List-ID;
 q=dns/txt; s=srht; t=1639411393; v=1;
 b=DVUVLUtHlRPUH+DsJg1hbdeRGpE39/j4KaJJX4h7qOHxc1tKPvvmJW6LFRgPTUCJHjoNI2Jl
 UfEaklBofAkSVf+8+VqA4pNfzNOMOR/MbaImr21+Rf6FGwSOOr4rf4V4qSM3bLDpcN2nKr+MYcH
 9DPZJb3xKWKcWVGAV6dmPsDRJX0uWCoMx52KZsvo0rF8LIRsOp82cC7iTqMqiWPMY/6Nd0ecEiU
 E3I/rq8e9y8HsTUNtws5z92fV43ZzZczoZ0MpHONd5YwTL/PsHfQImsgfQTvDzt/lv4QNtDv9LP
 +wXpkzz3Q82x0P4+i3slidKQxsJzA7FqFugaX53EPfqNg==
Received: from lists.my.domain (unknown [173.195.146.144])
	by mail-b.sr.ht (Postfix) with ESMTPSA id 6D06511F170
	for <alex@memoryandthought.me>; Mon, 13 Dec 2021 16:03:13 +0000 (UTC)
Received: from out0.migadu.com (out0.migadu.com [94.23.1.103])
	by mail-b.sr.ht (Postfix) with ESMTPS id 69F2611EF49
	for <~radicle-link/dev@lists.sr.ht>; Mon, 13 Dec 2021 16:03:04 +0000 (UTC)
X-Report-Abuse: Please report any abuse attempt to abuse@migadu.com and include these headers.
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=eagain.st; s=key1;
	t=1639411381;
	h=from:from:reply-to:subject:subject:date:date:message-id:message-id:
	 to:to:cc:cc:mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references;
	bh=LslTIs6IgK7GWLur7Ec/3nbV+mwR7cjd/6aEBGn+Rzg=;
	b=NB9zYujaB7SyELURDH19ATeMBxmePpkG5m5yUpL7n7GjzT4Y6u02MVTiCcQYlMF4Flc9o4
	PapUlodMzMxAKGghwYobCF06FekZBlCD9mHcF2/hNzNAbQfIDeZthIUpsr28b+BYPUDXs2
	MUu/EGJwaRTE8oHBEJRFLBLTAU/XOvA=
From: Kim Altintop <kim@eagain.st>
To: ~radicle-link/dev@lists.sr.ht
Cc: Kim Altintop <kim@eagain.st>
Subject: [PATCH radicle-link 1/1] Stable Rust
Date: Mon, 13 Dec 2021 17:02:56 +0100
Message-Id: <20211213160256.187186-2-kim@eagain.st>
In-Reply-To: <20211213160256.187186-1-kim@eagain.st>
References: <20211213155631.182523-1-kim@eagain.st>
 <20211213160256.187186-1-kim@eagain.st>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Migadu-Flow: FLOW_OUT
X-Migadu-Auth-User: kim@eagain.st
X-Sourcehut-Patchset-Status: UNKNOWN
List-Unsubscribe: <mailto:~radicle-link/dev+unsubscribe@lists.sr.ht?subject=unsubscribe>
List-Subscribe: <mailto:~radicle-link/dev+subscribe@lists.sr.ht?subject=subscribe>
List-Archive: <https://lists.sr.ht/~radicle-link/dev>
Archived-At: <https://lists.sr.ht/~radicle-link/dev/%3C20211213160256.187186-2-kim%40eagain.st%3E>
List-Post: <mailto:~radicle-link/dev@lists.sr.ht>
List-ID: ~radicle-link/dev <~radicle-link/dev.lists.sr.ht>
Sender: ~radicle-link/dev <~radicle-link/dev@lists.sr.ht>

Make all crates compile under stable rust.

A number of `std` features we've been using were either stabilised, or
are unlikely to ever be stabilised. Also GATs don't seem to ever arrive
in a shape or form comprehensible to mere mortals. So let's stop chasing
and reformulate all code to compile under stable.

Note that:

- there does not seem to be a workaround for the `backtrace` feature

  This was used in one place in the `daemon` crate to manually add
  backtrace information to an error message, which may or may not be
  that useful. Executable crates using `anyhow` at the top level should
  still get backtrace information, although this may require to enable
  `anyhow`'s `backtrace` feature.

- a `Try` trait is provided via `radicle-std-ext`

  This will probably not work with `?` desugaring, but we're not using
  that at the moment. The "real" Try trait can be enabled using the
  feature `nightly` when a nightly toolchain is used. Note that
  `nightly` was chosen over `unstable`, as we may want to use the latter
  for our own unstable features at some point.

- the never type (`!`) is provided as `Void` from `radicle-std-ext`

  Regrettably, the never type is one of those features which are
  unlikely to be stabilised anytime soon. We alias `Void` to
  `Infallible` however, so in case it _does_ get stabilised we'll get
  the actual thing and not an incompatible type.

- our `rustfmt` rules require nightly

  Build scripts have been adjusted to accomodate for that, but note that
  editor hooks and such may need to be adjusted by contributors.

- stable clippy has very different opinions

  Sorry for the noise.

- specifically, box patterns is marked "perma-unstable"

  I have thus opted to ignore all lints about large enum variants for
  error types and use unboxed values. Pattern matching on boxes is
  rather painful, so it might be good to review errors for whether they
  are actually meant to be scrutinized, and convert variants which
  aren't to trait objects.

Fixes #476
Signed-off-by: Kim Altintop <kim@eagain.st>
---
 .builds/linux-x86_64.yml                      |   8 +-
 .github/workflows/ci.yaml                     |  42 ++++-
 cob/Cargo.toml                                |   5 -
 cob/src/lib.rs                                |   4 +-
 cob/src/refs_storage.rs                       |  10 +-
 daemon/src/lib.rs                             |   1 -
 daemon/src/peer.rs                            |   2 +-
 daemon/src/peer/run_state.rs                  |   2 +-
 daemon/src/peer/run_state/input.rs            |   3 +-
 daemon/src/request/waiting_room.rs            |   5 +-
 daemon/src/state.rs                           |   4 +-
 e2e/Cargo.toml                                |   3 +
 e2e/src/bin/ephemeral-peer.rs                 |   7 +-
 git-helpers/src/remote_helper.rs              |   7 +-
 librad/Cargo.toml                             |   5 -
 librad/src/git/fetch/specs.rs                 |   2 +-
 librad/src/git/identities/any.rs              |   3 +-
 librad/src/git/identities/relations.rs        |   1 +
 librad/src/git/include.rs                     |   1 +
 librad/src/git/storage.rs                     |   3 +-
 librad/src/git/storage/config.rs              |   6 +-
 librad/src/git/storage/pool.rs                |   3 +-
 librad/src/git/storage/read.rs                |   4 +-
 librad/src/lib.rs                             |  17 +-
 librad/src/net/peer.rs                        |  22 ++-
 librad/src/net/peer/storage.rs                |  10 +-
 librad/src/net/protocol.rs                    |   9 +-
 librad/src/net/protocol/cache.rs              |   7 +-
 librad/src/net/protocol/event.rs              |   4 +-
 librad/src/net/protocol/io/connections.rs     |  16 +-
 librad/src/net/protocol/state.rs              |   3 +-
 librad/src/net/quic/endpoint.rs               |   4 +-
 librad/src/net/replication/v3/context.rs      |  60 +++---
 link-async/Cargo.toml                         |  11 +-
 link-async/src/lib.rs                         |   5 +-
 link-async/src/tasks.rs                       |  13 +-
 link-canonical-derive/Cargo.toml              |   3 -
 link-crypto/Cargo.toml                        |   2 +-
 link-crypto/src/lib.rs                        |   5 +-
 link-crypto/src/signer.rs                     |  15 +-
 link-git/src/lib.rs                           |   2 -
 link-identities/src/delegation/direct.rs      |   3 +-
 link-identities/src/lib.rs                    |   5 +-
 link-identities/src/urn.rs                    |   4 +-
 link-replication/Cargo.toml                   |   3 +
 link-replication/src/eval/rad.rs              |   2 +-
 link-replication/src/fetch.rs                 |   2 +-
 link-replication/src/io/refdb.rs              |  36 ++--
 link-replication/src/lib.rs                   |  13 +-
 link-replication/src/peek/clone.rs            |   4 +-
 link-replication/src/refdb.rs                 |  21 ++-
 link-replication/src/refdb/mem.rs             |  45 ++---
 link-replication/src/state.rs                 |  32 ++--
 link-replication/src/transmit.rs              |   1 +
 link-replication/src/validation.rs            |  19 +-
 macros/Cargo.toml                             |   1 +
 macros/src/lib.rs                             |  20 +-
 node-lib/src/lib.rs                           |   2 -
 node-lib/src/protocol.rs                      |   2 +-
 node-lib/src/tracking.rs                      |  79 ++++----
 rad-clib/Cargo.toml                           |   1 -
 rad-exe/src/cli/main.rs                       |   5 +-
 rad-exe/src/lib.rs                            |   2 -
 rad-identities/Cargo.toml                     |   3 +
 rad-identities/src/git/existing.rs            |   3 +-
 rad-identities/src/git/include.rs             |   1 +
 rad-identities/src/git/new.rs                 |   6 +-
 rad-identities/src/lib.rs                     |   6 +-
 rad-identities/src/rad_refs.rs                |   1 +
 rad-identities/src/tracking.rs                |   1 +
 rust-toolchain                                |   1 -
 scripts/ci/advisory                           |  11 +-
 scripts/ci/build-bins                         |   3 +-
 scripts/ci/build-test                         |   6 +-
 scripts/ci/clippy                             |  11 --
 scripts/ci/docs                               |   7 +-
 scripts/ci/fmt                                |   4 +
 scripts/ci/lint                               |  10 +
 scripts/ci/run                                |   3 +-
 scripts/ci/test-fast                          |   5 +-
 std-ext/Cargo.toml                            |   6 +-
 std-ext/src/iter.rs                           |  59 ------
 std-ext/src/lib.rs                            |  15 +-
 std-ext/src/ops.rs                            | 173 ++++++++++++++++++
 test/Cargo.toml                               |   5 +-
 test/src/lib.rs                               |   9 +-
 test/src/librad/git.rs                        |   6 +-
 test/src/ssh.rs                               |   6 +-
 test/src/test/integration/daemon/gossip.rs    |  20 +-
 .../test/integration/daemon/replication.rs    |   1 -
 .../test/integration/daemon/working_copy.rs   |   4 +-
 .../librad/scenario/collaboration.rs          |   2 +-
 .../librad/scenario/collaborative_objects.rs  |   2 +-
 .../integration/librad/scenario/menage.rs     |   4 +-
 .../librad/scenario/tracked_references.rs     |   2 +-
 .../librad/scenario/updated_delegate.rs       |   2 +-
 .../librad/scenario/working_copy.rs           |   2 +-
 .../test/integration/librad/smoke/clone.rs    |   4 +-
 .../test/integration/librad/smoke/gossip.rs   |   4 +-
 .../integration/librad/smoke/interrogation.rs |   2 +-
 .../integration/librad/smoke/regression.rs    |   2 +-
 .../properties/librad/identities/generic.rs   |   8 +-
 .../unit/librad/identities/git/project.rs     |   4 +-
 test/src/test/unit/librad/net/upgrade.rs      |   1 -
 .../test/unit/rad_identities/git/checkout.rs  |   2 +-
 105 files changed, 589 insertions(+), 479 deletions(-)
 delete mode 100644 rust-toolchain
 delete mode 100755 scripts/ci/clippy
 create mode 100755 scripts/ci/fmt
 create mode 100755 scripts/ci/lint
 delete mode 100644 std-ext/src/iter.rs
 create mode 100644 std-ext/src/ops.rs

diff --git a/.builds/linux-x86_64.yml b/.builds/linux-x86_64.yml
index 98b345a4..f43f2bf8 100644
--- a/.builds/linux-x86_64.yml
+++ b/.builds/linux-x86_64.yml
@@ -6,8 +6,7 @@ sources:
   - https://git.sr.ht/~radicle-link/radicle-link
 tasks:
   - setup: |
-      toolchain=$(cat radicle-link/rust-toolchain)
-      rustup toolchain install "$toolchain" \
+      rustup toolchain install stable nightly \
           --profile minimal --component clippy --component rustfmt
 
       deny_version="0.11.0"
@@ -25,9 +24,12 @@ tasks:
 
       cd radicle-link/
       cargo fetch
+  - fmt: |
+      cd radicle-link/
+      ./scripts/ci/fmt
   - lint: |
       cd radicle-link/
-      ./scripts/ci/clippy
+      ./scripts/ci/lint
   - advisories: |
       cd radicle-link/
       cargo deny check advisories ||:
diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml
index 21c74653..38666176 100644
--- a/.github/workflows/ci.yaml
+++ b/.github/workflows/ci.yaml
@@ -1,6 +1,19 @@
 name: ci
 on: [push, pull_request]
 jobs:
+  fmt:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: nightly
+          components: rustfmt
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/fmt
+        shell: bash
+
   lint:
     runs-on: ubuntu-latest
     steps:
@@ -8,9 +21,22 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
+          components: clippy
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/lint
+        shell: bash
+
+  docs:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
-      - run: ./scripts/ci/clippy
+      - run: ./scripts/ci/docs
         shell: bash
 
   cargo-deny:
@@ -29,12 +55,18 @@ jobs:
 
   linux:
     runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        toolchain:
+          - stable
+          - nightly
+    continue-on-error: ${{ matrix.toolchain == 'nightly' }}
     steps:
       - uses: actions/checkout@master
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: ${{ matrix.toolchain }}
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -48,7 +80,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -63,7 +95,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/test-fast
         shell: bash
diff --git a/cob/Cargo.toml b/cob/Cargo.toml
index 47aacac9..70867d03 100644
--- a/cob/Cargo.toml
+++ b/cob/Cargo.toml
@@ -51,8 +51,3 @@ path = "../git-ext"
 [dependencies.automerge]
 git = "https://github.com/automerge/automerge-rs.git"
 rev = "e72571962b51c2f0726fb534890ef3b4f7c74dfc"
-
-
-[dev-dependencies]
-rand = "0.8"
-env_logger = "0"
diff --git a/cob/src/lib.rs b/cob/src/lib.rs
index 9e58dfce..d19d0976 100644
--- a/cob/src/lib.rs
+++ b/cob/src/lib.rs
@@ -170,7 +170,7 @@ impl TypeName {
     /// A string representation of the typename which will match the typename in
     /// regular expressions. This primarily escapes periods
     pub fn regex_safe_string(&self) -> String {
-        self.0.replace(".", "\\.")
+        self.0.replace('.', "\\.")
     }
 }
 
@@ -265,6 +265,7 @@ impl From<&git2::Oid> for ObjectId {
 pub struct CollaborativeObject {
     /// The identity (person or project) this collaborative object is authorized
     /// with respect to
+    #[allow(unused)]
     authorizing_identity_urn: Urn,
     /// The typename of this object
     typename: TypeName,
@@ -273,6 +274,7 @@ pub struct CollaborativeObject {
     /// The id of the object
     id: ObjectId,
     /// The schema any changes to this object must respect
+    #[allow(unused)]
     schema: Schema,
 }
 
diff --git a/cob/src/refs_storage.rs b/cob/src/refs_storage.rs
index ee9786fe..ef775363 100644
--- a/cob/src/refs_storage.rs
+++ b/cob/src/refs_storage.rs
@@ -11,6 +11,7 @@ use git2::Reference;
 use link_identities::git::Urn;
 
 /// References to the tips of a collaborative object
+#[derive(Default)]
 pub struct ObjectRefs<'a> {
     /// The reference (if any) which represents the tip of the changes authored
     /// by the identity which owns the underlying storage
@@ -19,15 +20,6 @@ pub struct ObjectRefs<'a> {
     pub remote: Vec<Reference<'a>>,
 }
 
-impl<'a> Default for ObjectRefs<'a> {
-    fn default() -> Self {
-        ObjectRefs {
-            local: None,
-            remote: Vec::new(),
-        }
-    }
-}
-
 impl<'a> std::fmt::Debug for ObjectRefs<'a> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         let local_dbg = self
diff --git a/daemon/src/lib.rs b/daemon/src/lib.rs
index 7f0a4c2d..dd9b1162 100644
--- a/daemon/src/lib.rs
+++ b/daemon/src/lib.rs
@@ -27,7 +27,6 @@
     clippy::similar_names,
     clippy::too_many_lines
 )]
-#![feature(hash_set_entry, never_type, backtrace)]
 
 #[cfg(test)]
 extern crate assert_matches;
diff --git a/daemon/src/peer.rs b/daemon/src/peer.rs
index eabfc760..81392b1f 100644
--- a/daemon/src/peer.rs
+++ b/daemon/src/peer.rs
@@ -234,7 +234,7 @@ where
                                 Err(error) => {
                                     tracing::error!(?error, "accept error");
                                 },
-                                Ok(never) => never,
+                                Ok(never) => unreachable!("absurd: {}", never),
                             };
                         },
                         Err(e) => {
diff --git a/daemon/src/peer/run_state.rs b/daemon/src/peer/run_state.rs
index d5a4d276..e1024f13 100644
--- a/daemon/src/peer/run_state.rs
+++ b/daemon/src/peer/run_state.rs
@@ -213,7 +213,7 @@ impl RunState {
                 if !self.stats.connected_peers.is_empty() && self.stats.membership_active > 0 =>
             {
                 vec![Command::Announce]
-            }
+            },
             _ => vec![],
         }
     }
diff --git a/daemon/src/peer/run_state/input.rs b/daemon/src/peer/run_state/input.rs
index 185718ae..5b4234c2 100644
--- a/daemon/src/peer/run_state/input.rs
+++ b/daemon/src/peer/run_state/input.rs
@@ -5,9 +5,8 @@
 
 use std::{net::SocketAddr, time::SystemTime};
 
-use tokio::sync::oneshot;
-
 use librad::{git::Urn, net, net::peer::ProtocolEvent, PeerId};
+use tokio::sync::oneshot;
 
 use crate::{
     peer::announcement,
diff --git a/daemon/src/request/waiting_room.rs b/daemon/src/request/waiting_room.rs
index abf636de..0b4df62e 100644
--- a/daemon/src/request/waiting_room.rs
+++ b/daemon/src/request/waiting_room.rs
@@ -330,11 +330,8 @@ impl<T, D> WaitingRoom<T, D> {
         T: Clone,
     {
         #[allow(clippy::non_ascii_literal)]
-        let mut reason_str = anyhow::Chain::new(reason.as_ref())
+        let reason_str = anyhow::Chain::new(reason.as_ref())
             .fold("".to_string(), |acc, e| format!("{} той {}", acc, e));
-        if let Some(bt) = reason.backtrace() {
-            reason_str.push_str(&bt.to_string());
-        }
         self.transition(
             |request| match request {
                 SomeRequest::Cloning(request) => Some(request),
diff --git a/daemon/src/state.rs b/daemon/src/state.rs
index dbcd6815..9ab2fb3d 100644
--- a/daemon/src/state.rs
+++ b/daemon/src/state.rs
@@ -80,9 +80,7 @@ pub async fn default_owner<S>(peer: &Peer<S>) -> Result<Option<LocalIdentity>, E
 where
     S: Clone + Signer,
 {
-    Ok(peer
-        .using_storage(move |store| local::default(store))
-        .await??)
+    Ok(peer.using_storage(local::default).await??)
 }
 
 /// Set the default owner for this `PeerApi`.
diff --git a/e2e/Cargo.toml b/e2e/Cargo.toml
index 9de75e70..ea4cdf27 100644
--- a/e2e/Cargo.toml
+++ b/e2e/Cargo.toml
@@ -22,6 +22,9 @@ tracing = "0.1"
 [dependencies.librad]
 path = "../librad"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.1"
 features = ["rt-multi-thread", "macros"]
diff --git a/e2e/src/bin/ephemeral-peer.rs b/e2e/src/bin/ephemeral-peer.rs
index 09b53520..0c5298c5 100644
--- a/e2e/src/bin/ephemeral-peer.rs
+++ b/e2e/src/bin/ephemeral-peer.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(never_type)]
-
 use std::{
     net::{SocketAddr, ToSocketAddrs},
     panic,
@@ -33,6 +31,7 @@ use librad::{
     SecretKey,
 };
 use radicle_link_e2e::logging;
+use radicle_std_ext::Void;
 use tempfile::tempdir;
 use tokio::task::JoinError;
 
@@ -201,7 +200,7 @@ where
     }
 }
 
-async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
+async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<Void> {
     loop {
         tokio::time::sleep(Duration::from_secs(10)).await;
         let stats = peer.stats().await;
@@ -209,7 +208,7 @@ async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
     }
 }
 
-async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<!> {
+async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<Void> {
     tracing::debug!("stats collector");
 
     let peer_id_str = peer.peer_id().to_string();
diff --git a/git-helpers/src/remote_helper.rs b/git-helpers/src/remote_helper.rs
index 68e25820..067ee597 100644
--- a/git-helpers/src/remote_helper.rs
+++ b/git-helpers/src/remote_helper.rs
@@ -30,17 +30,12 @@ use librad::{
 
 use crate::credential;
 
+#[derive(Default)]
 pub struct Config {
     /// Signer for radicle artifacts created by pushes.
     pub signer: Option<BoxedSigner>,
 }
 
-impl Default for Config {
-    fn default() -> Self {
-        Self { signer: None }
-    }
-}
-
 // FIXME: this should be defined elsewhere to be consistent between applications
 const SECRET_KEY_FILE: &str = "librad.key";
 
diff --git a/librad/Cargo.toml b/librad/Cargo.toml
index 7de4f51c..cd09a9f2 100644
--- a/librad/Cargo.toml
+++ b/librad/Cargo.toml
@@ -45,7 +45,6 @@ percent-encoding = "2"
 picky-asn1 = "0.3.2"
 picky-asn1-der = "0.2.5"
 picky-asn1-x509 = "0.6.0"
-priority-queue = "1.0"
 rand = "0.8"
 rand_pcg = "0.3.1"
 regex = "1.3"
@@ -142,10 +141,6 @@ features = ["derive"]
 version = "1.13.1"
 features = ["rt-multi-thread", "net", "time"]
 
-[dependencies.tokio-util]
-version = "0.6"
-features = ["compat"]
-
 [dependencies.url]
 version = "2.1"
 features = ["serde"]
diff --git a/librad/src/git/fetch/specs.rs b/librad/src/git/fetch/specs.rs
index e0b220fa..8f05f4d4 100644
--- a/librad/src/git/fetch/specs.rs
+++ b/librad/src/git/fetch/specs.rs
@@ -346,7 +346,7 @@ pub mod refspecs {
                     }
                 };
 
-                targets_match.then_some({
+                targets_match.then(|| {
                     let dst = Reference {
                         remote: Some(tracked_peer.clone()),
                         category,
diff --git a/librad/src/git/identities/any.rs b/librad/src/git/identities/any.rs
index ecaee69f..5525dcb2 100644
--- a/librad/src/git/identities/any.rs
+++ b/librad/src/git/identities/any.rs
@@ -7,6 +7,7 @@ use std::convert::TryFrom;
 
 use git_ext::is_not_found_err;
 use itertools::Itertools as _;
+use std_ext::Void;
 
 use super::{
     super::{
@@ -102,7 +103,7 @@ where
     Xor::try_from_iter(list_urns(storage)?.map_ok(SomeUrn::from))
 }
 
-fn identities<S>(storage: &S) -> Identities<!>
+fn identities<S>(storage: &S) -> Identities<Void>
 where
     S: AsRef<storage::ReadOnly>,
 {
diff --git a/librad/src/git/identities/relations.rs b/librad/src/git/identities/relations.rs
index fa2621bf..0e23c288 100644
--- a/librad/src/git/identities/relations.rs
+++ b/librad/src/git/identities/relations.rs
@@ -23,6 +23,7 @@ use crate::{
 };
 
 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/librad/src/git/include.rs b/librad/src/git/include.rs
index e67dcdf2..8384ce6e 100644
--- a/librad/src/git/include.rs
+++ b/librad/src/git/include.rs
@@ -24,6 +24,7 @@ pub const GIT_CONFIG_PATH_KEY: &str = "include.path";
 
 #[derive(Debug, thiserror::Error)]
 #[non_exhaustive]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Io(#[from] io::Error),
diff --git a/librad/src/git/storage.rs b/librad/src/git/storage.rs
index 5fb93956..de021b16 100644
--- a/librad/src/git/storage.rs
+++ b/librad/src/git/storage.rs
@@ -14,6 +14,7 @@ use std::{
 use crypto::{BoxedSigner, SomeSigner};
 use git2::string_array::StringArray;
 use git_ext::{self as ext, is_not_found_err};
+use std_ext::Void;
 
 use crate::{
     collaborative_objects::CollaborativeObjects,
@@ -178,7 +179,7 @@ impl Storage {
         Config::try_from(self)
     }
 
-    pub fn config_readonly(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config_readonly(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(self.as_raw())?)
     }
 
diff --git a/librad/src/git/storage/config.rs b/librad/src/git/storage/config.rs
index e2d1711f..a0ba66ce 100644
--- a/librad/src/git/storage/config.rs
+++ b/librad/src/git/storage/config.rs
@@ -9,7 +9,7 @@ use std::{convert::TryFrom, io, marker::PhantomData, path::PathBuf};
 
 use crypto::BoxedSigner;
 use git_ext::{self as ext, is_not_found_err};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;
 use thiserror::Error;
 
 use super::{super::identities::local::LocalIdentity, Storage};
@@ -73,7 +73,7 @@ impl<'a> TryFrom<&'a Storage> for Config<'a, BoxedSigner> {
     }
 }
 
-impl TryFrom<&git2::Repository> for Config<'_, PhantomData<!>> {
+impl TryFrom<&git2::Repository> for Config<'_, PhantomData<Void>> {
     type Error = git2::Error;
 
     fn try_from(repo: &git2::Repository) -> Result<Self, Self::Error> {
@@ -210,7 +210,7 @@ impl<S> Config<'_, S> {
     }
 }
 
-impl Config<'_, PhantomData<!>> {
+impl Config<'_, PhantomData<Void>> {
     pub fn readonly(repo: &git2::Repository) -> Result<Self, git2::Error> {
         Self::try_from(repo)
     }
diff --git a/librad/src/git/storage/pool.rs b/librad/src/git/storage/pool.rs
index 32a9e8e4..77faa8d4 100644
--- a/librad/src/git/storage/pool.rs
+++ b/librad/src/git/storage/pool.rs
@@ -11,6 +11,7 @@ use std::{
 
 use deadpool::managed::{self, Manager, Object, RecycleResult};
 use parking_lot::RwLock;
+use std_ext::Void;
 use thiserror::Error;
 
 use super::{error, read, ReadOnly, Storage};
@@ -105,7 +106,7 @@ pub struct Config<W> {
     write: W,
 }
 
-pub type ReadConfig = Config<PhantomData<!>>;
+pub type ReadConfig = Config<PhantomData<Void>>;
 pub type ReadWriteConfig<S> = Config<Write<S>>;
 
 impl ReadConfig {
diff --git a/librad/src/git/storage/read.rs b/librad/src/git/storage/read.rs
index 39a33cdb..38dec400 100644
--- a/librad/src/git/storage/read.rs
+++ b/librad/src/git/storage/read.rs
@@ -10,7 +10,7 @@ use thiserror::Error;
 
 use git2::string_array::StringArray;
 use git_ext::{self as ext, blob, is_not_found_err, RefLike, RefspecPattern};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;
 
 use crate::{
     git::types::{reference, Many, One, Reference},
@@ -196,7 +196,7 @@ impl ReadOnly {
     /// 3. The SHA of the tag was not the same as the resolved reference
     /// 4. The `oid` was the [`zero`][`git2::Oid::zero`] SHA.
 
-    pub fn config(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(&self.backend)?)
     }
 
diff --git a/librad/src/lib.rs b/librad/src/lib.rs
index 92b7a65f..513abb28 100644
--- a/librad/src/lib.rs
+++ b/librad/src/lib.rs
@@ -3,22 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
-#![allow(incomplete_features)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]
-#![feature(backtrace)]
-#![feature(bool_to_option)]
-#![feature(box_patterns)]
-#![feature(btree_drain_filter)]
-#![feature(control_flow_enum)]
-#![feature(core_intrinsics)]
-#![feature(drain_filter)]
-#![feature(generic_associated_types)]
-#![feature(ip)]
-#![feature(never_type)]
-#![feature(try_trait_v2)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 #[macro_use]
 extern crate async_trait;
diff --git a/librad/src/net/peer.rs b/librad/src/net/peer.rs
index 6ca2b3b8..a9af048e 100644
--- a/librad/src/net/peer.rs
+++ b/librad/src/net/peer.rs
@@ -131,6 +131,7 @@ where
             pool,
             caches.urns.clone(),
             repl.clone(),
+            #[cfg(feature = "replication-v3")]
             phone.clone(),
         );
         let user_store = git::storage::Pool::new(
@@ -192,15 +193,17 @@ where
                     .map_err(|_| "network reconnect")
                     .try_filter_map(move |event| {
                         let provider = match event {
-                            Upstream::Gossip(box Gossip::Put {
-                                provider,
-                                payload:
-                                    gossip::Payload {
-                                        urn: payload_urn, ..
-                                    },
-                                ..
-                            }) if payload_urn == urn => Some(provider),
-
+                            Upstream::Gossip(gossip) => match *gossip {
+                                Gossip::Put {
+                                    provider,
+                                    payload:
+                                        gossip::Payload {
+                                            urn: payload_urn, ..
+                                        },
+                                    ..
+                                } if payload_urn == urn => Some(provider),
+                                _ => None,
+                            },
                             _ => None,
                         };
                         future::ok(provider)
@@ -346,7 +349,6 @@ where
             self.phone.clone(),
             self.config.protocol.clone(),
             self.config.signer.clone(),
-            self.repl.clone(),
             self.peer_store.clone(),
             self.caches.clone(),
         )
diff --git a/librad/src/net/peer/storage.rs b/librad/src/net/peer/storage.rs
index f176926b..12b97c56 100644
--- a/librad/src/net/peer/storage.rs
+++ b/librad/src/net/peer/storage.rs
@@ -14,6 +14,8 @@ use link_async::Spawner;
 use nonzero_ext::nonzero;
 use parking_lot::RwLock;
 
+#[cfg(feature = "replication-v3")]
+use crate::net::protocol::TinCans;
 use crate::{
     git::{
         storage::{self, Pool, PoolError, PooledRef, ReadOnlyStorage as _},
@@ -22,7 +24,7 @@ use crate::{
     },
     identities::urn,
     net::{
-        protocol::{broadcast, cache, gossip, TinCans},
+        protocol::{broadcast, cache, gossip},
         replication::{self, Replication},
     },
     rate_limit::{Keyed, RateLimiter},
@@ -41,13 +43,13 @@ type SeenFilter = StableBloomFilter<DefaultBuildHashKernels<RandomState>>;
 
 #[derive(Clone)]
 pub struct Storage {
-    conf: Config,
     pool: Pool<storage::Storage>,
     urns: cache::urns::Filter,
     seen: Arc<RwLock<SeenFilter>>,
     rate: Arc<RateLimiter<Keyed<(PeerId, Urn)>>>,
     exec: Arc<Spawner>,
     repl: Replication,
+    #[cfg(feature = "replication-v3")]
     tins: TinCans,
 }
 
@@ -58,10 +60,9 @@ impl Storage {
         pool: Pool<storage::Storage>,
         urns: cache::urns::Filter,
         repl: Replication,
-        tins: TinCans,
+        #[cfg(feature = "replication-v3")] tins: TinCans,
     ) -> Self {
         Self {
-            conf,
             pool,
             urns,
             // TODO: parameters pulled out of thin air
@@ -77,6 +78,7 @@ impl Storage {
             )),
             exec,
             repl,
+            #[cfg(feature = "replication-v3")]
             tins,
         }
     }
diff --git a/librad/src/net/protocol.rs b/librad/src/net/protocol.rs
index 8b5c1699..c35732d6 100644
--- a/librad/src/net/protocol.rs
+++ b/librad/src/net/protocol.rs
@@ -11,6 +11,7 @@ use link_async::Spawner;
 use nonempty::NonEmpty;
 use nonzero_ext::nonzero;
 use rand_pcg::Pcg64Mcg;
+use std_ext::Void;
 use tracing::Instrument as _;
 
 use super::{
@@ -21,7 +22,7 @@ use super::{
 };
 use crate::{
     git::storage,
-    net::replication::{self, Replication},
+    net::replication,
     paths::Paths,
     rate_limit::RateLimiter,
     PeerId,
@@ -122,7 +123,7 @@ impl<S> Bound<S> {
         disco: D,
     ) -> (
         impl FnOnce(),
-        impl Future<Output = Result<!, io::error::Accept>>,
+        impl Future<Output = Result<Void, io::error::Accept>>,
     )
     where
         S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
@@ -151,7 +152,6 @@ pub async fn bind<Sign, Store>(
     phone: TinCans,
     config: Config,
     signer: Sign,
-    replication: Replication,
     storage: Store,
     caches: cache::Caches,
 ) -> Result<Bound<Store>, error::Bootstrap>
@@ -186,7 +186,6 @@ where
         endpoint,
         membership,
         storage,
-        replication,
         phone: phone.clone(),
         config: StateConfig {
             paths: Arc::new(config.paths),
@@ -218,7 +217,7 @@ pub fn accept<Store, Disco>(
     disco: Disco,
 ) -> (
     impl FnOnce(),
-    impl Future<Output = Result<!, io::error::Accept>>,
+    impl Future<Output = Result<Void, io::error::Accept>>,
 )
 where
     Store: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
diff --git a/librad/src/net/protocol/cache.rs b/librad/src/net/protocol/cache.rs
index d42a37f2..93c0205b 100644
--- a/librad/src/net/protocol/cache.rs
+++ b/librad/src/net/protocol/cache.rs
@@ -31,6 +31,7 @@ pub mod urns {
 
     #[derive(Debug, Error)]
     #[non_exhaustive]
+    #[allow(clippy::large_enum_variant)]
     pub enum Error {
         #[error(transparent)]
         Build(#[from] xor::BuildError<identities::Error>),
@@ -61,7 +62,7 @@ pub mod urns {
     #[derive(Clone)]
     pub struct Filter {
         inner: Arc<RwLock<FilterInner>>,
-        watch: storage::Watcher,
+        _watch: storage::Watcher,
     }
 
     struct FilterInner {
@@ -85,13 +86,13 @@ pub mod urns {
                 Arc::new(RwLock::new(inner))
             };
 
-            let (watch, events) = storage.watch().namespaces()?;
+            let (_watch, events) = storage.watch().namespaces()?;
             thread::spawn({
                 let filter = Arc::clone(&inner);
                 move || recache_thread(storage, filter, events, observe)
             });
 
-            Ok(Self { inner, watch })
+            Ok(Self { inner, _watch })
         }
 
         pub fn contains(&self, urn: &SomeUrn) -> bool {
diff --git a/librad/src/net/protocol/event.rs b/librad/src/net/protocol/event.rs
index 282ff002..24b98d3b 100644
--- a/librad/src/net/protocol/event.rs
+++ b/librad/src/net/protocol/event.rs
@@ -196,7 +196,9 @@ pub mod upstream {
 
         pub fn gossip_from(peer: PeerId) -> impl Fn(&Upstream) -> bool {
             move |event| match event {
-                Upstream::Gossip(box Gossip::Put { provider, .. }) => provider.peer_id == peer,
+                Upstream::Gossip(gossip) => match gossip.as_ref() {
+                    Gossip::Put { provider, .. } => provider.peer_id == peer,
+                },
                 _ => false,
             }
         }
diff --git a/librad/src/net/protocol/io/connections.rs b/librad/src/net/protocol/io/connections.rs
index ee05fdc7..35d7c038 100644
--- a/librad/src/net/protocol/io/connections.rs
+++ b/librad/src/net/protocol/io/connections.rs
@@ -3,7 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use std::net::SocketAddr;
+use std::net::{IpAddr, SocketAddr};
 
 use either::Either;
 use futures::{
@@ -11,6 +11,7 @@ use futures::{
     stream::{Stream, StreamExt as _},
 };
 use indexmap::IndexSet;
+use std_ext::Void;
 
 pub use super::error;
 use super::streams;
@@ -31,7 +32,7 @@ use crate::{
 pub(in crate::net::protocol) async fn incoming<S, I>(
     state: State<S>,
     ingress: I,
-) -> Result<!, error::Accept>
+) -> Result<Void, error::Accept>
 where
     S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
     I: futures::Stream<
@@ -85,7 +86,16 @@ where
 {
     fn routable(addr: &SocketAddr) -> bool {
         let ip = addr.ip();
-        !(ip.is_unspecified() || ip.is_documentation() || ip.is_multicast())
+        !(ip.is_unspecified()
+            || ip.is_multicast()
+            || match ip {
+                IpAddr::V4(ipv4) => ipv4.is_documentation(),
+                IpAddr::V6(ipv6) =>
+                // ipv6.is_documentation() requires !#[feature(ip)]
+                {
+                    (ipv6.segments()[0] == 0x2001) && (ipv6.segments()[1] == 0xdb8)
+                },
+            })
     }
 
     let addrs = addrs.into_iter().filter(routable).collect::<IndexSet<_>>();
diff --git a/librad/src/net/protocol/state.rs b/librad/src/net/protocol/state.rs
index 2119f362..dce707e2 100644
--- a/librad/src/net/protocol/state.rs
+++ b/librad/src/net/protocol/state.rs
@@ -24,7 +24,7 @@ use super::{
 };
 use crate::{
     git::storage::{self, PoolError, PooledRef},
-    net::{quic, replication::Replication},
+    net::quic,
     paths::Paths,
     rate_limit::{self, Direct, Keyed, RateLimiter},
     PeerId,
@@ -44,7 +44,6 @@ pub(super) struct State<S> {
     pub endpoint: Endpoint,
     pub membership: membership::Hpv<Pcg64Mcg, SocketAddr>,
     pub storage: Storage<S>,
-    pub replication: Replication,
     pub phone: TinCans,
     pub config: StateConfig,
     pub caches: cache::Caches,
diff --git a/librad/src/net/quic/endpoint.rs b/librad/src/net/quic/endpoint.rs
index c8d29154..e154a40e 100644
--- a/librad/src/net/quic/endpoint.rs
+++ b/librad/src/net/quic/endpoint.rs
@@ -63,7 +63,7 @@ pub struct Endpoint<const R: usize> {
     endpoint: quinn::Endpoint,
     listen_addrs: Arc<RwLock<BTreeSet<SocketAddr>>>,
     conntrack: Conntrack,
-    refcount: Arc<()>,
+    _refcount: Arc<()>,
 }
 
 impl<const R: usize> Endpoint<R> {
@@ -101,7 +101,7 @@ impl<const R: usize> Endpoint<R> {
             endpoint,
             listen_addrs: addrs,
             conntrack: conntrack.clone(),
-            refcount: Arc::new(()),
+            _refcount: Arc::new(()),
         };
         let incoming = incoming
             .map(Ok)
diff --git a/librad/src/net/replication/v3/context.rs b/librad/src/net/replication/v3/context.rs
index d9658d32..62efc3f4 100644
--- a/librad/src/net/replication/v3/context.rs
+++ b/librad/src/net/replication/v3/context.rs
@@ -25,6 +25,7 @@ use link_replication::{
     Negotiation,
     Net,
     ObjectId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -34,6 +35,7 @@ use link_replication::{
     VerifiedIdentity,
 };
 use multihash::Multihash;
+use std_ext::Void;
 
 use crate::{
     git::{self, refs, storage::Storage, tracking},
@@ -58,6 +60,7 @@ pub mod error {
     use thiserror::Error;
 
     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Verification {
         #[error("unknown identity kind")]
         UnknownIdentityKind(Box<SomeIdentity>),
@@ -66,16 +69,16 @@ pub mod error {
         MissingDelegate(identities::git::Urn),
 
         #[error(transparent)]
-        Person(#[from] Box<identities::error::VerifyPerson>),
+        Person(#[from] identities::error::VerifyPerson),
 
         #[error(transparent)]
-        Project(#[from] Box<identities::error::VerifyProject>),
+        Project(#[from] identities::error::VerifyProject),
 
         #[error(transparent)]
-        Load(#[from] Box<identities::error::Load>),
+        Load(#[from] identities::error::Load),
 
         #[error(transparent)]
-        Git(#[from] Box<git::identities::Error>),
+        Git(#[from] git::identities::Error),
     }
 
     #[derive(Debug, Error)]
@@ -88,6 +91,7 @@ pub mod error {
     }
 
     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Connection {
         #[error(transparent)]
         Upgrade(#[from] upgrade::Error<quic::BidiStream>),
@@ -95,25 +99,6 @@ pub mod error {
         #[error(transparent)]
         Quic(#[from] quic::Error),
     }
-
-    macro_rules! from_unboxed {
-        ($($t:path)*) => {
-            $(
-                impl From<$t> for Verification {
-                    fn from(e: $t) -> Self {
-                        Self::from(Box::new(e))
-                    }
-                }
-            )*
-        };
-    }
-
-    from_unboxed! {
-        identities::error::VerifyPerson
-        identities::error::VerifyProject
-        identities::error::Load
-        git::identities::Error
-    }
 }
 
 type Network = io::Network<Urn, io::Refdb<io::Odb>, io::Odb, quic::Connection>;
@@ -294,7 +279,7 @@ impl Identities for Context<'_> {
         let id = self
             .store
             .read_only()
-            .identities::<!>()
+            .identities::<Void>()
             .some_identity(*git_ext::Oid::from(head.as_ref().to_owned()))?;
         self.verify(id, resolve)
     }
@@ -442,13 +427,10 @@ impl Iterator for Tracked {
     }
 }
 
-impl Refdb for Context<'_> {
+impl<'c> Refdb for Context<'c> {
     type Oid = <io::Refdb<io::Odb> as Refdb>::Oid;
 
-    type Scan<'a> = <io::Refdb<io::Odb> as Refdb>::Scan<'a>;
-
     type FindError = <io::Refdb<io::Odb> as Refdb>::FindError;
-    type ScanError = <io::Refdb<io::Odb> as Refdb>::ScanError;
     type TxError = <io::Refdb<io::Odb> as Refdb>::TxError;
     type ReloadError = <io::Refdb<io::Odb> as Refdb>::ReloadError;
 
@@ -459,14 +441,6 @@ impl Refdb for Context<'_> {
         self.refdb.refname_to_id(refname)
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.refdb.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -479,6 +453,20 @@ impl Refdb for Context<'_> {
     }
 }
 
+impl<'a> RefScan for &'a Context<'_> {
+    type Oid = <&'a io::Refdb<io::Odb> as RefScan>::Oid;
+    type Scan = <&'a io::Refdb<io::Odb> as RefScan>::Scan;
+    type Error = <&'a io::Refdb<io::Odb> as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        self.refdb.scan(prefix)
+    }
+}
+
 #[async_trait(?Send)]
 impl Net for Context<'_> {
     type Error = <Network as Net>::Error;
diff --git a/link-async/Cargo.toml b/link-async/Cargo.toml
index 7190cfb9..641f5768 100644
--- a/link-async/Cargo.toml
+++ b/link-async/Cargo.toml
@@ -9,6 +9,10 @@ license = "GPL-3.0-or-later"
 doctest = false
 test = false
 
+[features]
+default = []
+nightly = []
+
 [dependencies]
 blocking = "1.0"
 futures = "0.3"
@@ -17,10 +21,9 @@ rand = "0.8"
 thiserror = "1.0"
 tracing = "0.1"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.13.1"
 features = ["time"]
-
-[dependencies.tokio-stream]
-version = "0.1.8"
-features = ["time"]
diff --git a/link-async/src/lib.rs b/link-async/src/lib.rs
index 504cf480..2625a6bc 100644
--- a/link-async/src/lib.rs
+++ b/link-async/src/lib.rs
@@ -3,8 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(try_trait_v2)]
-#![feature(min_type_alias_impl_trait)]
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+extern crate radicle_std_ext as std_ext;
 
 mod spawn;
 pub use spawn::{Cancelled, JoinError, Spawner, Stats, Task};
diff --git a/link-async/src/tasks.rs b/link-async/src/tasks.rs
index 0a4418bb..ded71063 100644
--- a/link-async/src/tasks.rs
+++ b/link-async/src/tasks.rs
@@ -3,20 +3,15 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use core::time::Duration;
+use std::{marker::PhantomData, ops::ControlFlow, panic, pin::Pin, task::Poll, time::Duration};
+
 use futures::{
     stream::{FuturesUnordered, StreamExt},
     Future,
     FutureExt,
     Stream,
 };
-use std::{
-    marker::PhantomData,
-    ops::{ControlFlow, Try},
-    panic,
-    pin::Pin,
-    task::Poll,
-};
+use std_ext::ops::Try;
 
 /// Run tasks from a stream of tasks but terminate if the stream is idle for
 /// `idle_timeout`. The idle timeout starts when there are no tasks running and
@@ -166,7 +161,7 @@ struct ReturnRemainingTasks<T: Try> {
 impl<T: Try> Unpin for ReturnRemainingTasks<T> {}
 
 impl<T: Try> OnErrorPolicy<T> for ReturnRemainingTasks<T> {
-    type Output = Result<(), (T::Residual, impl Stream<Item = Result<T, crate::JoinError>>)>;
+    type Output = Result<(), (T::Residual, FuturesUnordered<crate::Task<T>>)>;
     type Err = T::Residual;
 
     fn extract_err(result: T) -> Option<Self::Err> {
diff --git a/link-canonical-derive/Cargo.toml b/link-canonical-derive/Cargo.toml
index c2828939..a6c6adb9 100644
--- a/link-canonical-derive/Cargo.toml
+++ b/link-canonical-derive/Cargo.toml
@@ -13,6 +13,3 @@ convert_case = "0.4"
 proc-macro2 = "1.0"
 quote = "1.0"
 syn = { version = "1.0", features = [ "full" ] }
-
-[dev-dependencies.link-canonical]
-path = "../link-canonical"
\ No newline at end of file
diff --git a/link-crypto/Cargo.toml b/link-crypto/Cargo.toml
index 10941ba4..ad8e9fcd 100644
--- a/link-crypto/Cargo.toml
+++ b/link-crypto/Cargo.toml
@@ -31,7 +31,7 @@ features = ["serde", "minicbor"]
 
 [dependencies.radicle-keystore]
 git = "https://github.com/radicle-dev/radicle-keystore"
-rev = "00f8fb6135f8e4cd097a48e6f0700e08ce4abb04"
+rev = "293ef5d076b27ae3d8f9cff7fd8a5234b2604199"
 features = [ "ssh-agent" ]
 
 [dependencies.serde]
diff --git a/link-crypto/src/lib.rs b/link-crypto/src/lib.rs
index dc34c072..701d81d8 100644
--- a/link-crypto/src/lib.rs
+++ b/link-crypto/src/lib.rs
@@ -3,10 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 #[macro_use]
 extern crate async_trait;
diff --git a/link-crypto/src/signer.rs b/link-crypto/src/signer.rs
index 43120afa..d4577fb8 100644
--- a/link-crypto/src/signer.rs
+++ b/link-crypto/src/signer.rs
@@ -14,24 +14,13 @@ use crate::{keys, peer::PeerId};
 
 /// A blanket trait over [`sign::Signer`] that can be shared safely among
 /// threads.
-pub trait Signer:
-    sign::Signer<Error: std::error::Error + Send + Sync + 'static>
-    + Send
-    + Sync
-    + dyn_clone::DynClone
-    + 'static
-{
+pub trait Signer: sign::Signer + Send + Sync + dyn_clone::DynClone + 'static {
     fn sign_blocking(&self, data: &[u8]) -> Result<sign::Signature, <Self as sign::Signer>::Error> {
         block_on(self.sign(data))
     }
 }
 
-impl<T> Signer for T
-where
-    T: sign::Signer + Send + Sync + Clone + 'static,
-    <T as sign::Signer>::Error: std::error::Error + Send + Sync + 'static,
-{
-}
+impl<T> Signer for T where T: sign::Signer + Send + Sync + Clone + 'static {}
 
 // Here be Dragons...
 
diff --git a/link-git/src/lib.rs b/link-git/src/lib.rs
index d190079e..b397c101 100644
--- a/link-git/src/lib.rs
+++ b/link-git/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(array_map, never_type)]
-
 #[macro_use]
 extern crate async_trait;
 
diff --git a/link-identities/src/delegation/direct.rs b/link-identities/src/delegation/direct.rs
index aa64ecf2..516a10c8 100644
--- a/link-identities/src/delegation/direct.rs
+++ b/link-identities/src/delegation/direct.rs
@@ -9,6 +9,7 @@ use thiserror::Error;
 
 use crypto::PublicKey;
 use data::{nonempty::Set as _, NonEmptyOrderedSet};
+use std_ext::Void;
 
 use super::Delegations;
 use crate::{payload, sealed};
@@ -59,7 +60,7 @@ impl Direct {
 }
 
 impl Delegations for Direct {
-    type Error = !;
+    type Error = Void;
 
     fn eligible(&self, votes: BTreeSet<&PublicKey>) -> Result<BTreeSet<&PublicKey>, Self::Error> {
         Ok(self.eligible(votes))
diff --git a/link-identities/src/lib.rs b/link-identities/src/lib.rs
index fff7a24b..d2b22706 100644
--- a/link-identities/src/lib.rs
+++ b/link-identities/src/lib.rs
@@ -3,10 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(bool_to_option, never_type)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 use std::fmt::{self, Display};
 
diff --git a/link-identities/src/urn.rs b/link-identities/src/urn.rs
index 69950aa1..b6dade6b 100644
--- a/link-identities/src/urn.rs
+++ b/link-identities/src/urn.rs
@@ -266,7 +266,7 @@ where
             .ok_or(Self::Err::Missing("namespace"))
             .and_then(|nid| {
                 (nid == "rad")
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidNID(nid.to_string()))
             })?;
 
@@ -275,7 +275,7 @@ where
             .ok_or(Self::Err::Missing("protocol"))
             .and_then(|proto| {
                 (R::PROTOCOL == proto)
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidProto(proto.to_string()))
             })?;
 
diff --git a/link-replication/Cargo.toml b/link-replication/Cargo.toml
index bc13b1a8..1193b548 100644
--- a/link-replication/Cargo.toml
+++ b/link-replication/Cargo.toml
@@ -33,3 +33,6 @@ features = ["git2"]
 
 [dependencies.radicle-data]
 path = "../data"
+
+[dependencies.radicle-std-ext]
+path = "../std-ext"
diff --git a/link-replication/src/eval/rad.rs b/link-replication/src/eval/rad.rs
index fe8037b9..327148f7 100644
--- a/link-replication/src/eval/rad.rs
+++ b/link-replication/src/eval/rad.rs
@@ -137,7 +137,7 @@ where
             else {
                 Ok(Ok(Left(newer)))
             }
-        }
+        },
         // Otherwise, theirs:
         //
         // * `rad/id` does not exist, so no other choice
diff --git a/link-replication/src/fetch.rs b/link-replication/src/fetch.rs
index 51b427a2..c1400bba 100644
--- a/link-replication/src/fetch.rs
+++ b/link-replication/src/fetch.rs
@@ -151,7 +151,7 @@ impl<T: AsRef<oid>> Negotiation for Fetch<T> {
             let want: Option<&oid> = self
                 .signed(&r.remote_id, &refname_no_remote)
                 .map(|s| s.as_ref())
-                .or_else(|| self.is_tracked(&r.remote_id).then_some(&r.tip));
+                .or_else(|| self.is_tracked(&r.remote_id).then(|| r.tip.as_ref()));
 
             match (want, have) {
                 (Some(want), Some(have)) if want == have.as_ref() => {
diff --git a/link-replication/src/io/refdb.rs b/link-replication/src/io/refdb.rs
index dfdaba86..09bf9c37 100644
--- a/link-replication/src/io/refdb.rs
+++ b/link-replication/src/io/refdb.rs
@@ -43,6 +43,7 @@ pub mod error {
     use thiserror::Error;
 
     #[derive(Debug, Error)]
+    #[allow(clippy::enum_variant_names)]
     pub enum Find {
         #[error(transparent)]
         Refname(#[from] refs::name::Error),
@@ -415,24 +416,12 @@ impl<D: Odb> Refdb<D> {
     }
 }
 
-impl<D: Odb> refdb::Refdb for Refdb<D> {
+impl<'a, D> refdb::RefScan for &'a Refdb<D> {
     type Oid = ObjectId;
+    type Scan = Scan<'a>;
+    type Error = error::Scan;
 
-    type Scan<'a> = Scan<'a>;
-
-    type FindError = error::Find;
-    type ScanError = error::Scan;
-    type TxError = error::Tx;
-    type ReloadError = error::Reload;
-
-    fn refname_to_id(
-        &self,
-        refname: impl AsRef<BStr>,
-    ) -> Result<Option<Self::Oid>, Self::FindError> {
-        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
-    }
-
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
     where
         O: Into<Option<P>>,
         P: AsRef<str>,
@@ -451,6 +440,21 @@ impl<D: Odb> refdb::Refdb for Refdb<D> {
             inner,
         })
     }
+}
+
+impl<D: Odb> refdb::Refdb for Refdb<D> {
+    type Oid = ObjectId;
+
+    type FindError = error::Find;
+    type TxError = error::Tx;
+    type ReloadError = error::Reload;
+
+    fn refname_to_id(
+        &self,
+        refname: impl AsRef<BStr>,
+    ) -> Result<Option<Self::Oid>, Self::FindError> {
+        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
+    }
 
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
diff --git a/link-replication/src/lib.rs b/link-replication/src/lib.rs
index 05b81791..18d3aac3 100644
--- a/link-replication/src/lib.rs
+++ b/link-replication/src/lib.rs
@@ -3,15 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links, incomplete_features)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(
-    bool_to_option,
-    generic_associated_types,
-    never_type,
-    unwrap_infallible
-)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 use std::fmt::Debug;
 
@@ -21,6 +15,7 @@ extern crate async_trait;
 extern crate tracing;
 
 use link_crypto::PeerId;
+use radicle_std_ext::prelude::*;
 
 pub mod error;
 pub use error::Error;
@@ -40,7 +35,7 @@ mod odb;
 pub use odb::Odb;
 
 mod refdb;
-pub use refdb::{Applied, Policy, Refdb, SymrefTarget, Update, Updated};
+pub use refdb::{Applied, Policy, RefScan, Refdb, SymrefTarget, Update, Updated};
 
 mod sigrefs;
 pub use sigrefs::{SignedRefs, Sigrefs};
diff --git a/link-replication/src/peek/clone.rs b/link-replication/src/peek/clone.rs
index d21653fd..6d89cb04 100644
--- a/link-replication/src/peek/clone.rs
+++ b/link-replication/src/peek/clone.rs
@@ -47,9 +47,7 @@ impl Negotiation for ForClone {
 
         let (name, tip) = refs::into_unpacked(r);
         match refs::parse::<Identity>(name.as_bstr())? {
-            parsed
-            @
-            refs::Parsed {
+            parsed @ refs::Parsed {
                 remote: None,
                 inner: Left(_),
             } => Some(FilteredRef::new(name, tip, &self.remote_id, parsed)),
diff --git a/link-replication/src/refdb.rs b/link-replication/src/refdb.rs
index 1aa60962..91565fed 100644
--- a/link-replication/src/refdb.rs
+++ b/link-replication/src/refdb.rs
@@ -16,10 +16,7 @@ pub use mem::Mem;
 pub trait Refdb {
     type Oid: AsRef<oid> + Into<ObjectId>;
 
-    type Scan<'a>: IntoIterator<Item = Result<(BString, Self::Oid), Self::ScanError>> + 'a;
-
     type FindError: std::error::Error + Send + Sync + 'static;
-    type ScanError: std::error::Error + Send + Sync + 'static;
     type TxError: std::error::Error + Send + Sync + 'static;
     type ReloadError: std::error::Error + Send + Sync + 'static;
 
@@ -32,12 +29,6 @@ pub trait Refdb {
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError>;
 
-    /// Traverse all refs in the current namespace matching `predicate`.
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>;
-
     /// Apply the provided ref updates.
     ///
     /// This should be a transaction: either all updates (modulo the ones
@@ -57,6 +48,18 @@ pub trait Refdb {
     fn reload(&mut self) -> Result<(), Self::ReloadError>;
 }
 
+pub trait RefScan {
+    type Oid: AsRef<oid> + Into<ObjectId>;
+    type Scan: Iterator<Item = Result<(BString, Self::Oid), Self::Error>>;
+    type Error: std::error::Error + Send + Sync + 'static;
+
+    /// Traverse all refs in the current namespace matching `prefix`.
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>;
+}
+
 #[derive(Clone, Debug)]
 pub enum Update<'a> {
     Direct {
diff --git a/link-replication/src/refdb/mem.rs b/link-replication/src/refdb/mem.rs
index d767325e..b69b0f44 100644
--- a/link-replication/src/refdb/mem.rs
+++ b/link-replication/src/refdb/mem.rs
@@ -7,8 +7,8 @@ use std::collections::{hash_map, HashMap};
 
 use bstr::{BStr, BString};
 
-use super::{Applied, Refdb, Update, Updated};
-use crate::ObjectId;
+use super::{Applied, RefScan, Refdb, Update, Updated};
+use crate::{ObjectId, Void};
 
 /// A very simple in-memory [`Refdb`].
 ///
@@ -28,12 +28,9 @@ impl From<HashMap<BString, ObjectId>> for Mem {
 impl Refdb for Mem {
     type Oid = ObjectId;
 
-    type Scan<'a> = Scan<'a, ObjectId>;
-
-    type FindError = !;
-    type ScanError = !;
-    type TxError = !;
-    type ReloadError = !;
+    type FindError = Void;
+    type TxError = Void;
+    type ReloadError = Void;
 
     fn refname_to_id(
         &self,
@@ -42,18 +39,6 @@ impl Refdb for Mem {
         Ok(self.refs.get(refname.as_ref()).map(Clone::clone))
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        let prefix = prefix.into();
-        Ok(Scan {
-            pref: prefix.map(|p| p.as_ref().to_owned()),
-            iter: self.refs.iter(),
-        })
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -93,6 +78,24 @@ impl Refdb for Mem {
     }
 }
 
+impl<'a> RefScan for &'a Mem {
+    type Oid = ObjectId;
+    type Scan = Scan<'a, Self::Oid>;
+    type Error = Void;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        let prefix = prefix.into();
+        Ok(Scan {
+            pref: prefix.map(|p| p.as_ref().to_owned()),
+            iter: self.refs.iter(),
+        })
+    }
+}
+
 pub struct Scan<'a, Oid> {
     pref: Option<String>,
     iter: hash_map::Iter<'a, BString, Oid>,
@@ -102,7 +105,7 @@ impl<'a, Oid> Iterator for Scan<'a, Oid>
 where
     Oid: Clone + 'a,
 {
-    type Item = Result<(BString, Oid), !>;
+    type Item = Result<(BString, Oid), Void>;
 
     fn next(&mut self) -> Option<Self::Item> {
         let next = self.iter.next().and_then(|(k, v)| match &self.pref {
diff --git a/link-replication/src/state.rs b/link-replication/src/state.rs
index 296787bc..c5a2e186 100644
--- a/link-replication/src/state.rs
+++ b/link-replication/src/state.rs
@@ -23,6 +23,7 @@ use crate::{
     Net,
     ObjectId,
     PeerId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -165,7 +166,7 @@ where
         let mut ap = Applied::default();
         for up in other {
             self.tips.push(up.clone().into_owned());
-            ap.append(&mut self.refs.update(Some(up)).into_ok());
+            ap.append(&mut self.refs.update(Some(up)).expect("absurd"));
         }
         ap
     }
@@ -187,17 +188,14 @@ pub(crate) struct Shim<'a, T, U> {
     fetch: &'a mut FetchState<U>,
 }
 
-impl<T, U> Refdb for Shim<'_, T, U>
+impl<'s, T, U> Refdb for Shim<'s, T, U>
 where
     T: Refdb,
     U: Ord,
 {
     type Oid = <refdb::Mem as Refdb>::Oid;
 
-    type Scan<'a> = <refdb::Mem as Refdb>::Scan<'a>;
-
     type FindError = <T as Refdb>::FindError;
-    type ScanError = <refdb::Mem as Refdb>::ScanError;
     type TxError = <refdb::Mem as Refdb>::TxError;
     type ReloadError = <refdb::Mem as Refdb>::ReloadError;
 
@@ -205,7 +203,7 @@ where
         &self,
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError> {
-        let cached = self.fetch.refs.refname_to_id(&refname).into_ok();
+        let cached = self.fetch.refs.refname_to_id(&refname).expect("absurd");
         if cached.is_some() {
             Ok(cached)
         } else {
@@ -215,14 +213,6 @@ where
         }
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.fetch.refs.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -235,6 +225,20 @@ where
     }
 }
 
+impl<'a, T, U> RefScan for &'a Shim<'_, T, U> {
+    type Oid = <&'a refdb::Mem as RefScan>::Oid;
+    type Scan = <&'a refdb::Mem as RefScan>::Scan;
+    type Error = <&'a refdb::Mem as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        RefScan::scan(&self.fetch.refs, prefix)
+    }
+}
+
 impl<T, U> SignedRefs for Shim<'_, T, U>
 where
     T: SignedRefs,
diff --git a/link-replication/src/transmit.rs b/link-replication/src/transmit.rs
index 5ab4eaed..fc524dcf 100644
--- a/link-replication/src/transmit.rs
+++ b/link-replication/src/transmit.rs
@@ -79,6 +79,7 @@ pub struct FilteredRef<T: ?Sized> {
 }
 
 impl<T> FilteredRef<T> {
+    #[allow(clippy::unnecessary_lazy_evaluations)]
     pub fn new(
         name: BString,
         tip: ObjectId,
diff --git a/link-replication/src/validation.rs b/link-replication/src/validation.rs
index 3991bb5d..ed565ec6 100644
--- a/link-replication/src/validation.rs
+++ b/link-replication/src/validation.rs
@@ -17,16 +17,17 @@ use crate::{
     refs,
     sigrefs,
     LocalPeer,
-    Refdb,
+    RefScan,
 };
 
 #[tracing::instrument(level = "debug", skip(cx, sigrefs), err)]
-pub fn validate<C, Oid>(
-    cx: &C,
-    sigrefs: &sigrefs::Combined<Oid>,
-) -> Result<Vec<error::Validation>, C::ScanError>
+pub fn validate<'a, C, Oid>(
+    cx: &'a C,
+    sigrefs: &'a sigrefs::Combined<Oid>,
+) -> Result<Vec<error::Validation>, <&'a C as RefScan>::Error>
 where
-    C: LocalPeer + Refdb,
+    C: LocalPeer,
+    &'a C: RefScan,
     Oid: Debug + AsRef<oid>,
 {
     use refs::component::*;
@@ -50,7 +51,7 @@ where
         let prefix = format!("refs/remotes/{}", peer);
         info!("scanning {} for signed refs", prefix);
 
-        for item in Refdb::scan(cx, prefix)? {
+        for item in RefScan::scan(cx, prefix)? {
             let (name, oid) = item?;
 
             trace!("{}", name);
@@ -121,7 +122,7 @@ where
             let prefix = format!("refs/remotes/{}", peer);
             info!(%prefix, "scanning for unsigned trackings");
 
-            for item in Refdb::scan(cx, prefix)? {
+            for item in RefScan::scan(cx, prefix)? {
                 let (name, _oid) = item?;
 
                 trace!("{}", name);
@@ -182,7 +183,7 @@ where
 
         info!(?pids, "scanning for orphans and strange refs");
 
-        for item in Refdb::scan::<_, String>(cx, None)? {
+        for item in RefScan::scan::<_, String>(cx, None)? {
             let (name, _oid) = item?;
 
             trace!("{}", name);
diff --git a/macros/Cargo.toml b/macros/Cargo.toml
index 2d089e05..ffa7347f 100644
--- a/macros/Cargo.toml
+++ b/macros/Cargo.toml
@@ -12,6 +12,7 @@ proc-macro = true
 test = false
 
 [dependencies]
+proc-macro-error = "1.0.4"
 quote = "1"
 syn = "1"
 
diff --git a/macros/src/lib.rs b/macros/src/lib.rs
index a5d1bacb..343129bd 100644
--- a/macros/src/lib.rs
+++ b/macros/src/lib.rs
@@ -3,11 +3,13 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(proc_macro_diagnostic)]
+#[macro_use]
+extern crate proc_macro_error;
 
 use std::convert::TryFrom;
 
 use proc_macro::TokenStream;
+use proc_macro_error::abort;
 use quote::quote;
 use syn::{parse_macro_input, LitStr};
 
@@ -23,6 +25,7 @@ use radicle_git_ext::reference::name::{RefLike, RefspecPattern};
 ///
 /// assert_eq!("lolek/bolek", reflike!("lolek/bolek").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn reflike(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -35,12 +38,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
         },
 
         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefLike literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefLike literal: {}", e);
         },
     }
 }
@@ -55,6 +53,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
 ///
 /// assert_eq!("refs/heads/*", refspec_pattern!("refs/heads/*").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn refspec_pattern(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -67,12 +66,7 @@ pub fn refspec_pattern(input: TokenStream) -> TokenStream {
         },
 
         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefspecPattern literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefspecPattern literal: {}", e);
         },
     }
 }
diff --git a/node-lib/src/lib.rs b/node-lib/src/lib.rs
index 4efe3409..9d65c1f4 100644
--- a/node-lib/src/lib.rs
+++ b/node-lib/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(box_patterns)]
-
 pub mod args;
 
 mod cfg;
diff --git a/node-lib/src/protocol.rs b/node-lib/src/protocol.rs
index 588e7242..c26f5e6b 100644
--- a/node-lib/src/protocol.rs
+++ b/node-lib/src/protocol.rs
@@ -50,7 +50,7 @@ where
                     Err(err) => {
                         error!(?err, "accept error");
                     },
-                    Ok(never) => never,
+                    Ok(never) => unreachable!("absurd: {}", never),
                 }
             },
             Err(err) => {
diff --git a/node-lib/src/tracking.rs b/node-lib/src/tracking.rs
index 724410e5..b2088b7e 100644
--- a/node-lib/src/tracking.rs
+++ b/node-lib/src/tracking.rs
@@ -48,49 +48,52 @@ where
     pin_mut!(events);
 
     while let Some(res) = events.next().await {
-        if let Err(err) = res {
-            error!(?err, "event error");
-            continue;
-        }
+        match res {
+            Ok(ProtocolEvent::Gossip(gossip)) => {
+                let Gossip::Put {
+                    payload: Payload { urn, .. },
+                    provider:
+                        PeerInfo {
+                            peer_id,
+                            seen_addrs,
+                            ..
+                        },
+                    result,
+                } = *gossip;
 
-        if let ProtocolEvent::Gossip(box Gossip::Put {
-            payload: Payload { urn, .. },
-            provider:
-                PeerInfo {
-                    peer_id,
-                    seen_addrs,
-                    ..
-                },
-            result: Uninteresting,
-        }) = res.unwrap()
-        {
-            if !tracker.is_tracked(&peer_id, &urn) {
-                continue;
-            }
+                if result != Uninteresting || !tracker.is_tracked(&peer_id, &urn) {
+                    continue;
+                }
 
-            let go = async {
-                let updated = peer
-                    .using_storage({
-                        let urn = urn.clone();
-                        move |storage| tracking::track(storage, &urn, peer_id)
-                    })
-                    .await??;
+                let go = async {
+                    let updated = peer
+                        .using_storage({
+                            let urn = urn.clone();
+                            move |storage| tracking::track(storage, &urn, peer_id)
+                        })
+                        .await??;
 
-                // Skip explicit replication if the peer is already tracked.
-                if updated {
-                    let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
-                    peer.replicate((peer_id, addr_hints), urn.clone(), None)
-                        .await?;
-                }
+                    // Skip explicit replication if the peer is already tracked.
+                    if updated {
+                        let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
+                        peer.replicate((peer_id, addr_hints), urn.clone(), None)
+                            .await?;
+                    }
 
-                Ok::<_, anyhow::Error>(updated)
-            };
+                    Ok::<_, anyhow::Error>(updated)
+                };
+
+                match go.await {
+                    Ok(true) => info!("tracked project {} from {}", urn, peer_id),
+                    Ok(false) => info!("already tracked {} from {}", urn, peer_id),
+                    Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
+                }
+            },
 
-            match go.await {
-                Ok(true) => info!("tracked project {} from {}", urn, peer_id),
-                Ok(false) => info!("already tracked {} from {}", urn, peer_id),
-                Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
-            }
+            Ok(_) => {},
+            Err(err) => {
+                error!(?err, "event error");
+            },
         }
     }
 
diff --git a/rad-clib/Cargo.toml b/rad-clib/Cargo.toml
index 36a5bce9..884d68b1 100644
--- a/rad-clib/Cargo.toml
+++ b/rad-clib/Cargo.toml
@@ -13,7 +13,6 @@ test = false
 unsafe = []
 
 [dependencies]
-async-global-executor = "2.0.2"
 futures-lite = "1.12.0"
 once_cell = "1.8"
 serde_json = "1.0"
diff --git a/rad-exe/src/cli/main.rs b/rad-exe/src/cli/main.rs
index f0e56196..cbcf559c 100644
--- a/rad-exe/src/cli/main.rs
+++ b/rad-exe/src/cli/main.rs
@@ -26,7 +26,10 @@ pub fn main() -> anyhow::Result<()> {
                     let exe = format!("rad-{}", exe);
                     let status = Command::new(exe.clone()).args(&external[1..]).status();
                     match status {
-                        Ok(status) => Ok(status.exit_ok()?),
+                        Ok(status) => {
+                            anyhow::ensure!(status.success(), status);
+                            Ok(())
+                        },
                         Err(err) => {
                             if let ErrorKind::NotFound = err.kind() {
                                 eprintln!("{} not found", exe);
diff --git a/rad-exe/src/lib.rs b/rad-exe/src/lib.rs
index 05217dab..d26f893e 100644
--- a/rad-exe/src/lib.rs
+++ b/rad-exe/src/lib.rs
@@ -3,6 +3,4 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(exit_status_error)]
-
 pub mod cli;
diff --git a/rad-identities/Cargo.toml b/rad-identities/Cargo.toml
index 737dbd6d..c642860f 100644
--- a/rad-identities/Cargo.toml
+++ b/rad-identities/Cargo.toml
@@ -39,6 +39,9 @@ path = "../librad"
 [dependencies.radicle-git-ext]
 path = "../git-ext"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.serde]
 version = "1.0"
 features = [ "derive" ]
diff --git a/rad-identities/src/git/existing.rs b/rad-identities/src/git/existing.rs
index 56970bb8..702ec727 100644
--- a/rad-identities/src/git/existing.rs
+++ b/rad-identities/src/git/existing.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext,
     std_ext::result::ResultExt as _,
 };
+use std_ext::Void;
 
 use crate::{
     field::{HasBranch, HasName},
@@ -52,7 +53,7 @@ impl<V, P: HasName> Existing<V, P> {
     }
 }
 
-type Invalid = PhantomData<!>;
+type Invalid = PhantomData<Void>;
 
 impl<P: HasName + HasBranch> Existing<Invalid, P> {
     pub fn new(payload: P, path: PathBuf) -> Self {
diff --git a/rad-identities/src/git/include.rs b/rad-identities/src/git/include.rs
index 1c1e85cc..a4e64cc9 100644
--- a/rad-identities/src/git/include.rs
+++ b/rad-identities/src/git/include.rs
@@ -20,6 +20,7 @@ use librad::{
 use crate::field::HasUrn;
 
 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/git/new.rs b/rad-identities/src/git/new.rs
index fb9ccc01..758af792 100644
--- a/rad-identities/src/git/new.rs
+++ b/rad-identities/src/git/new.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext::OneLevel,
     identities::payload,
 };
+use std_ext::Void;
 
 use crate::{
     field::{HasBranch, HasName},
@@ -46,10 +47,11 @@ impl<V, P: HasName> New<V, P> {
     }
 }
 
-pub type Invalid = PhantomData<!>;
-pub type Valid = PhantomData<!>;
+pub type Invalid = PhantomData<Void>;
+pub type Valid = PhantomData<Void>;
 
 impl<P> New<Invalid, P> {
+    #[allow(clippy::self_named_constructors)]
     pub fn new(payload: P, path: PathBuf) -> Self {
         Self {
             payload,
diff --git a/rad-identities/src/lib.rs b/rad-identities/src/lib.rs
index 90f100a3..d3cdcfd3 100644
--- a/rad-identities/src/lib.rs
+++ b/rad-identities/src/lib.rs
@@ -3,16 +3,14 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(never_type)]
-
 #[macro_use]
 extern crate lazy_static;
+extern crate radicle_std_ext as std_ext;
 
 use std::fmt;
 
-use thiserror::Error;
-
 use librad::{git::Urn, PeerId};
+use thiserror::Error;
 
 pub mod cli;
 
diff --git a/rad-identities/src/rad_refs.rs b/rad-identities/src/rad_refs.rs
index 1a774bd1..705212ee 100644
--- a/rad-identities/src/rad_refs.rs
+++ b/rad-identities/src/rad_refs.rs
@@ -21,6 +21,7 @@ use librad::{
 };
 
 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/tracking.rs b/rad-identities/src/tracking.rs
index b670d4e1..f8920e06 100644
--- a/rad-identities/src/tracking.rs
+++ b/rad-identities/src/tracking.rs
@@ -14,6 +14,7 @@ use librad::{
 use crate::git::include;
 
 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Include(#[from] include::Error),
diff --git a/rust-toolchain b/rust-toolchain
deleted file mode 100644
index 8398865b..00000000
--- a/rust-toolchain
+++ /dev/null
@@ -1 +0,0 @@
-nightly-2021-06-17
diff --git a/scripts/ci/advisory b/scripts/ci/advisory
index baadc7c9..07e8c72e 100755
--- a/scripts/ci/advisory
+++ b/scripts/ci/advisory
@@ -1,17 +1,8 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- deny: Version'
 cargo deny --version
-
-echo '--- deny: Advisories'
 cargo deny check advisories
-
-echo '--- deny: Licenses'
 cargo deny check licenses
-
-echo '--- deny: Bans'
 cargo deny check bans
-
-echo '--- deny: Sources'
 cargo deny check sources
diff --git a/scripts/ci/build-bins b/scripts/ci/build-bins
index 3a74fcad..4a4c7f8c 100755
--- a/scripts/ci/build-bins
+++ b/scripts/ci/build-bins
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Build'
 cd bins && cargo build --workspace --all-features
diff --git a/scripts/ci/build-test b/scripts/ci/build-test
index c8f22a13..af5330a9 100755
--- a/scripts/ci/build-test
+++ b/scripts/ci/build-test
@@ -1,11 +1,7 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Build'
 cargo build --workspace
 
-echo '--- Test (replication v2)'
 RUST_LOG=error ssh-agent cargo test --workspace
-
-echo '--- Test (replication v3)'
 RUST_LOG=error ssh-agent cargo test --workspace  --features replication-v3
diff --git a/scripts/ci/clippy b/scripts/ci/clippy
deleted file mode 100755
index c63ffe0c..00000000
--- a/scripts/ci/clippy
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env bash
-set -eou pipefail
-
-echo '--- Formatting'
-cargo fmt -- --check
-
-echo '--- Clippy'
-# Force clippy to consider all local sources
-# https://github.com/rust-lang/rust-clippy/issues/4612
-find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
-cargo clippy --all-targets --all-features -- -D warnings
diff --git a/scripts/ci/docs b/scripts/ci/docs
index 368e915f..647880ce 100755
--- a/scripts/ci/docs
+++ b/scripts/ci/docs
@@ -1,6 +1,5 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo "--- Docs"
-RUSTDOCFLAGS="-D broken-intra-doc-links -D warnings" \
-cargo doc --no-deps --workspace --document-private-items --all-features
+RUSTDOCFLAGS="-D rustdoc::broken-intra-doc-links -D warnings" \
+cargo doc --no-deps --workspace --document-private-items
diff --git a/scripts/ci/fmt b/scripts/ci/fmt
new file mode 100755
index 00000000..698940b8
--- /dev/null
+++ b/scripts/ci/fmt
@@ -0,0 +1,4 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+cargo +nightly fmt -- --check
diff --git a/scripts/ci/lint b/scripts/ci/lint
new file mode 100755
index 00000000..2e206d75
--- /dev/null
+++ b/scripts/ci/lint
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+# Force clippy to consider all local sources
+# https://github.com/rust-lang/rust-clippy/issues/4612
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets -- -D warnings
+
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets --features replication-v3 -- -D warnings
diff --git a/scripts/ci/run b/scripts/ci/run
index 170e733d..228977be 100755
--- a/scripts/ci/run
+++ b/scripts/ci/run
@@ -1,7 +1,8 @@
 #!/usr/bin/env bash
 set -eou pipefail
 
-./scripts/ci/clippy
+./scripts/ci/fmt
+./scripts/ci/lint
 ./scripts/ci/build-test
 ./scripts/ci/docs
 ./scripts/ci/advisory
diff --git a/scripts/ci/test-fast b/scripts/ci/test-fast
index b1bc92d3..d0619af6 100755
--- a/scripts/ci/test-fast
+++ b/scripts/ci/test-fast
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Library tests'
-cargo test --lib --all-features unit
+cargo test --lib unit
diff --git a/std-ext/Cargo.toml b/std-ext/Cargo.toml
index 9750198f..766ba940 100644
--- a/std-ext/Cargo.toml
+++ b/std-ext/Cargo.toml
@@ -7,5 +7,9 @@ license = "GPL-3.0-or-later"
 description = "Monkey patches of std types"
 
 [lib]
-doctest = true
+doctest = false
 test = false
+
+[features]
+default = []
+unstable = []
diff --git a/std-ext/src/iter.rs b/std-ext/src/iter.rs
deleted file mode 100644
index 9754b401..00000000
--- a/std-ext/src/iter.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright ┬й 2019-2020 The Radicle Foundation <hello@radicle.foundation>
-//
-// This file is part of radicle-link, distributed under the GPLv3 with Radicle
-// Linking Exception. For full terms see the included LICENSE file.
-
-pub trait IteratorExt {
-    /// Converts an interator of triples into a triple of containers, analogous
-    /// to [`Iterator::unzip`].
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use radicle_std_ext::iter::IteratorExt as _;
-    ///
-    /// let a = [(1, 2, 3), (4, 5, 6)];
-    ///
-    /// let (left, middle, right): (Vec<_>, Vec<_>, Vec<_>) = a.iter().copied().unzip3();
-    ///
-    /// assert_eq!(left, [1, 4]);
-    /// assert_eq!(middle, [2, 5]);
-    /// assert_eq!(right, [3, 6]);
-    /// ```
-    fn unzip3<A, B, C, FromA, FromB, FromC>(self) -> (FromA, FromB, FromC)
-    where
-        FromA: Default + Extend<A>,
-        FromB: Default + Extend<B>,
-        FromC: Default + Extend<C>,
-        Self: Sized + Iterator<Item = (A, B, C)>,
-    {
-        fn extend<'a, A, B, C>(
-            ts: &'a mut impl Extend<A>,
-            us: &'a mut impl Extend<B>,
-            vs: &'a mut impl Extend<C>,
-        ) -> impl FnMut((), (A, B, C)) + 'a {
-            move |(), (t, u, v)| {
-                ts.extend_one(t);
-                us.extend_one(u);
-                vs.extend_one(v);
-            }
-        }
-
-        let mut ts: FromA = Default::default();
-        let mut us: FromB = Default::default();
-        let mut vs: FromC = Default::default();
-
-        let (lower_bound, _) = self.size_hint();
-        if lower_bound > 0 {
-            ts.extend_reserve(lower_bound);
-            us.extend_reserve(lower_bound);
-            vs.extend_reserve(lower_bound);
-        }
-
-        self.fold((), extend(&mut ts, &mut us, &mut vs));
-
-        (ts, us, vs)
-    }
-}
-
-impl<T> IteratorExt for T where T: Sized + Iterator {}
diff --git a/std-ext/src/lib.rs b/std-ext/src/lib.rs
index 563e2aba..55c47c42 100644
--- a/std-ext/src/lib.rs
+++ b/std-ext/src/lib.rs
@@ -3,6 +3,17 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(extend_one)]
-pub mod iter;
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+pub mod ops;
 pub mod result;
+
+pub type Void = std::convert::Infallible;
+
+pub mod prelude {
+    use super::*;
+
+    pub use super::Void;
+    pub use ops::{FromResidual, Try};
+    pub use result::ResultExt;
+}
diff --git a/std-ext/src/ops.rs b/std-ext/src/ops.rs
new file mode 100644
index 00000000..9dc48a5b
--- /dev/null
+++ b/std-ext/src/ops.rs
@@ -0,0 +1,173 @@
+// Copyright ┬й 2021 The Radicle Link Contributors
+//
+// This file is part of radicle-link, distributed under the GPLv3 with Radicle
+// Linking Exception. For full terms see the included LICENSE file.
+
+//! Provides Try-trait for stable rust
+//!
+//! Probably doesn't work with `?`-desugaring. If the `nightly` feature is
+//! enabled for this crate, the `std` version is enabled.
+
+#[cfg(not(feature = "nightly"))]
+pub use stable::{FromResidual, Try};
+#[cfg(feature = "nightly")]
+pub use std::ops::{FromResidual, Try};
+
+mod stable {
+    use std::{convert, ops::ControlFlow, task::Poll};
+
+    pub trait Try: FromResidual {
+        type Output;
+        type Residual;
+
+        fn from_output(output: Self::Output) -> Self;
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;
+    }
+
+    pub trait FromResidual<R = <Self as Try>::Residual> {
+        fn from_residual(residual: R) -> Self;
+    }
+
+    impl<B, C> Try for ControlFlow<B, C> {
+        type Output = C;
+        type Residual = ControlFlow<B, convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            ControlFlow::Continue(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                ControlFlow::Continue(c) => ControlFlow::Continue(c),
+                ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),
+            }
+        }
+    }
+
+    impl<B, C> FromResidual for ControlFlow<B, C> {
+        #[inline]
+        fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {
+            match residual {
+                ControlFlow::Break(b) => ControlFlow::Break(b),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T> Try for Option<T> {
+        type Output = T;
+        type Residual = Option<convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Some(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Some(v) => ControlFlow::Continue(v),
+                None => ControlFlow::Break(None),
+            }
+        }
+    }
+
+    impl<T> FromResidual for Option<T> {
+        #[inline]
+        fn from_residual(residual: Option<convert::Infallible>) -> Self {
+            match residual {
+                None => None,
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Result<T, E> {
+        type Output = T;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Ok(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Ok(v) => ControlFlow::Continue(v),
+                Err(e) => ControlFlow::Break(Err(e)),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
+        #[inline]
+        fn from_residual(residual: Result<convert::Infallible, E>) -> Self {
+            match residual {
+                Err(e) => Err(From::from(e)),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Option<Result<T, E>>> {
+        type Output = Poll<Option<T>>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(|x| x.map(Ok))
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),
+                Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),
+                Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Option<Result<T, F>>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Some(Err(From::from(e)))),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Result<T, E>> {
+        type Output = Poll<T>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(Ok)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),
+                Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Err(From::from(e))),
+                _ => unreachable!(),
+            }
+        }
+    }
+}
diff --git a/test/Cargo.toml b/test/Cargo.toml
index 4106f1fb..151eb9c8 100644
--- a/test/Cargo.toml
+++ b/test/Cargo.toml
@@ -14,7 +14,7 @@ replication-v3 = ["librad/replication-v3"]
 
 [dependencies]
 assert_cmd = "2"
-assert_matches = "1"
+assert_matches = "1.5.0"
 anyhow = "1"
 async-stream = "0.3"
 async-trait = "0"
@@ -112,6 +112,9 @@ path = "../git-ext"
 [dependencies.radicle-git-helpers]
 path = "../git-helpers"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.rand]
 version = "0.8"
 features = [ "small_rng" ]
diff --git a/test/src/lib.rs b/test/src/lib.rs
index 47ab36ce..15441c6c 100644
--- a/test/src/lib.rs
+++ b/test/src/lib.rs
@@ -3,11 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(bool_to_option)]
-#![feature(never_type)]
-#![feature(assert_matches)]
-#![feature(path_try_exists)]
-
+#[cfg(test)]
+#[macro_use]
+extern crate assert_matches;
 #[macro_use]
 extern crate lazy_static;
 #[cfg(test)]
@@ -19,6 +17,7 @@ extern crate futures_await_test;
 #[cfg(test)]
 #[macro_use]
 extern crate link_canonical;
+extern crate radicle_std_ext as std_ext;
 
 #[macro_use]
 pub mod daemon;
diff --git a/test/src/librad/git.rs b/test/src/librad/git.rs
index d07a06c1..f9295e6f 100644
--- a/test/src/librad/git.rs
+++ b/test/src/librad/git.rs
@@ -7,12 +7,12 @@ use std::io;
 
 use anyhow::anyhow;
 use either::Either::*;
-
 use librad::{
     git::{identities, storage::Storage, Urn},
     identities::{payload, *},
     SecretKey,
 };
+use std_ext::Void;
 
 use crate::tempdir::WithTmpDir;
 
@@ -236,7 +236,7 @@ impl<'a> Project<'a> {
 
     pub fn verify<F>(&self, lookup: F) -> Result<VerifiedProject, error::VerifyProject>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         self.dev
             .git
@@ -246,7 +246,7 @@ impl<'a> Project<'a> {
 
     pub fn assert_verifies<F>(&self, lookup: F) -> anyhow::Result<()>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         let verified = self.verify(lookup)?.into_inner();
         anyhow::ensure!(
diff --git a/test/src/ssh.rs b/test/src/ssh.rs
index 239c46fc..5dc78f53 100644
--- a/test/src/ssh.rs
+++ b/test/src/ssh.rs
@@ -3,10 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use std::{
-    fs,
-    process::{Command, Stdio},
-};
+use std::process::{Command, Stdio};
 
 use rad_clib::keys::ssh::SshAuthSock;
 
@@ -32,7 +29,6 @@ pub fn with_ssh_agent<F, T>(callback: F) -> anyhow::Result<T>
 where
     F: FnOnce(SshAuthSock) -> anyhow::Result<T>,
 {
-    fs::try_exists("ssh-agent").expect("`ssh-agent` was not found, it is needed to run this test");
     let sock = ssh_auth_sock();
     let path = match &*sock {
         SshAuthSock::Uds(path) => path,
diff --git a/test/src/test/integration/daemon/gossip.rs b/test/src/test/integration/daemon/gossip.rs
index d96fddc5..91ab1575 100644
--- a/test/src/test/integration/daemon/gossip.rs
+++ b/test/src/test/integration/daemon/gossip.rs
@@ -5,7 +5,6 @@
 
 use std::time::{Duration, SystemTime};
 
-use assert_matches::assert_matches;
 use futures::{future, StreamExt as _};
 use tokio::time::timeout;
 
@@ -188,18 +187,19 @@ fn can_ask_and_clone_project() -> Result<(), anyhow::Error> {
 
         let alice_tracked = state::tracked(&alice_peer.peer, urn.clone()).await?;
 
-        assert_matches!(
-            alice_tracked.first().unwrap(),
+        match alice_tracked.first().unwrap() {
             radicle_daemon::project::peer::Peer::Remote {
                 peer_id,
-                status: radicle_daemon::project::peer::Status::Replicated(
-                    radicle_daemon::project::peer::Replicated { role, .. }
-                ),
+                status:
+                    radicle_daemon::project::peer::Status::Replicated(
+                        radicle_daemon::project::peer::Replicated { role, .. },
+                    ),
             } => {
-                assert_eq!(*peer_id, bob_peer.peer_id);
-                assert_eq!(*role, radicle_daemon::project::peer::Role::Tracker);
-            }
-        );
+                assert_eq!(peer_id, &bob_peer.peer_id);
+                assert_eq!(role, &radicle_daemon::project::peer::Role::Tracker);
+            },
+            _ => unreachable!(),
+        }
 
         Ok(())
     })
diff --git a/test/src/test/integration/daemon/replication.rs b/test/src/test/integration/daemon/replication.rs
index c265892f..8cbf550b 100644
--- a/test/src/test/integration/daemon/replication.rs
+++ b/test/src/test/integration/daemon/replication.rs
@@ -5,7 +5,6 @@
 
 use std::convert::TryFrom;
 
-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;
 
 use librad::{
diff --git a/test/src/test/integration/daemon/working_copy.rs b/test/src/test/integration/daemon/working_copy.rs
index 3e2ea9ae..ac4aa7da 100644
--- a/test/src/test/integration/daemon/working_copy.rs
+++ b/test/src/test/integration/daemon/working_copy.rs
@@ -3,10 +3,8 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use radicle_daemon::{project::checkout, state, RunConfig};
-
-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;
+use radicle_daemon::{project::checkout, state, RunConfig};
 
 use crate::{
     daemon::common::{blocking, shia_le_pathbuf, Harness},
diff --git a/test/src/test/integration/librad/scenario/collaboration.rs b/test/src/test/integration/librad/scenario/collaboration.rs
index 4eb34bd5..ec0a933f 100644
--- a/test/src/test/integration/librad/scenario/collaboration.rs
+++ b/test/src/test/integration/librad/scenario/collaboration.rs
@@ -35,7 +35,7 @@ fn can_add_maintainer() {
 
         let proj = {
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/collaborative_objects.rs b/test/src/test/integration/librad/scenario/collaborative_objects.rs
index 5ee0c2f6..51c3a75b 100644
--- a/test/src/test/integration/librad/scenario/collaborative_objects.rs
+++ b/test/src/test/integration/librad/scenario/collaborative_objects.rs
@@ -86,7 +86,7 @@ fn collab_object_crud() {
         let peer2 = net.peers().index(1);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/menage.rs b/test/src/test/integration/librad/scenario/menage.rs
index 0e4b7a6f..c4238a7e 100644
--- a/test/src/test/integration/librad/scenario/menage.rs
+++ b/test/src/test/integration/librad/scenario/menage.rs
@@ -84,7 +84,7 @@ fn a_trois() {
         let peer3 = net.peers().index(2);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -234,7 +234,7 @@ fn threes_a_crowd() {
         }
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/tracked_references.rs b/test/src/test/integration/librad/scenario/tracked_references.rs
index 7ed57b63..d0593d63 100644
--- a/test/src/test/integration/librad/scenario/tracked_references.rs
+++ b/test/src/test/integration/librad/scenario/tracked_references.rs
@@ -58,7 +58,7 @@ fn can_see_tracked_references() {
         let peer2 = net.peers().index(1);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/updated_delegate.rs b/test/src/test/integration/librad/scenario/updated_delegate.rs
index 6733dafb..cfaf5c5b 100644
--- a/test/src/test/integration/librad/scenario/updated_delegate.rs
+++ b/test/src/test/integration/librad/scenario/updated_delegate.rs
@@ -39,7 +39,7 @@ fn can_replicate_with_updated_delegate() {
 
         let person = {
             let person = peer1
-                .using_storage(move |storage| TestPerson::create(storage))
+                .using_storage(TestPerson::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/working_copy.rs b/test/src/test/integration/librad/scenario/working_copy.rs
index cbaa0fa3..77e1e090 100644
--- a/test/src/test/integration/librad/scenario/working_copy.rs
+++ b/test/src/test/integration/librad/scenario/working_copy.rs
@@ -78,7 +78,7 @@ fn can_fetch() {
         let peer2_events = peer2.subscribe();
 
         let proj = peer1
-            .using_storage(move |store| TestProject::create(store))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/smoke/clone.rs b/test/src/test/integration/librad/smoke/clone.rs
index f67a8cbe..e6f3d87f 100644
--- a/test/src/test/integration/librad/smoke/clone.rs
+++ b/test/src/test/integration/librad/smoke/clone.rs
@@ -147,7 +147,7 @@ struct Host<'a> {
 impl<'a> Host<'a> {
     async fn init(peer: &'a RunningTestPeer) -> Host<'a> {
         let project = peer
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -170,7 +170,7 @@ impl Leecher<'_> {
                 (
                     host_peer,
                     supply_addr_hints
-                        .then_some(host_addrs)
+                        .then(|| host_addrs)
                         .into_iter()
                         .flatten()
                         .collect(),
diff --git a/test/src/test/integration/librad/smoke/gossip.rs b/test/src/test/integration/librad/smoke/gossip.rs
index fdf169de..c06a4983 100644
--- a/test/src/test/integration/librad/smoke/gossip.rs
+++ b/test/src/test/integration/librad/smoke/gossip.rs
@@ -60,7 +60,7 @@ fn fetches_on_gossip_notify() {
         let peer1 = net.peers().index(0);
         let peer2 = net.peers().index(1);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -201,7 +201,7 @@ fn ask_and_clone() {
         let proj = {
             let events = peer1.subscribe();
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/interrogation.rs b/test/src/test/integration/librad/smoke/interrogation.rs
index 617daae9..227496b1 100644
--- a/test/src/test/integration/librad/smoke/interrogation.rs
+++ b/test/src/test/integration/librad/smoke/interrogation.rs
@@ -38,7 +38,7 @@ fn responds() {
         let TestProject { project, owner } = {
             let events = responder.subscribe();
             let proj = responder
-                .using_storage(move |s| TestProject::create(s))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/regression.rs b/test/src/test/integration/librad/smoke/regression.rs
index 3b85c15a..9600d8a0 100644
--- a/test/src/test/integration/librad/smoke/regression.rs
+++ b/test/src/test/integration/librad/smoke/regression.rs
@@ -31,7 +31,7 @@ fn list_identities_returns_only_local_projects() {
         let peer2 = net.peers().index(1);
         let peer3 = net.peers().index(2);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/properties/librad/identities/generic.rs b/test/src/test/properties/librad/identities/generic.rs
index c21d488d..b5a2edfb 100644
--- a/test/src/test/properties/librad/identities/generic.rs
+++ b/test/src/test/properties/librad/identities/generic.rs
@@ -5,15 +5,15 @@
 
 use std::collections::BTreeMap;
 
-use nonempty::NonEmpty;
-use proptest::prelude::*;
-
 use librad::identities::{
     delegation::Delegations,
     generic::{error, Doc, Identity},
     sign::Signatures,
     Verifying,
 };
+use nonempty::NonEmpty;
+use proptest::prelude::*;
+use std_ext::Void;
 
 use crate::librad::identities::generic::*;
 
@@ -175,7 +175,7 @@ proptest! {
             tail[tail.len() - 1].clone()
         };
         let folded = root
-            .verify(tail.into_iter().map(|x| Ok::<_, !>(Verifying::from(x))))
+            .verify(tail.into_iter().map(|x| Ok::<_, Void>(Verifying::from(x))))
             .unwrap();
 
         assert_eq!(folded.head.into_inner(), expected)
diff --git a/test/src/test/unit/librad/identities/git/project.rs b/test/src/test/unit/librad/identities/git/project.rs
index 0dfef7ea..0be415fd 100644
--- a/test/src/test/unit/librad/identities/git/project.rs
+++ b/test/src/test/unit/librad/identities/git/project.rs
@@ -6,7 +6,6 @@
 use std::collections::BTreeMap;
 
 use either::Either::*;
-
 use librad::{
     git::Urn,
     identities::{
@@ -19,6 +18,7 @@ use librad::{
     },
     SecretKey,
 };
+use std_ext::Void;
 
 use crate::librad::git::{repo, Device, Project};
 
@@ -354,6 +354,6 @@ fn current_heads_from<'a>(
         .collect()
 }
 
-fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, !> + '_ {
+fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, Void> + '_ {
     move |urn| Ok(*map.get(&urn).unwrap())
 }
diff --git a/test/src/test/unit/librad/net/upgrade.rs b/test/src/test/unit/librad/net/upgrade.rs
index 715df4d5..90b88204 100644
--- a/test/src/test/unit/librad/net/upgrade.rs
+++ b/test/src/test/unit/librad/net/upgrade.rs
@@ -4,7 +4,6 @@
 // Linking Exception. For full terms see the included LICENSE file.
 
 use futures::try_join;
-
 use librad::{
     net::upgrade::{
         upgrade,
diff --git a/test/src/test/unit/rad_identities/git/checkout.rs b/test/src/test/unit/rad_identities/git/checkout.rs
index 9ce01c03..f2b39a9f 100644
--- a/test/src/test/unit/rad_identities/git/checkout.rs
+++ b/test/src/test/unit/rad_identities/git/checkout.rs
@@ -67,7 +67,7 @@ fn remote_checkout() {
         let temp = tempdir().unwrap();
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
-- 
2.34.1


From kim@eagain.st Tue Dec 14 07:30:47 2021
Delivered-To: alex@memoryandthought.me
Received: by 2002:a02:a1cd:0:0:0:0:0 with SMTP id o13csp6481258jah;
        Mon, 13 Dec 2021 23:31:02 -0800 (PST)
X-Google-Smtp-Source: ABdhPJyH0wAm6P2UYU46001VYOROe4Xic2wPwwrHQ6rOcCm1iWkUdsbj6f6yhzcFJLQfe6HhgIpi
X-Received: by 2002:ac8:5485:: with SMTP id h5mr4115378qtq.672.1639467062458;
        Mon, 13 Dec 2021 23:31:02 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1639467062; cv=none;
        d=google.com; s=arc-20160816;
        b=ygP+DThmTKpgw/W7xnvTTI1Udq8buT7uVQiYgkyUgbpRYEvrd2/ZMLKwB72Iq70GM9
         XAPxtLCE3ULavGgB+28C7gZGiuSbBNmZqmFx2RRCOmm6rdq5zKqNWQvW3qiULPVBHjJy
         ySa3E2LnayIkXgMYMaPEAldJy0MZ6m47RXCCWR4Su4BRRlmksMUaxsS6MvcQYA829FpW
         h50XGElF/76Ma5ZxnxLryQLaVr3DbzKsHURCZIbhEm+IxTtXCv4IRoSAtQW5Gb9bghtC
         l0YeNJz3LWwi4kdwXm1c5j3mpdQMXxQfb51ATKTFNFwUfqWw9MpN51eCg/icaKhjah/J
         RP6w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=sender:list-id:list-post:archived-at:list-archive:list-subscribe
         :list-unsubscribe:content-transfer-encoding:mime-version:references
         :in-reply-to:message-id:date:subject:cc:to:from:dkim-signature
         :dkim-signature;
        bh=6K2Ys6Ub7UD3yFQGk8+gKQAZ5SOZ58SuZp7F8417l+s=;
        b=xK/NvR4CgbBqrGAIO21JwznOSm7bWYNcr9OJBbgTODqnNVJKWCf9sjNoVMcH0qdOw5
         l6aERfrjKkBenNgfcdpuvSRY9MVgFZiZE8+GmJYRDLsNpDdD2cmAUdEcitQ+d1x5X3Qb
         oF+kzTsp89qi3cfAelXIVJ5nJxr4pFk4KExU3v0m6m3p4ff4RRu6xFdFM2g+3N8WKbV+
         u13d0ys+fqLjhvJVXzgHHSyZvc5jdRCy5ROsXsqD2rU/+vOceTDtTgNTJ+HdHqqEeNp0
         SbLwR6Arj6JxW2Wflie5SHVPWkN3sJXNqqu+O0zbnL188JIkuxkA6l91TXp5BWVH2EJr
         OFAw==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=mJeWd0jl;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=QCk143Dc;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Return-Path: <lists@sr.ht>
Received: from mail-b.sr.ht (mail-b.sr.ht. [173.195.146.151])
        by mx.google.com with ESMTPS id o19si13934426qtk.756.2021.12.13.23.31.02
        for <alex@memoryandthought.me>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Mon, 13 Dec 2021 23:31:02 -0800 (PST)
Received-SPF: pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) client-ip=173.195.146.151;
Authentication-Results: mx.google.com;
       dkim=pass header.i=@lists.sr.ht header.s=srht header.b=mJeWd0jl;
       dkim=pass header.i=@eagain.st header.s=key1 header.b=QCk143Dc;
       spf=pass (google.com: domain of lists@sr.ht designates 173.195.146.151 as permitted sender) smtp.mailfrom=lists@sr.ht;
       dmarc=pass (p=QUARANTINE sp=QUARANTINE dis=NONE) header.from=eagain.st
Authentication-Results: mail-b.sr.ht; dkim=pass header.d=eagain.st header.i=@eagain.st
DKIM-Signature: a=rsa-sha256; bh=sD885r77+Y7OtlDKfbvcETOdQCG9L+gjwHO8iPlaT64=;
 c=simple/simple; d=lists.sr.ht;
 h=From:To:Cc:Subject:Date:In-Reply-To:References:List-Unsubscribe:List-Subscribe:List-Archive:List-Post:List-ID;
 q=dns/txt; s=srht; t=1639467062; v=1;
 b=mJeWd0jlzBYrVuxPWFvc7Aaxd+GkETYei1MrpmbG7cI4o/MSwBf26AkqJnjQ0lL5E4WiJFAB
 bQql+e9Amg3VaeZeNR2U4txRjQBwXmq7vi0JVSMRiPfC5cCBLimGTVsNDUvD6ieDFjSg36TnYb5
 2LrenfbQ9qS3xX3z3hc9K4bgbbQTqCOztcyVt9D6yCAcIs3BPdW4GC3q6R5Ma4H0757+Zi3VDuF
 xJD18ZeRketlPPuzOfCmil0db5jpwGf21n5axgH1SRMSfo6sUIzmuIomHq1BBJNpZCFsH+Ggti1
 NrRuJ/o2qfy5oAEqQd1Hv/L13hilf/y/ul/sp1F9/S5aA==
Received: from lists.my.domain (unknown [173.195.146.144])
	by mail-b.sr.ht (Postfix) with ESMTPSA id E419311F320
	for <alex@memoryandthought.me>; Tue, 14 Dec 2021 07:31:01 +0000 (UTC)
Received: from out0.migadu.com (out0.migadu.com [94.23.1.103])
	by mail-b.sr.ht (Postfix) with ESMTPS id 342AD11F027
	for <~radicle-link/dev@lists.sr.ht>; Tue, 14 Dec 2021 07:30:58 +0000 (UTC)
X-Report-Abuse: Please report any abuse attempt to abuse@migadu.com and include these headers.
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=eagain.st; s=key1;
	t=1639467053;
	h=from:from:reply-to:subject:subject:date:date:message-id:message-id:
	 to:to:cc:cc:mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references;
	bh=6K2Ys6Ub7UD3yFQGk8+gKQAZ5SOZ58SuZp7F8417l+s=;
	b=QCk143DcFUQcA1zs/7K+einXILNoqIPREmwxmKsrmweNFAJ71nqG70Qa442c8GbLovKl+d
	wozCQVBzZECL5r4XFuadJNEJF/ylAUoT/c8kVY8DVAQ6fMX+MYtJh+OljW9erlJ93S+btY
	46nkehPoURv0fDSn6S7xzEec9M4BhIk=
From: Kim Altintop <kim@eagain.st>
To: ~radicle-link/dev@lists.sr.ht
Cc: Kim Altintop <kim@eagain.st>
Subject: [PATCH radicle-link 1/1] Stable Rust
Date: Tue, 14 Dec 2021 08:30:47 +0100
Message-Id: <20211214073047.13255-2-kim@eagain.st>
In-Reply-To: <20211214073047.13255-1-kim@eagain.st>
References: <20211213155631.182523-1-kim@eagain.st>
 <20211214073047.13255-1-kim@eagain.st>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Migadu-Flow: FLOW_OUT
X-Migadu-Auth-User: kim@eagain.st
X-Sourcehut-Patchset-Status: UNKNOWN
List-Unsubscribe: <mailto:~radicle-link/dev+unsubscribe@lists.sr.ht?subject=unsubscribe>
List-Subscribe: <mailto:~radicle-link/dev+subscribe@lists.sr.ht?subject=subscribe>
List-Archive: <https://lists.sr.ht/~radicle-link/dev>
Archived-At: <https://lists.sr.ht/~radicle-link/dev/%3C20211214073047.13255-2-kim%40eagain.st%3E>
List-Post: <mailto:~radicle-link/dev@lists.sr.ht>
List-ID: ~radicle-link/dev <~radicle-link/dev.lists.sr.ht>
Sender: ~radicle-link/dev <~radicle-link/dev@lists.sr.ht>

Make all crates compile under stable rust.

A number of `std` features we've been using were either stabilised, or
are unlikely to ever be stabilised. Also GATs don't seem to ever arrive
in a shape or form comprehensible to mere mortals. So let's stop chasing
and reformulate all code to compile under stable.

Note that:

- there does not seem to be a workaround for the `backtrace` feature

  This was used in one place in the `daemon` crate to manually add
  backtrace information to an error message, which may or may not be
  that useful. Executable crates using `anyhow` at the top level should
  still get backtrace information, although this may require to enable
  `anyhow`'s `backtrace` feature.

- a `Try` trait is provided via `radicle-std-ext`

  This will probably not work with `?` desugaring, but we're not using
  that at the moment. The "real" Try trait can be enabled using the
  feature `nightly` when a nightly toolchain is used. Note that
  `nightly` was chosen over `unstable`, as we may want to use the latter
  for our own unstable features at some point.

- the never type (`!`) is provided as `Void` from `radicle-std-ext`

  Regrettably, the never type is one of those features which are
  unlikely to be stabilised anytime soon. We alias `Void` to
  `Infallible` however, so in case it _does_ get stabilised we'll get
  the actual thing and not an incompatible type.

- our `rustfmt` rules require nightly

  Build scripts have been adjusted to accomodate for that, but note that
  editor hooks and such may need to be adjusted by contributors.

- stable clippy has very different opinions

  Sorry for the noise.

- specifically, box patterns is marked "perma-unstable"

  I have thus opted to ignore all lints about large enum variants for
  error types and use unboxed values. Pattern matching on boxes is
  rather painful, so it might be good to review errors for whether they
  are actually meant to be scrutinized, and convert variants which
  aren't to trait objects.

Fixes #476
Signed-off-by: Kim Altintop <kim@eagain.st>
---
 .builds/linux-x86_64.yml                      |   8 +-
 .github/workflows/ci.yaml                     |  42 ++++-
 cob/Cargo.toml                                |   5 -
 cob/src/lib.rs                                |   4 +-
 cob/src/refs_storage.rs                       |  10 +-
 daemon/src/lib.rs                             |   1 -
 daemon/src/peer.rs                            |   2 +-
 daemon/src/peer/run_state.rs                  |   2 +-
 daemon/src/peer/run_state/input.rs            |   3 +-
 daemon/src/request/waiting_room.rs            |   5 +-
 daemon/src/state.rs                           |   4 +-
 e2e/Cargo.toml                                |   3 +
 e2e/src/bin/ephemeral-peer.rs                 |   7 +-
 git-helpers/src/remote_helper.rs              |   7 +-
 librad/Cargo.toml                             |   5 -
 librad/src/git/fetch/specs.rs                 |   2 +-
 librad/src/git/identities/any.rs              |   3 +-
 librad/src/git/identities/relations.rs        |   1 +
 librad/src/git/include.rs                     |   1 +
 librad/src/git/storage.rs                     |   3 +-
 librad/src/git/storage/config.rs              |   6 +-
 librad/src/git/storage/pool.rs                |   3 +-
 librad/src/git/storage/read.rs                |   4 +-
 librad/src/lib.rs                             |  17 +-
 librad/src/net/peer.rs                        |  22 ++-
 librad/src/net/peer/storage.rs                |  10 +-
 librad/src/net/protocol.rs                    |   9 +-
 librad/src/net/protocol/cache.rs              |   7 +-
 librad/src/net/protocol/event.rs              |   4 +-
 librad/src/net/protocol/io/connections.rs     |  16 +-
 librad/src/net/protocol/state.rs              |   3 +-
 librad/src/net/quic/endpoint.rs               |   4 +-
 librad/src/net/replication/v3/context.rs      |  60 +++---
 link-async/Cargo.toml                         |  11 +-
 link-async/src/lib.rs                         |   5 +-
 link-async/src/tasks.rs                       |  13 +-
 link-canonical-derive/Cargo.toml              |   3 -
 link-crypto/Cargo.toml                        |   2 +-
 link-crypto/src/lib.rs                        |   5 +-
 link-crypto/src/signer.rs                     |  15 +-
 link-git/src/lib.rs                           |   2 -
 link-identities/src/delegation/direct.rs      |   3 +-
 link-identities/src/lib.rs                    |   5 +-
 link-identities/src/urn.rs                    |   4 +-
 link-replication/Cargo.toml                   |   3 +
 link-replication/src/eval/rad.rs              |   2 +-
 link-replication/src/fetch.rs                 |   2 +-
 link-replication/src/io/refdb.rs              |  36 ++--
 link-replication/src/lib.rs                   |  13 +-
 link-replication/src/peek/clone.rs            |   4 +-
 link-replication/src/refdb.rs                 |  21 ++-
 link-replication/src/refdb/mem.rs             |  45 ++---
 link-replication/src/state.rs                 |  32 ++--
 link-replication/src/transmit.rs              |   1 +
 link-replication/src/validation.rs            |  19 +-
 macros/Cargo.toml                             |   1 +
 macros/src/lib.rs                             |  20 +-
 node-lib/src/lib.rs                           |   2 -
 node-lib/src/protocol.rs                      |   2 +-
 node-lib/src/tracking.rs                      |  79 ++++----
 rad-clib/Cargo.toml                           |   1 -
 rad-exe/src/cli/main.rs                       |   5 +-
 rad-exe/src/lib.rs                            |   2 -
 rad-identities/Cargo.toml                     |   3 +
 rad-identities/src/git/existing.rs            |   3 +-
 rad-identities/src/git/include.rs             |   1 +
 rad-identities/src/git/new.rs                 |   6 +-
 rad-identities/src/lib.rs                     |   6 +-
 rad-identities/src/rad_refs.rs                |   1 +
 rad-identities/src/tracking.rs                |   1 +
 rust-toolchain                                |   1 -
 scripts/ci/advisory                           |  11 +-
 scripts/ci/build-bins                         |   3 +-
 scripts/ci/build-test                         |   6 +-
 scripts/ci/clippy                             |  11 --
 scripts/ci/docs                               |   7 +-
 scripts/ci/fmt                                |   4 +
 scripts/ci/lint                               |  10 +
 scripts/ci/run                                |   3 +-
 scripts/ci/test-fast                          |   5 +-
 std-ext/Cargo.toml                            |   6 +-
 std-ext/src/iter.rs                           |  59 ------
 std-ext/src/lib.rs                            |  15 +-
 std-ext/src/ops.rs                            | 173 ++++++++++++++++++
 test/Cargo.toml                               |   5 +-
 test/src/lib.rs                               |   9 +-
 test/src/librad/git.rs                        |   6 +-
 test/src/ssh.rs                               |   6 +-
 test/src/test/integration/daemon/gossip.rs    |  20 +-
 .../test/integration/daemon/replication.rs    |   1 -
 .../test/integration/daemon/working_copy.rs   |   4 +-
 .../librad/scenario/collaboration.rs          |   2 +-
 .../librad/scenario/collaborative_objects.rs  |   2 +-
 .../integration/librad/scenario/menage.rs     |   4 +-
 .../librad/scenario/tracked_references.rs     |   2 +-
 .../librad/scenario/updated_delegate.rs       |   2 +-
 .../librad/scenario/working_copy.rs           |   2 +-
 .../test/integration/librad/smoke/clone.rs    |   4 +-
 .../test/integration/librad/smoke/gossip.rs   |   4 +-
 .../integration/librad/smoke/interrogation.rs |   2 +-
 .../integration/librad/smoke/regression.rs    |   2 +-
 .../properties/librad/identities/generic.rs   |   8 +-
 .../unit/librad/identities/git/project.rs     |   4 +-
 test/src/test/unit/librad/net/upgrade.rs      |   1 -
 .../test/unit/rad_identities/git/checkout.rs  |   2 +-
 105 files changed, 589 insertions(+), 479 deletions(-)
 delete mode 100644 rust-toolchain
 delete mode 100755 scripts/ci/clippy
 create mode 100755 scripts/ci/fmt
 create mode 100755 scripts/ci/lint
 delete mode 100644 std-ext/src/iter.rs
 create mode 100644 std-ext/src/ops.rs

diff --git a/.builds/linux-x86_64.yml b/.builds/linux-x86_64.yml
index 98b345a4..f43f2bf8 100644
--- a/.builds/linux-x86_64.yml
+++ b/.builds/linux-x86_64.yml
@@ -6,8 +6,7 @@ sources:
   - https://git.sr.ht/~radicle-link/radicle-link
 tasks:
   - setup: |
-      toolchain=$(cat radicle-link/rust-toolchain)
-      rustup toolchain install "$toolchain" \
+      rustup toolchain install stable nightly \
           --profile minimal --component clippy --component rustfmt
 
       deny_version="0.11.0"
@@ -25,9 +24,12 @@ tasks:
 
       cd radicle-link/
       cargo fetch
+  - fmt: |
+      cd radicle-link/
+      ./scripts/ci/fmt
   - lint: |
       cd radicle-link/
-      ./scripts/ci/clippy
+      ./scripts/ci/lint
   - advisories: |
       cd radicle-link/
       cargo deny check advisories ||:
diff --git a/.github/workflows/ci.yaml b/.github/workflows/ci.yaml
index 21c74653..38666176 100644
--- a/.github/workflows/ci.yaml
+++ b/.github/workflows/ci.yaml
@@ -1,6 +1,19 @@
 name: ci
 on: [push, pull_request]
 jobs:
+  fmt:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: nightly
+          components: rustfmt
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/fmt
+        shell: bash
+
   lint:
     runs-on: ubuntu-latest
     steps:
@@ -8,9 +21,22 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
+          components: clippy
+      - uses: Swatinem/rust-cache@v1
+      - run: ./scripts/ci/lint
+        shell: bash
+
+  docs:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
-      - run: ./scripts/ci/clippy
+      - run: ./scripts/ci/docs
         shell: bash
 
   cargo-deny:
@@ -29,12 +55,18 @@ jobs:
 
   linux:
     runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        toolchain:
+          - stable
+          - nightly
+    continue-on-error: ${{ matrix.toolchain == 'nightly' }}
     steps:
       - uses: actions/checkout@master
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: ${{ matrix.toolchain }}
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -48,7 +80,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/build-test
         shell: bash
@@ -63,7 +95,7 @@ jobs:
       - uses: actions-rs/toolchain@v1
         with:
           profile: minimal
-          components: rustfmt, clippy
+          toolchain: stable
       - uses: Swatinem/rust-cache@v1
       - run: ./scripts/ci/test-fast
         shell: bash
diff --git a/cob/Cargo.toml b/cob/Cargo.toml
index 47aacac9..70867d03 100644
--- a/cob/Cargo.toml
+++ b/cob/Cargo.toml
@@ -51,8 +51,3 @@ path = "../git-ext"
 [dependencies.automerge]
 git = "https://github.com/automerge/automerge-rs.git"
 rev = "e72571962b51c2f0726fb534890ef3b4f7c74dfc"
-
-
-[dev-dependencies]
-rand = "0.8"
-env_logger = "0"
diff --git a/cob/src/lib.rs b/cob/src/lib.rs
index 9e58dfce..d19d0976 100644
--- a/cob/src/lib.rs
+++ b/cob/src/lib.rs
@@ -170,7 +170,7 @@ impl TypeName {
     /// A string representation of the typename which will match the typename in
     /// regular expressions. This primarily escapes periods
     pub fn regex_safe_string(&self) -> String {
-        self.0.replace(".", "\\.")
+        self.0.replace('.', "\\.")
     }
 }
 
@@ -265,6 +265,7 @@ impl From<&git2::Oid> for ObjectId {
 pub struct CollaborativeObject {
     /// The identity (person or project) this collaborative object is authorized
     /// with respect to
+    #[allow(unused)]
     authorizing_identity_urn: Urn,
     /// The typename of this object
     typename: TypeName,
@@ -273,6 +274,7 @@ pub struct CollaborativeObject {
     /// The id of the object
     id: ObjectId,
     /// The schema any changes to this object must respect
+    #[allow(unused)]
     schema: Schema,
 }
 
diff --git a/cob/src/refs_storage.rs b/cob/src/refs_storage.rs
index ee9786fe..ef775363 100644
--- a/cob/src/refs_storage.rs
+++ b/cob/src/refs_storage.rs
@@ -11,6 +11,7 @@ use git2::Reference;
 use link_identities::git::Urn;
 
 /// References to the tips of a collaborative object
+#[derive(Default)]
 pub struct ObjectRefs<'a> {
     /// The reference (if any) which represents the tip of the changes authored
     /// by the identity which owns the underlying storage
@@ -19,15 +20,6 @@ pub struct ObjectRefs<'a> {
     pub remote: Vec<Reference<'a>>,
 }
 
-impl<'a> Default for ObjectRefs<'a> {
-    fn default() -> Self {
-        ObjectRefs {
-            local: None,
-            remote: Vec::new(),
-        }
-    }
-}
-
 impl<'a> std::fmt::Debug for ObjectRefs<'a> {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         let local_dbg = self
diff --git a/daemon/src/lib.rs b/daemon/src/lib.rs
index 7f0a4c2d..dd9b1162 100644
--- a/daemon/src/lib.rs
+++ b/daemon/src/lib.rs
@@ -27,7 +27,6 @@
     clippy::similar_names,
     clippy::too_many_lines
 )]
-#![feature(hash_set_entry, never_type, backtrace)]
 
 #[cfg(test)]
 extern crate assert_matches;
diff --git a/daemon/src/peer.rs b/daemon/src/peer.rs
index eabfc760..81392b1f 100644
--- a/daemon/src/peer.rs
+++ b/daemon/src/peer.rs
@@ -234,7 +234,7 @@ where
                                 Err(error) => {
                                     tracing::error!(?error, "accept error");
                                 },
-                                Ok(never) => never,
+                                Ok(never) => unreachable!("absurd: {}", never),
                             };
                         },
                         Err(e) => {
diff --git a/daemon/src/peer/run_state.rs b/daemon/src/peer/run_state.rs
index d5a4d276..e1024f13 100644
--- a/daemon/src/peer/run_state.rs
+++ b/daemon/src/peer/run_state.rs
@@ -213,7 +213,7 @@ impl RunState {
                 if !self.stats.connected_peers.is_empty() && self.stats.membership_active > 0 =>
             {
                 vec![Command::Announce]
-            }
+            },
             _ => vec![],
         }
     }
diff --git a/daemon/src/peer/run_state/input.rs b/daemon/src/peer/run_state/input.rs
index 185718ae..5b4234c2 100644
--- a/daemon/src/peer/run_state/input.rs
+++ b/daemon/src/peer/run_state/input.rs
@@ -5,9 +5,8 @@
 
 use std::{net::SocketAddr, time::SystemTime};
 
-use tokio::sync::oneshot;
-
 use librad::{git::Urn, net, net::peer::ProtocolEvent, PeerId};
+use tokio::sync::oneshot;
 
 use crate::{
     peer::announcement,
diff --git a/daemon/src/request/waiting_room.rs b/daemon/src/request/waiting_room.rs
index abf636de..0b4df62e 100644
--- a/daemon/src/request/waiting_room.rs
+++ b/daemon/src/request/waiting_room.rs
@@ -330,11 +330,8 @@ impl<T, D> WaitingRoom<T, D> {
         T: Clone,
     {
         #[allow(clippy::non_ascii_literal)]
-        let mut reason_str = anyhow::Chain::new(reason.as_ref())
+        let reason_str = anyhow::Chain::new(reason.as_ref())
             .fold("".to_string(), |acc, e| format!("{} той {}", acc, e));
-        if let Some(bt) = reason.backtrace() {
-            reason_str.push_str(&bt.to_string());
-        }
         self.transition(
             |request| match request {
                 SomeRequest::Cloning(request) => Some(request),
diff --git a/daemon/src/state.rs b/daemon/src/state.rs
index dbcd6815..9ab2fb3d 100644
--- a/daemon/src/state.rs
+++ b/daemon/src/state.rs
@@ -80,9 +80,7 @@ pub async fn default_owner<S>(peer: &Peer<S>) -> Result<Option<LocalIdentity>, E
 where
     S: Clone + Signer,
 {
-    Ok(peer
-        .using_storage(move |store| local::default(store))
-        .await??)
+    Ok(peer.using_storage(local::default).await??)
 }
 
 /// Set the default owner for this `PeerApi`.
diff --git a/e2e/Cargo.toml b/e2e/Cargo.toml
index 9de75e70..ea4cdf27 100644
--- a/e2e/Cargo.toml
+++ b/e2e/Cargo.toml
@@ -22,6 +22,9 @@ tracing = "0.1"
 [dependencies.librad]
 path = "../librad"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.1"
 features = ["rt-multi-thread", "macros"]
diff --git a/e2e/src/bin/ephemeral-peer.rs b/e2e/src/bin/ephemeral-peer.rs
index 09b53520..0c5298c5 100644
--- a/e2e/src/bin/ephemeral-peer.rs
+++ b/e2e/src/bin/ephemeral-peer.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(never_type)]
-
 use std::{
     net::{SocketAddr, ToSocketAddrs},
     panic,
@@ -33,6 +31,7 @@ use librad::{
     SecretKey,
 };
 use radicle_link_e2e::logging;
+use radicle_std_ext::Void;
 use tempfile::tempdir;
 use tokio::task::JoinError;
 
@@ -201,7 +200,7 @@ where
     }
 }
 
-async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
+async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<Void> {
     loop {
         tokio::time::sleep(Duration::from_secs(10)).await;
         let stats = peer.stats().await;
@@ -209,7 +208,7 @@ async fn stdout_stats(peer: Peer<SecretKey>) -> anyhow::Result<!> {
     }
 }
 
-async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<!> {
+async fn graphite_stats(peer: Peer<SecretKey>, graphite_addr: SocketAddr) -> anyhow::Result<Void> {
     tracing::debug!("stats collector");
 
     let peer_id_str = peer.peer_id().to_string();
diff --git a/git-helpers/src/remote_helper.rs b/git-helpers/src/remote_helper.rs
index 68e25820..067ee597 100644
--- a/git-helpers/src/remote_helper.rs
+++ b/git-helpers/src/remote_helper.rs
@@ -30,17 +30,12 @@ use librad::{
 
 use crate::credential;
 
+#[derive(Default)]
 pub struct Config {
     /// Signer for radicle artifacts created by pushes.
     pub signer: Option<BoxedSigner>,
 }
 
-impl Default for Config {
-    fn default() -> Self {
-        Self { signer: None }
-    }
-}
-
 // FIXME: this should be defined elsewhere to be consistent between applications
 const SECRET_KEY_FILE: &str = "librad.key";
 
diff --git a/librad/Cargo.toml b/librad/Cargo.toml
index 7de4f51c..cd09a9f2 100644
--- a/librad/Cargo.toml
+++ b/librad/Cargo.toml
@@ -45,7 +45,6 @@ percent-encoding = "2"
 picky-asn1 = "0.3.2"
 picky-asn1-der = "0.2.5"
 picky-asn1-x509 = "0.6.0"
-priority-queue = "1.0"
 rand = "0.8"
 rand_pcg = "0.3.1"
 regex = "1.3"
@@ -142,10 +141,6 @@ features = ["derive"]
 version = "1.13.1"
 features = ["rt-multi-thread", "net", "time"]
 
-[dependencies.tokio-util]
-version = "0.6"
-features = ["compat"]
-
 [dependencies.url]
 version = "2.1"
 features = ["serde"]
diff --git a/librad/src/git/fetch/specs.rs b/librad/src/git/fetch/specs.rs
index e0b220fa..8f05f4d4 100644
--- a/librad/src/git/fetch/specs.rs
+++ b/librad/src/git/fetch/specs.rs
@@ -346,7 +346,7 @@ pub mod refspecs {
                     }
                 };
 
-                targets_match.then_some({
+                targets_match.then(|| {
                     let dst = Reference {
                         remote: Some(tracked_peer.clone()),
                         category,
diff --git a/librad/src/git/identities/any.rs b/librad/src/git/identities/any.rs
index ecaee69f..5525dcb2 100644
--- a/librad/src/git/identities/any.rs
+++ b/librad/src/git/identities/any.rs
@@ -7,6 +7,7 @@ use std::convert::TryFrom;
 
 use git_ext::is_not_found_err;
 use itertools::Itertools as _;
+use std_ext::Void;
 
 use super::{
     super::{
@@ -102,7 +103,7 @@ where
     Xor::try_from_iter(list_urns(storage)?.map_ok(SomeUrn::from))
 }
 
-fn identities<S>(storage: &S) -> Identities<!>
+fn identities<S>(storage: &S) -> Identities<Void>
 where
     S: AsRef<storage::ReadOnly>,
 {
diff --git a/librad/src/git/identities/relations.rs b/librad/src/git/identities/relations.rs
index fa2621bf..0e23c288 100644
--- a/librad/src/git/identities/relations.rs
+++ b/librad/src/git/identities/relations.rs
@@ -23,6 +23,7 @@ use crate::{
 };
 
 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/librad/src/git/include.rs b/librad/src/git/include.rs
index e67dcdf2..8384ce6e 100644
--- a/librad/src/git/include.rs
+++ b/librad/src/git/include.rs
@@ -24,6 +24,7 @@ pub const GIT_CONFIG_PATH_KEY: &str = "include.path";
 
 #[derive(Debug, thiserror::Error)]
 #[non_exhaustive]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Io(#[from] io::Error),
diff --git a/librad/src/git/storage.rs b/librad/src/git/storage.rs
index 5fb93956..de021b16 100644
--- a/librad/src/git/storage.rs
+++ b/librad/src/git/storage.rs
@@ -14,6 +14,7 @@ use std::{
 use crypto::{BoxedSigner, SomeSigner};
 use git2::string_array::StringArray;
 use git_ext::{self as ext, is_not_found_err};
+use std_ext::Void;
 
 use crate::{
     collaborative_objects::CollaborativeObjects,
@@ -178,7 +179,7 @@ impl Storage {
         Config::try_from(self)
     }
 
-    pub fn config_readonly(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config_readonly(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(self.as_raw())?)
     }
 
diff --git a/librad/src/git/storage/config.rs b/librad/src/git/storage/config.rs
index e2d1711f..a0ba66ce 100644
--- a/librad/src/git/storage/config.rs
+++ b/librad/src/git/storage/config.rs
@@ -9,7 +9,7 @@ use std::{convert::TryFrom, io, marker::PhantomData, path::PathBuf};
 
 use crypto::BoxedSigner;
 use git_ext::{self as ext, is_not_found_err};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;
 use thiserror::Error;
 
 use super::{super::identities::local::LocalIdentity, Storage};
@@ -73,7 +73,7 @@ impl<'a> TryFrom<&'a Storage> for Config<'a, BoxedSigner> {
     }
 }
 
-impl TryFrom<&git2::Repository> for Config<'_, PhantomData<!>> {
+impl TryFrom<&git2::Repository> for Config<'_, PhantomData<Void>> {
     type Error = git2::Error;
 
     fn try_from(repo: &git2::Repository) -> Result<Self, Self::Error> {
@@ -210,7 +210,7 @@ impl<S> Config<'_, S> {
     }
 }
 
-impl Config<'_, PhantomData<!>> {
+impl Config<'_, PhantomData<Void>> {
     pub fn readonly(repo: &git2::Repository) -> Result<Self, git2::Error> {
         Self::try_from(repo)
     }
diff --git a/librad/src/git/storage/pool.rs b/librad/src/git/storage/pool.rs
index 32a9e8e4..77faa8d4 100644
--- a/librad/src/git/storage/pool.rs
+++ b/librad/src/git/storage/pool.rs
@@ -11,6 +11,7 @@ use std::{
 
 use deadpool::managed::{self, Manager, Object, RecycleResult};
 use parking_lot::RwLock;
+use std_ext::Void;
 use thiserror::Error;
 
 use super::{error, read, ReadOnly, Storage};
@@ -105,7 +106,7 @@ pub struct Config<W> {
     write: W,
 }
 
-pub type ReadConfig = Config<PhantomData<!>>;
+pub type ReadConfig = Config<PhantomData<Void>>;
 pub type ReadWriteConfig<S> = Config<Write<S>>;
 
 impl ReadConfig {
diff --git a/librad/src/git/storage/read.rs b/librad/src/git/storage/read.rs
index 39a33cdb..38dec400 100644
--- a/librad/src/git/storage/read.rs
+++ b/librad/src/git/storage/read.rs
@@ -10,7 +10,7 @@ use thiserror::Error;
 
 use git2::string_array::StringArray;
 use git_ext::{self as ext, blob, is_not_found_err, RefLike, RefspecPattern};
-use std_ext::result::ResultExt as _;
+use std_ext::prelude::*;
 
 use crate::{
     git::types::{reference, Many, One, Reference},
@@ -196,7 +196,7 @@ impl ReadOnly {
     /// 3. The SHA of the tag was not the same as the resolved reference
     /// 4. The `oid` was the [`zero`][`git2::Oid::zero`] SHA.
 
-    pub fn config(&self) -> Result<Config<PhantomData<!>>, Error> {
+    pub fn config(&self) -> Result<Config<PhantomData<Void>>, Error> {
         Ok(Config::try_from(&self.backend)?)
     }
 
diff --git a/librad/src/lib.rs b/librad/src/lib.rs
index 92b7a65f..513abb28 100644
--- a/librad/src/lib.rs
+++ b/librad/src/lib.rs
@@ -3,22 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
-#![allow(incomplete_features)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]
-#![feature(backtrace)]
-#![feature(bool_to_option)]
-#![feature(box_patterns)]
-#![feature(btree_drain_filter)]
-#![feature(control_flow_enum)]
-#![feature(core_intrinsics)]
-#![feature(drain_filter)]
-#![feature(generic_associated_types)]
-#![feature(ip)]
-#![feature(never_type)]
-#![feature(try_trait_v2)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 #[macro_use]
 extern crate async_trait;
diff --git a/librad/src/net/peer.rs b/librad/src/net/peer.rs
index 6ca2b3b8..a9af048e 100644
--- a/librad/src/net/peer.rs
+++ b/librad/src/net/peer.rs
@@ -131,6 +131,7 @@ where
             pool,
             caches.urns.clone(),
             repl.clone(),
+            #[cfg(feature = "replication-v3")]
             phone.clone(),
         );
         let user_store = git::storage::Pool::new(
@@ -192,15 +193,17 @@ where
                     .map_err(|_| "network reconnect")
                     .try_filter_map(move |event| {
                         let provider = match event {
-                            Upstream::Gossip(box Gossip::Put {
-                                provider,
-                                payload:
-                                    gossip::Payload {
-                                        urn: payload_urn, ..
-                                    },
-                                ..
-                            }) if payload_urn == urn => Some(provider),
-
+                            Upstream::Gossip(gossip) => match *gossip {
+                                Gossip::Put {
+                                    provider,
+                                    payload:
+                                        gossip::Payload {
+                                            urn: payload_urn, ..
+                                        },
+                                    ..
+                                } if payload_urn == urn => Some(provider),
+                                _ => None,
+                            },
                             _ => None,
                         };
                         future::ok(provider)
@@ -346,7 +349,6 @@ where
             self.phone.clone(),
             self.config.protocol.clone(),
             self.config.signer.clone(),
-            self.repl.clone(),
             self.peer_store.clone(),
             self.caches.clone(),
         )
diff --git a/librad/src/net/peer/storage.rs b/librad/src/net/peer/storage.rs
index f176926b..12b97c56 100644
--- a/librad/src/net/peer/storage.rs
+++ b/librad/src/net/peer/storage.rs
@@ -14,6 +14,8 @@ use link_async::Spawner;
 use nonzero_ext::nonzero;
 use parking_lot::RwLock;
 
+#[cfg(feature = "replication-v3")]
+use crate::net::protocol::TinCans;
 use crate::{
     git::{
         storage::{self, Pool, PoolError, PooledRef, ReadOnlyStorage as _},
@@ -22,7 +24,7 @@ use crate::{
     },
     identities::urn,
     net::{
-        protocol::{broadcast, cache, gossip, TinCans},
+        protocol::{broadcast, cache, gossip},
         replication::{self, Replication},
     },
     rate_limit::{Keyed, RateLimiter},
@@ -41,13 +43,13 @@ type SeenFilter = StableBloomFilter<DefaultBuildHashKernels<RandomState>>;
 
 #[derive(Clone)]
 pub struct Storage {
-    conf: Config,
     pool: Pool<storage::Storage>,
     urns: cache::urns::Filter,
     seen: Arc<RwLock<SeenFilter>>,
     rate: Arc<RateLimiter<Keyed<(PeerId, Urn)>>>,
     exec: Arc<Spawner>,
     repl: Replication,
+    #[cfg(feature = "replication-v3")]
     tins: TinCans,
 }
 
@@ -58,10 +60,9 @@ impl Storage {
         pool: Pool<storage::Storage>,
         urns: cache::urns::Filter,
         repl: Replication,
-        tins: TinCans,
+        #[cfg(feature = "replication-v3")] tins: TinCans,
     ) -> Self {
         Self {
-            conf,
             pool,
             urns,
             // TODO: parameters pulled out of thin air
@@ -77,6 +78,7 @@ impl Storage {
             )),
             exec,
             repl,
+            #[cfg(feature = "replication-v3")]
             tins,
         }
     }
diff --git a/librad/src/net/protocol.rs b/librad/src/net/protocol.rs
index 8b5c1699..c35732d6 100644
--- a/librad/src/net/protocol.rs
+++ b/librad/src/net/protocol.rs
@@ -11,6 +11,7 @@ use link_async::Spawner;
 use nonempty::NonEmpty;
 use nonzero_ext::nonzero;
 use rand_pcg::Pcg64Mcg;
+use std_ext::Void;
 use tracing::Instrument as _;
 
 use super::{
@@ -21,7 +22,7 @@ use super::{
 };
 use crate::{
     git::storage,
-    net::replication::{self, Replication},
+    net::replication,
     paths::Paths,
     rate_limit::RateLimiter,
     PeerId,
@@ -122,7 +123,7 @@ impl<S> Bound<S> {
         disco: D,
     ) -> (
         impl FnOnce(),
-        impl Future<Output = Result<!, io::error::Accept>>,
+        impl Future<Output = Result<Void, io::error::Accept>>,
     )
     where
         S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
@@ -151,7 +152,6 @@ pub async fn bind<Sign, Store>(
     phone: TinCans,
     config: Config,
     signer: Sign,
-    replication: Replication,
     storage: Store,
     caches: cache::Caches,
 ) -> Result<Bound<Store>, error::Bootstrap>
@@ -186,7 +186,6 @@ where
         endpoint,
         membership,
         storage,
-        replication,
         phone: phone.clone(),
         config: StateConfig {
             paths: Arc::new(config.paths),
@@ -218,7 +217,7 @@ pub fn accept<Store, Disco>(
     disco: Disco,
 ) -> (
     impl FnOnce(),
-    impl Future<Output = Result<!, io::error::Accept>>,
+    impl Future<Output = Result<Void, io::error::Accept>>,
 )
 where
     Store: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
diff --git a/librad/src/net/protocol/cache.rs b/librad/src/net/protocol/cache.rs
index d42a37f2..93c0205b 100644
--- a/librad/src/net/protocol/cache.rs
+++ b/librad/src/net/protocol/cache.rs
@@ -31,6 +31,7 @@ pub mod urns {
 
     #[derive(Debug, Error)]
     #[non_exhaustive]
+    #[allow(clippy::large_enum_variant)]
     pub enum Error {
         #[error(transparent)]
         Build(#[from] xor::BuildError<identities::Error>),
@@ -61,7 +62,7 @@ pub mod urns {
     #[derive(Clone)]
     pub struct Filter {
         inner: Arc<RwLock<FilterInner>>,
-        watch: storage::Watcher,
+        _watch: storage::Watcher,
     }
 
     struct FilterInner {
@@ -85,13 +86,13 @@ pub mod urns {
                 Arc::new(RwLock::new(inner))
             };
 
-            let (watch, events) = storage.watch().namespaces()?;
+            let (_watch, events) = storage.watch().namespaces()?;
             thread::spawn({
                 let filter = Arc::clone(&inner);
                 move || recache_thread(storage, filter, events, observe)
             });
 
-            Ok(Self { inner, watch })
+            Ok(Self { inner, _watch })
         }
 
         pub fn contains(&self, urn: &SomeUrn) -> bool {
diff --git a/librad/src/net/protocol/event.rs b/librad/src/net/protocol/event.rs
index 282ff002..24b98d3b 100644
--- a/librad/src/net/protocol/event.rs
+++ b/librad/src/net/protocol/event.rs
@@ -196,7 +196,9 @@ pub mod upstream {
 
         pub fn gossip_from(peer: PeerId) -> impl Fn(&Upstream) -> bool {
             move |event| match event {
-                Upstream::Gossip(box Gossip::Put { provider, .. }) => provider.peer_id == peer,
+                Upstream::Gossip(gossip) => match gossip.as_ref() {
+                    Gossip::Put { provider, .. } => provider.peer_id == peer,
+                },
                 _ => false,
             }
         }
diff --git a/librad/src/net/protocol/io/connections.rs b/librad/src/net/protocol/io/connections.rs
index ee05fdc7..35d7c038 100644
--- a/librad/src/net/protocol/io/connections.rs
+++ b/librad/src/net/protocol/io/connections.rs
@@ -3,7 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use std::net::SocketAddr;
+use std::net::{IpAddr, SocketAddr};
 
 use either::Either;
 use futures::{
@@ -11,6 +11,7 @@ use futures::{
     stream::{Stream, StreamExt as _},
 };
 use indexmap::IndexSet;
+use std_ext::Void;
 
 pub use super::error;
 use super::streams;
@@ -31,7 +32,7 @@ use crate::{
 pub(in crate::net::protocol) async fn incoming<S, I>(
     state: State<S>,
     ingress: I,
-) -> Result<!, error::Accept>
+) -> Result<Void, error::Accept>
 where
     S: ProtocolStorage<SocketAddr, Update = gossip::Payload> + Clone + 'static,
     I: futures::Stream<
@@ -85,7 +86,16 @@ where
 {
     fn routable(addr: &SocketAddr) -> bool {
         let ip = addr.ip();
-        !(ip.is_unspecified() || ip.is_documentation() || ip.is_multicast())
+        !(ip.is_unspecified()
+            || ip.is_multicast()
+            || match ip {
+                IpAddr::V4(ipv4) => ipv4.is_documentation(),
+                IpAddr::V6(ipv6) =>
+                // ipv6.is_documentation() requires !#[feature(ip)]
+                {
+                    (ipv6.segments()[0] == 0x2001) && (ipv6.segments()[1] == 0xdb8)
+                },
+            })
     }
 
     let addrs = addrs.into_iter().filter(routable).collect::<IndexSet<_>>();
diff --git a/librad/src/net/protocol/state.rs b/librad/src/net/protocol/state.rs
index 2119f362..dce707e2 100644
--- a/librad/src/net/protocol/state.rs
+++ b/librad/src/net/protocol/state.rs
@@ -24,7 +24,7 @@ use super::{
 };
 use crate::{
     git::storage::{self, PoolError, PooledRef},
-    net::{quic, replication::Replication},
+    net::quic,
     paths::Paths,
     rate_limit::{self, Direct, Keyed, RateLimiter},
     PeerId,
@@ -44,7 +44,6 @@ pub(super) struct State<S> {
     pub endpoint: Endpoint,
     pub membership: membership::Hpv<Pcg64Mcg, SocketAddr>,
     pub storage: Storage<S>,
-    pub replication: Replication,
     pub phone: TinCans,
     pub config: StateConfig,
     pub caches: cache::Caches,
diff --git a/librad/src/net/quic/endpoint.rs b/librad/src/net/quic/endpoint.rs
index c8d29154..e154a40e 100644
--- a/librad/src/net/quic/endpoint.rs
+++ b/librad/src/net/quic/endpoint.rs
@@ -63,7 +63,7 @@ pub struct Endpoint<const R: usize> {
     endpoint: quinn::Endpoint,
     listen_addrs: Arc<RwLock<BTreeSet<SocketAddr>>>,
     conntrack: Conntrack,
-    refcount: Arc<()>,
+    _refcount: Arc<()>,
 }
 
 impl<const R: usize> Endpoint<R> {
@@ -101,7 +101,7 @@ impl<const R: usize> Endpoint<R> {
             endpoint,
             listen_addrs: addrs,
             conntrack: conntrack.clone(),
-            refcount: Arc::new(()),
+            _refcount: Arc::new(()),
         };
         let incoming = incoming
             .map(Ok)
diff --git a/librad/src/net/replication/v3/context.rs b/librad/src/net/replication/v3/context.rs
index d9658d32..62efc3f4 100644
--- a/librad/src/net/replication/v3/context.rs
+++ b/librad/src/net/replication/v3/context.rs
@@ -25,6 +25,7 @@ use link_replication::{
     Negotiation,
     Net,
     ObjectId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -34,6 +35,7 @@ use link_replication::{
     VerifiedIdentity,
 };
 use multihash::Multihash;
+use std_ext::Void;
 
 use crate::{
     git::{self, refs, storage::Storage, tracking},
@@ -58,6 +60,7 @@ pub mod error {
     use thiserror::Error;
 
     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Verification {
         #[error("unknown identity kind")]
         UnknownIdentityKind(Box<SomeIdentity>),
@@ -66,16 +69,16 @@ pub mod error {
         MissingDelegate(identities::git::Urn),
 
         #[error(transparent)]
-        Person(#[from] Box<identities::error::VerifyPerson>),
+        Person(#[from] identities::error::VerifyPerson),
 
         #[error(transparent)]
-        Project(#[from] Box<identities::error::VerifyProject>),
+        Project(#[from] identities::error::VerifyProject),
 
         #[error(transparent)]
-        Load(#[from] Box<identities::error::Load>),
+        Load(#[from] identities::error::Load),
 
         #[error(transparent)]
-        Git(#[from] Box<git::identities::Error>),
+        Git(#[from] git::identities::Error),
     }
 
     #[derive(Debug, Error)]
@@ -88,6 +91,7 @@ pub mod error {
     }
 
     #[derive(Debug, Error)]
+    #[allow(clippy::large_enum_variant)]
     pub enum Connection {
         #[error(transparent)]
         Upgrade(#[from] upgrade::Error<quic::BidiStream>),
@@ -95,25 +99,6 @@ pub mod error {
         #[error(transparent)]
         Quic(#[from] quic::Error),
     }
-
-    macro_rules! from_unboxed {
-        ($($t:path)*) => {
-            $(
-                impl From<$t> for Verification {
-                    fn from(e: $t) -> Self {
-                        Self::from(Box::new(e))
-                    }
-                }
-            )*
-        };
-    }
-
-    from_unboxed! {
-        identities::error::VerifyPerson
-        identities::error::VerifyProject
-        identities::error::Load
-        git::identities::Error
-    }
 }
 
 type Network = io::Network<Urn, io::Refdb<io::Odb>, io::Odb, quic::Connection>;
@@ -294,7 +279,7 @@ impl Identities for Context<'_> {
         let id = self
             .store
             .read_only()
-            .identities::<!>()
+            .identities::<Void>()
             .some_identity(*git_ext::Oid::from(head.as_ref().to_owned()))?;
         self.verify(id, resolve)
     }
@@ -442,13 +427,10 @@ impl Iterator for Tracked {
     }
 }
 
-impl Refdb for Context<'_> {
+impl<'c> Refdb for Context<'c> {
     type Oid = <io::Refdb<io::Odb> as Refdb>::Oid;
 
-    type Scan<'a> = <io::Refdb<io::Odb> as Refdb>::Scan<'a>;
-
     type FindError = <io::Refdb<io::Odb> as Refdb>::FindError;
-    type ScanError = <io::Refdb<io::Odb> as Refdb>::ScanError;
     type TxError = <io::Refdb<io::Odb> as Refdb>::TxError;
     type ReloadError = <io::Refdb<io::Odb> as Refdb>::ReloadError;
 
@@ -459,14 +441,6 @@ impl Refdb for Context<'_> {
         self.refdb.refname_to_id(refname)
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.refdb.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -479,6 +453,20 @@ impl Refdb for Context<'_> {
     }
 }
 
+impl<'a> RefScan for &'a Context<'_> {
+    type Oid = <&'a io::Refdb<io::Odb> as RefScan>::Oid;
+    type Scan = <&'a io::Refdb<io::Odb> as RefScan>::Scan;
+    type Error = <&'a io::Refdb<io::Odb> as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        self.refdb.scan(prefix)
+    }
+}
+
 #[async_trait(?Send)]
 impl Net for Context<'_> {
     type Error = <Network as Net>::Error;
diff --git a/link-async/Cargo.toml b/link-async/Cargo.toml
index 7190cfb9..641f5768 100644
--- a/link-async/Cargo.toml
+++ b/link-async/Cargo.toml
@@ -9,6 +9,10 @@ license = "GPL-3.0-or-later"
 doctest = false
 test = false
 
+[features]
+default = []
+nightly = []
+
 [dependencies]
 blocking = "1.0"
 futures = "0.3"
@@ -17,10 +21,9 @@ rand = "0.8"
 thiserror = "1.0"
 tracing = "0.1"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.tokio]
 version = "1.13.1"
 features = ["time"]
-
-[dependencies.tokio-stream]
-version = "0.1.8"
-features = ["time"]
diff --git a/link-async/src/lib.rs b/link-async/src/lib.rs
index 504cf480..2625a6bc 100644
--- a/link-async/src/lib.rs
+++ b/link-async/src/lib.rs
@@ -3,8 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(try_trait_v2)]
-#![feature(min_type_alias_impl_trait)]
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+extern crate radicle_std_ext as std_ext;
 
 mod spawn;
 pub use spawn::{Cancelled, JoinError, Spawner, Stats, Task};
diff --git a/link-async/src/tasks.rs b/link-async/src/tasks.rs
index 0a4418bb..ded71063 100644
--- a/link-async/src/tasks.rs
+++ b/link-async/src/tasks.rs
@@ -3,20 +3,15 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use core::time::Duration;
+use std::{marker::PhantomData, ops::ControlFlow, panic, pin::Pin, task::Poll, time::Duration};
+
 use futures::{
     stream::{FuturesUnordered, StreamExt},
     Future,
     FutureExt,
     Stream,
 };
-use std::{
-    marker::PhantomData,
-    ops::{ControlFlow, Try},
-    panic,
-    pin::Pin,
-    task::Poll,
-};
+use std_ext::ops::Try;
 
 /// Run tasks from a stream of tasks but terminate if the stream is idle for
 /// `idle_timeout`. The idle timeout starts when there are no tasks running and
@@ -166,7 +161,7 @@ struct ReturnRemainingTasks<T: Try> {
 impl<T: Try> Unpin for ReturnRemainingTasks<T> {}
 
 impl<T: Try> OnErrorPolicy<T> for ReturnRemainingTasks<T> {
-    type Output = Result<(), (T::Residual, impl Stream<Item = Result<T, crate::JoinError>>)>;
+    type Output = Result<(), (T::Residual, FuturesUnordered<crate::Task<T>>)>;
     type Err = T::Residual;
 
     fn extract_err(result: T) -> Option<Self::Err> {
diff --git a/link-canonical-derive/Cargo.toml b/link-canonical-derive/Cargo.toml
index c2828939..a6c6adb9 100644
--- a/link-canonical-derive/Cargo.toml
+++ b/link-canonical-derive/Cargo.toml
@@ -13,6 +13,3 @@ convert_case = "0.4"
 proc-macro2 = "1.0"
 quote = "1.0"
 syn = { version = "1.0", features = [ "full" ] }
-
-[dev-dependencies.link-canonical]
-path = "../link-canonical"
\ No newline at end of file
diff --git a/link-crypto/Cargo.toml b/link-crypto/Cargo.toml
index 10941ba4..ad8e9fcd 100644
--- a/link-crypto/Cargo.toml
+++ b/link-crypto/Cargo.toml
@@ -31,7 +31,7 @@ features = ["serde", "minicbor"]
 
 [dependencies.radicle-keystore]
 git = "https://github.com/radicle-dev/radicle-keystore"
-rev = "00f8fb6135f8e4cd097a48e6f0700e08ce4abb04"
+rev = "293ef5d076b27ae3d8f9cff7fd8a5234b2604199"
 features = [ "ssh-agent" ]
 
 [dependencies.serde]
diff --git a/link-crypto/src/lib.rs b/link-crypto/src/lib.rs
index dc34c072..701d81d8 100644
--- a/link-crypto/src/lib.rs
+++ b/link-crypto/src/lib.rs
@@ -3,10 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(associated_type_bounds)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 #[macro_use]
 extern crate async_trait;
diff --git a/link-crypto/src/signer.rs b/link-crypto/src/signer.rs
index 43120afa..d4577fb8 100644
--- a/link-crypto/src/signer.rs
+++ b/link-crypto/src/signer.rs
@@ -14,24 +14,13 @@ use crate::{keys, peer::PeerId};
 
 /// A blanket trait over [`sign::Signer`] that can be shared safely among
 /// threads.
-pub trait Signer:
-    sign::Signer<Error: std::error::Error + Send + Sync + 'static>
-    + Send
-    + Sync
-    + dyn_clone::DynClone
-    + 'static
-{
+pub trait Signer: sign::Signer + Send + Sync + dyn_clone::DynClone + 'static {
     fn sign_blocking(&self, data: &[u8]) -> Result<sign::Signature, <Self as sign::Signer>::Error> {
         block_on(self.sign(data))
     }
 }
 
-impl<T> Signer for T
-where
-    T: sign::Signer + Send + Sync + Clone + 'static,
-    <T as sign::Signer>::Error: std::error::Error + Send + Sync + 'static,
-{
-}
+impl<T> Signer for T where T: sign::Signer + Send + Sync + Clone + 'static {}
 
 // Here be Dragons...
 
diff --git a/link-git/src/lib.rs b/link-git/src/lib.rs
index d190079e..b397c101 100644
--- a/link-git/src/lib.rs
+++ b/link-git/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(array_map, never_type)]
-
 #[macro_use]
 extern crate async_trait;
 
diff --git a/link-identities/src/delegation/direct.rs b/link-identities/src/delegation/direct.rs
index aa64ecf2..516a10c8 100644
--- a/link-identities/src/delegation/direct.rs
+++ b/link-identities/src/delegation/direct.rs
@@ -9,6 +9,7 @@ use thiserror::Error;
 
 use crypto::PublicKey;
 use data::{nonempty::Set as _, NonEmptyOrderedSet};
+use std_ext::Void;
 
 use super::Delegations;
 use crate::{payload, sealed};
@@ -59,7 +60,7 @@ impl Direct {
 }
 
 impl Delegations for Direct {
-    type Error = !;
+    type Error = Void;
 
     fn eligible(&self, votes: BTreeSet<&PublicKey>) -> Result<BTreeSet<&PublicKey>, Self::Error> {
         Ok(self.eligible(votes))
diff --git a/link-identities/src/lib.rs b/link-identities/src/lib.rs
index fff7a24b..d2b22706 100644
--- a/link-identities/src/lib.rs
+++ b/link-identities/src/lib.rs
@@ -3,10 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(bool_to_option, never_type)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 use std::fmt::{self, Display};
 
diff --git a/link-identities/src/urn.rs b/link-identities/src/urn.rs
index 69950aa1..b6dade6b 100644
--- a/link-identities/src/urn.rs
+++ b/link-identities/src/urn.rs
@@ -266,7 +266,7 @@ where
             .ok_or(Self::Err::Missing("namespace"))
             .and_then(|nid| {
                 (nid == "rad")
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidNID(nid.to_string()))
             })?;
 
@@ -275,7 +275,7 @@ where
             .ok_or(Self::Err::Missing("protocol"))
             .and_then(|proto| {
                 (R::PROTOCOL == proto)
-                    .then_some(())
+                    .then(|| ())
                     .ok_or_else(|| Self::Err::InvalidProto(proto.to_string()))
             })?;
 
diff --git a/link-replication/Cargo.toml b/link-replication/Cargo.toml
index bc13b1a8..1193b548 100644
--- a/link-replication/Cargo.toml
+++ b/link-replication/Cargo.toml
@@ -33,3 +33,6 @@ features = ["git2"]
 
 [dependencies.radicle-data]
 path = "../data"
+
+[dependencies.radicle-std-ext]
+path = "../std-ext"
diff --git a/link-replication/src/eval/rad.rs b/link-replication/src/eval/rad.rs
index fe8037b9..327148f7 100644
--- a/link-replication/src/eval/rad.rs
+++ b/link-replication/src/eval/rad.rs
@@ -137,7 +137,7 @@ where
             else {
                 Ok(Ok(Left(newer)))
             }
-        }
+        },
         // Otherwise, theirs:
         //
         // * `rad/id` does not exist, so no other choice
diff --git a/link-replication/src/fetch.rs b/link-replication/src/fetch.rs
index 51b427a2..c1400bba 100644
--- a/link-replication/src/fetch.rs
+++ b/link-replication/src/fetch.rs
@@ -151,7 +151,7 @@ impl<T: AsRef<oid>> Negotiation for Fetch<T> {
             let want: Option<&oid> = self
                 .signed(&r.remote_id, &refname_no_remote)
                 .map(|s| s.as_ref())
-                .or_else(|| self.is_tracked(&r.remote_id).then_some(&r.tip));
+                .or_else(|| self.is_tracked(&r.remote_id).then(|| r.tip.as_ref()));
 
             match (want, have) {
                 (Some(want), Some(have)) if want == have.as_ref() => {
diff --git a/link-replication/src/io/refdb.rs b/link-replication/src/io/refdb.rs
index dfdaba86..09bf9c37 100644
--- a/link-replication/src/io/refdb.rs
+++ b/link-replication/src/io/refdb.rs
@@ -43,6 +43,7 @@ pub mod error {
     use thiserror::Error;
 
     #[derive(Debug, Error)]
+    #[allow(clippy::enum_variant_names)]
     pub enum Find {
         #[error(transparent)]
         Refname(#[from] refs::name::Error),
@@ -415,24 +416,12 @@ impl<D: Odb> Refdb<D> {
     }
 }
 
-impl<D: Odb> refdb::Refdb for Refdb<D> {
+impl<'a, D> refdb::RefScan for &'a Refdb<D> {
     type Oid = ObjectId;
+    type Scan = Scan<'a>;
+    type Error = error::Scan;
 
-    type Scan<'a> = Scan<'a>;
-
-    type FindError = error::Find;
-    type ScanError = error::Scan;
-    type TxError = error::Tx;
-    type ReloadError = error::Reload;
-
-    fn refname_to_id(
-        &self,
-        refname: impl AsRef<BStr>,
-    ) -> Result<Option<Self::Oid>, Self::FindError> {
-        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
-    }
-
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
     where
         O: Into<Option<P>>,
         P: AsRef<str>,
@@ -451,6 +440,21 @@ impl<D: Odb> refdb::Refdb for Refdb<D> {
             inner,
         })
     }
+}
+
+impl<D: Odb> refdb::Refdb for Refdb<D> {
+    type Oid = ObjectId;
+
+    type FindError = error::Find;
+    type TxError = error::Tx;
+    type ReloadError = error::Reload;
+
+    fn refname_to_id(
+        &self,
+        refname: impl AsRef<BStr>,
+    ) -> Result<Option<Self::Oid>, Self::FindError> {
+        self.find_namespaced(&self.namespaced(&mut Cow::from(refname.as_ref()))?)
+    }
 
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
diff --git a/link-replication/src/lib.rs b/link-replication/src/lib.rs
index 05b81791..18d3aac3 100644
--- a/link-replication/src/lib.rs
+++ b/link-replication/src/lib.rs
@@ -3,15 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![allow(private_intra_doc_links, incomplete_features)]
+#![allow(rustdoc::private_intra_doc_links)]
 #![warn(clippy::extra_unused_lifetimes)]
-#![deny(broken_intra_doc_links)]
-#![feature(
-    bool_to_option,
-    generic_associated_types,
-    never_type,
-    unwrap_infallible
-)]
+#![deny(rustdoc::broken_intra_doc_links)]
 
 use std::fmt::Debug;
 
@@ -21,6 +15,7 @@ extern crate async_trait;
 extern crate tracing;
 
 use link_crypto::PeerId;
+use radicle_std_ext::prelude::*;
 
 pub mod error;
 pub use error::Error;
@@ -40,7 +35,7 @@ mod odb;
 pub use odb::Odb;
 
 mod refdb;
-pub use refdb::{Applied, Policy, Refdb, SymrefTarget, Update, Updated};
+pub use refdb::{Applied, Policy, RefScan, Refdb, SymrefTarget, Update, Updated};
 
 mod sigrefs;
 pub use sigrefs::{SignedRefs, Sigrefs};
diff --git a/link-replication/src/peek/clone.rs b/link-replication/src/peek/clone.rs
index d21653fd..6d89cb04 100644
--- a/link-replication/src/peek/clone.rs
+++ b/link-replication/src/peek/clone.rs
@@ -47,9 +47,7 @@ impl Negotiation for ForClone {
 
         let (name, tip) = refs::into_unpacked(r);
         match refs::parse::<Identity>(name.as_bstr())? {
-            parsed
-            @
-            refs::Parsed {
+            parsed @ refs::Parsed {
                 remote: None,
                 inner: Left(_),
             } => Some(FilteredRef::new(name, tip, &self.remote_id, parsed)),
diff --git a/link-replication/src/refdb.rs b/link-replication/src/refdb.rs
index 1aa60962..91565fed 100644
--- a/link-replication/src/refdb.rs
+++ b/link-replication/src/refdb.rs
@@ -16,10 +16,7 @@ pub use mem::Mem;
 pub trait Refdb {
     type Oid: AsRef<oid> + Into<ObjectId>;
 
-    type Scan<'a>: IntoIterator<Item = Result<(BString, Self::Oid), Self::ScanError>> + 'a;
-
     type FindError: std::error::Error + Send + Sync + 'static;
-    type ScanError: std::error::Error + Send + Sync + 'static;
     type TxError: std::error::Error + Send + Sync + 'static;
     type ReloadError: std::error::Error + Send + Sync + 'static;
 
@@ -32,12 +29,6 @@ pub trait Refdb {
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError>;
 
-    /// Traverse all refs in the current namespace matching `predicate`.
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>;
-
     /// Apply the provided ref updates.
     ///
     /// This should be a transaction: either all updates (modulo the ones
@@ -57,6 +48,18 @@ pub trait Refdb {
     fn reload(&mut self) -> Result<(), Self::ReloadError>;
 }
 
+pub trait RefScan {
+    type Oid: AsRef<oid> + Into<ObjectId>;
+    type Scan: Iterator<Item = Result<(BString, Self::Oid), Self::Error>>;
+    type Error: std::error::Error + Send + Sync + 'static;
+
+    /// Traverse all refs in the current namespace matching `prefix`.
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>;
+}
+
 #[derive(Clone, Debug)]
 pub enum Update<'a> {
     Direct {
diff --git a/link-replication/src/refdb/mem.rs b/link-replication/src/refdb/mem.rs
index d767325e..b69b0f44 100644
--- a/link-replication/src/refdb/mem.rs
+++ b/link-replication/src/refdb/mem.rs
@@ -7,8 +7,8 @@ use std::collections::{hash_map, HashMap};
 
 use bstr::{BStr, BString};
 
-use super::{Applied, Refdb, Update, Updated};
-use crate::ObjectId;
+use super::{Applied, RefScan, Refdb, Update, Updated};
+use crate::{ObjectId, Void};
 
 /// A very simple in-memory [`Refdb`].
 ///
@@ -28,12 +28,9 @@ impl From<HashMap<BString, ObjectId>> for Mem {
 impl Refdb for Mem {
     type Oid = ObjectId;
 
-    type Scan<'a> = Scan<'a, ObjectId>;
-
-    type FindError = !;
-    type ScanError = !;
-    type TxError = !;
-    type ReloadError = !;
+    type FindError = Void;
+    type TxError = Void;
+    type ReloadError = Void;
 
     fn refname_to_id(
         &self,
@@ -42,18 +39,6 @@ impl Refdb for Mem {
         Ok(self.refs.get(refname.as_ref()).map(Clone::clone))
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        let prefix = prefix.into();
-        Ok(Scan {
-            pref: prefix.map(|p| p.as_ref().to_owned()),
-            iter: self.refs.iter(),
-        })
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -93,6 +78,24 @@ impl Refdb for Mem {
     }
 }
 
+impl<'a> RefScan for &'a Mem {
+    type Oid = ObjectId;
+    type Scan = Scan<'a, Self::Oid>;
+    type Error = Void;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        let prefix = prefix.into();
+        Ok(Scan {
+            pref: prefix.map(|p| p.as_ref().to_owned()),
+            iter: self.refs.iter(),
+        })
+    }
+}
+
 pub struct Scan<'a, Oid> {
     pref: Option<String>,
     iter: hash_map::Iter<'a, BString, Oid>,
@@ -102,7 +105,7 @@ impl<'a, Oid> Iterator for Scan<'a, Oid>
 where
     Oid: Clone + 'a,
 {
-    type Item = Result<(BString, Oid), !>;
+    type Item = Result<(BString, Oid), Void>;
 
     fn next(&mut self) -> Option<Self::Item> {
         let next = self.iter.next().and_then(|(k, v)| match &self.pref {
diff --git a/link-replication/src/state.rs b/link-replication/src/state.rs
index 296787bc..c5a2e186 100644
--- a/link-replication/src/state.rs
+++ b/link-replication/src/state.rs
@@ -23,6 +23,7 @@ use crate::{
     Net,
     ObjectId,
     PeerId,
+    RefScan,
     Refdb,
     SignedRefs,
     Sigrefs,
@@ -165,7 +166,7 @@ where
         let mut ap = Applied::default();
         for up in other {
             self.tips.push(up.clone().into_owned());
-            ap.append(&mut self.refs.update(Some(up)).into_ok());
+            ap.append(&mut self.refs.update(Some(up)).expect("absurd"));
         }
         ap
     }
@@ -187,17 +188,14 @@ pub(crate) struct Shim<'a, T, U> {
     fetch: &'a mut FetchState<U>,
 }
 
-impl<T, U> Refdb for Shim<'_, T, U>
+impl<'s, T, U> Refdb for Shim<'s, T, U>
 where
     T: Refdb,
     U: Ord,
 {
     type Oid = <refdb::Mem as Refdb>::Oid;
 
-    type Scan<'a> = <refdb::Mem as Refdb>::Scan<'a>;
-
     type FindError = <T as Refdb>::FindError;
-    type ScanError = <refdb::Mem as Refdb>::ScanError;
     type TxError = <refdb::Mem as Refdb>::TxError;
     type ReloadError = <refdb::Mem as Refdb>::ReloadError;
 
@@ -205,7 +203,7 @@ where
         &self,
         refname: impl AsRef<BStr>,
     ) -> Result<Option<Self::Oid>, Self::FindError> {
-        let cached = self.fetch.refs.refname_to_id(&refname).into_ok();
+        let cached = self.fetch.refs.refname_to_id(&refname).expect("absurd");
         if cached.is_some() {
             Ok(cached)
         } else {
@@ -215,14 +213,6 @@ where
         }
     }
 
-    fn scan<O, P>(&self, prefix: O) -> Result<Self::Scan<'_>, Self::ScanError>
-    where
-        O: Into<Option<P>>,
-        P: AsRef<str>,
-    {
-        self.fetch.refs.scan(prefix)
-    }
-
     fn update<'a, I>(&mut self, updates: I) -> Result<Applied<'a>, Self::TxError>
     where
         I: IntoIterator<Item = Update<'a>>,
@@ -235,6 +225,20 @@ where
     }
 }
 
+impl<'a, T, U> RefScan for &'a Shim<'_, T, U> {
+    type Oid = <&'a refdb::Mem as RefScan>::Oid;
+    type Scan = <&'a refdb::Mem as RefScan>::Scan;
+    type Error = <&'a refdb::Mem as RefScan>::Error;
+
+    fn scan<O, P>(self, prefix: O) -> Result<Self::Scan, Self::Error>
+    where
+        O: Into<Option<P>>,
+        P: AsRef<str>,
+    {
+        RefScan::scan(&self.fetch.refs, prefix)
+    }
+}
+
 impl<T, U> SignedRefs for Shim<'_, T, U>
 where
     T: SignedRefs,
diff --git a/link-replication/src/transmit.rs b/link-replication/src/transmit.rs
index 5ab4eaed..fc524dcf 100644
--- a/link-replication/src/transmit.rs
+++ b/link-replication/src/transmit.rs
@@ -79,6 +79,7 @@ pub struct FilteredRef<T: ?Sized> {
 }
 
 impl<T> FilteredRef<T> {
+    #[allow(clippy::unnecessary_lazy_evaluations)]
     pub fn new(
         name: BString,
         tip: ObjectId,
diff --git a/link-replication/src/validation.rs b/link-replication/src/validation.rs
index 3991bb5d..ed565ec6 100644
--- a/link-replication/src/validation.rs
+++ b/link-replication/src/validation.rs
@@ -17,16 +17,17 @@ use crate::{
     refs,
     sigrefs,
     LocalPeer,
-    Refdb,
+    RefScan,
 };
 
 #[tracing::instrument(level = "debug", skip(cx, sigrefs), err)]
-pub fn validate<C, Oid>(
-    cx: &C,
-    sigrefs: &sigrefs::Combined<Oid>,
-) -> Result<Vec<error::Validation>, C::ScanError>
+pub fn validate<'a, C, Oid>(
+    cx: &'a C,
+    sigrefs: &'a sigrefs::Combined<Oid>,
+) -> Result<Vec<error::Validation>, <&'a C as RefScan>::Error>
 where
-    C: LocalPeer + Refdb,
+    C: LocalPeer,
+    &'a C: RefScan,
     Oid: Debug + AsRef<oid>,
 {
     use refs::component::*;
@@ -50,7 +51,7 @@ where
         let prefix = format!("refs/remotes/{}", peer);
         info!("scanning {} for signed refs", prefix);
 
-        for item in Refdb::scan(cx, prefix)? {
+        for item in RefScan::scan(cx, prefix)? {
             let (name, oid) = item?;
 
             trace!("{}", name);
@@ -121,7 +122,7 @@ where
             let prefix = format!("refs/remotes/{}", peer);
             info!(%prefix, "scanning for unsigned trackings");
 
-            for item in Refdb::scan(cx, prefix)? {
+            for item in RefScan::scan(cx, prefix)? {
                 let (name, _oid) = item?;
 
                 trace!("{}", name);
@@ -182,7 +183,7 @@ where
 
         info!(?pids, "scanning for orphans and strange refs");
 
-        for item in Refdb::scan::<_, String>(cx, None)? {
+        for item in RefScan::scan::<_, String>(cx, None)? {
             let (name, _oid) = item?;
 
             trace!("{}", name);
diff --git a/macros/Cargo.toml b/macros/Cargo.toml
index 2d089e05..ffa7347f 100644
--- a/macros/Cargo.toml
+++ b/macros/Cargo.toml
@@ -12,6 +12,7 @@ proc-macro = true
 test = false
 
 [dependencies]
+proc-macro-error = "1.0.4"
 quote = "1"
 syn = "1"
 
diff --git a/macros/src/lib.rs b/macros/src/lib.rs
index a5d1bacb..343129bd 100644
--- a/macros/src/lib.rs
+++ b/macros/src/lib.rs
@@ -3,11 +3,13 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(proc_macro_diagnostic)]
+#[macro_use]
+extern crate proc_macro_error;
 
 use std::convert::TryFrom;
 
 use proc_macro::TokenStream;
+use proc_macro_error::abort;
 use quote::quote;
 use syn::{parse_macro_input, LitStr};
 
@@ -23,6 +25,7 @@ use radicle_git_ext::reference::name::{RefLike, RefspecPattern};
 ///
 /// assert_eq!("lolek/bolek", reflike!("lolek/bolek").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn reflike(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -35,12 +38,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
         },
 
         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefLike literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefLike literal: {}", e);
         },
     }
 }
@@ -55,6 +53,7 @@ pub fn reflike(input: TokenStream) -> TokenStream {
 ///
 /// assert_eq!("refs/heads/*", refspec_pattern!("refs/heads/*").as_str())
 /// ```
+#[proc_macro_error]
 #[proc_macro]
 pub fn refspec_pattern(input: TokenStream) -> TokenStream {
     let lit = parse_macro_input!(input as LitStr);
@@ -67,12 +66,7 @@ pub fn refspec_pattern(input: TokenStream) -> TokenStream {
         },
 
         Err(e) => {
-            lit.span()
-                .unwrap()
-                .error(format!("invalid RefspecPattern literal: {}", e))
-                .emit();
-
-            TokenStream::from(quote! { unimplemented!() })
+            abort!(lit.span(), "invalid RefspecPattern literal: {}", e);
         },
     }
 }
diff --git a/node-lib/src/lib.rs b/node-lib/src/lib.rs
index 4efe3409..9d65c1f4 100644
--- a/node-lib/src/lib.rs
+++ b/node-lib/src/lib.rs
@@ -3,8 +3,6 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(box_patterns)]
-
 pub mod args;
 
 mod cfg;
diff --git a/node-lib/src/protocol.rs b/node-lib/src/protocol.rs
index 588e7242..c26f5e6b 100644
--- a/node-lib/src/protocol.rs
+++ b/node-lib/src/protocol.rs
@@ -50,7 +50,7 @@ where
                     Err(err) => {
                         error!(?err, "accept error");
                     },
-                    Ok(never) => never,
+                    Ok(never) => unreachable!("absurd: {}", never),
                 }
             },
             Err(err) => {
diff --git a/node-lib/src/tracking.rs b/node-lib/src/tracking.rs
index 724410e5..b2088b7e 100644
--- a/node-lib/src/tracking.rs
+++ b/node-lib/src/tracking.rs
@@ -48,49 +48,52 @@ where
     pin_mut!(events);
 
     while let Some(res) = events.next().await {
-        if let Err(err) = res {
-            error!(?err, "event error");
-            continue;
-        }
+        match res {
+            Ok(ProtocolEvent::Gossip(gossip)) => {
+                let Gossip::Put {
+                    payload: Payload { urn, .. },
+                    provider:
+                        PeerInfo {
+                            peer_id,
+                            seen_addrs,
+                            ..
+                        },
+                    result,
+                } = *gossip;
 
-        if let ProtocolEvent::Gossip(box Gossip::Put {
-            payload: Payload { urn, .. },
-            provider:
-                PeerInfo {
-                    peer_id,
-                    seen_addrs,
-                    ..
-                },
-            result: Uninteresting,
-        }) = res.unwrap()
-        {
-            if !tracker.is_tracked(&peer_id, &urn) {
-                continue;
-            }
+                if result != Uninteresting || !tracker.is_tracked(&peer_id, &urn) {
+                    continue;
+                }
 
-            let go = async {
-                let updated = peer
-                    .using_storage({
-                        let urn = urn.clone();
-                        move |storage| tracking::track(storage, &urn, peer_id)
-                    })
-                    .await??;
+                let go = async {
+                    let updated = peer
+                        .using_storage({
+                            let urn = urn.clone();
+                            move |storage| tracking::track(storage, &urn, peer_id)
+                        })
+                        .await??;
 
-                // Skip explicit replication if the peer is already tracked.
-                if updated {
-                    let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
-                    peer.replicate((peer_id, addr_hints), urn.clone(), None)
-                        .await?;
-                }
+                    // Skip explicit replication if the peer is already tracked.
+                    if updated {
+                        let addr_hints = seen_addrs.iter().copied().collect::<Vec<_>>();
+                        peer.replicate((peer_id, addr_hints), urn.clone(), None)
+                            .await?;
+                    }
 
-                Ok::<_, anyhow::Error>(updated)
-            };
+                    Ok::<_, anyhow::Error>(updated)
+                };
+
+                match go.await {
+                    Ok(true) => info!("tracked project {} from {}", urn, peer_id),
+                    Ok(false) => info!("already tracked {} from {}", urn, peer_id),
+                    Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
+                }
+            },
 
-            match go.await {
-                Ok(true) => info!("tracked project {} from {}", urn, peer_id),
-                Ok(false) => info!("already tracked {} from {}", urn, peer_id),
-                Err(err) => error!(?err, "tracking failed for {} from {}", urn, peer_id),
-            }
+            Ok(_) => {},
+            Err(err) => {
+                error!(?err, "event error");
+            },
         }
     }
 
diff --git a/rad-clib/Cargo.toml b/rad-clib/Cargo.toml
index 36a5bce9..884d68b1 100644
--- a/rad-clib/Cargo.toml
+++ b/rad-clib/Cargo.toml
@@ -13,7 +13,6 @@ test = false
 unsafe = []
 
 [dependencies]
-async-global-executor = "2.0.2"
 futures-lite = "1.12.0"
 once_cell = "1.8"
 serde_json = "1.0"
diff --git a/rad-exe/src/cli/main.rs b/rad-exe/src/cli/main.rs
index f0e56196..cbcf559c 100644
--- a/rad-exe/src/cli/main.rs
+++ b/rad-exe/src/cli/main.rs
@@ -26,7 +26,10 @@ pub fn main() -> anyhow::Result<()> {
                     let exe = format!("rad-{}", exe);
                     let status = Command::new(exe.clone()).args(&external[1..]).status();
                     match status {
-                        Ok(status) => Ok(status.exit_ok()?),
+                        Ok(status) => {
+                            anyhow::ensure!(status.success(), status);
+                            Ok(())
+                        },
                         Err(err) => {
                             if let ErrorKind::NotFound = err.kind() {
                                 eprintln!("{} not found", exe);
diff --git a/rad-exe/src/lib.rs b/rad-exe/src/lib.rs
index 05217dab..d26f893e 100644
--- a/rad-exe/src/lib.rs
+++ b/rad-exe/src/lib.rs
@@ -3,6 +3,4 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(exit_status_error)]
-
 pub mod cli;
diff --git a/rad-identities/Cargo.toml b/rad-identities/Cargo.toml
index 737dbd6d..c642860f 100644
--- a/rad-identities/Cargo.toml
+++ b/rad-identities/Cargo.toml
@@ -39,6 +39,9 @@ path = "../librad"
 [dependencies.radicle-git-ext]
 path = "../git-ext"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.serde]
 version = "1.0"
 features = [ "derive" ]
diff --git a/rad-identities/src/git/existing.rs b/rad-identities/src/git/existing.rs
index 56970bb8..702ec727 100644
--- a/rad-identities/src/git/existing.rs
+++ b/rad-identities/src/git/existing.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext,
     std_ext::result::ResultExt as _,
 };
+use std_ext::Void;
 
 use crate::{
     field::{HasBranch, HasName},
@@ -52,7 +53,7 @@ impl<V, P: HasName> Existing<V, P> {
     }
 }
 
-type Invalid = PhantomData<!>;
+type Invalid = PhantomData<Void>;
 
 impl<P: HasName + HasBranch> Existing<Invalid, P> {
     pub fn new(payload: P, path: PathBuf) -> Self {
diff --git a/rad-identities/src/git/include.rs b/rad-identities/src/git/include.rs
index 1c1e85cc..a4e64cc9 100644
--- a/rad-identities/src/git/include.rs
+++ b/rad-identities/src/git/include.rs
@@ -20,6 +20,7 @@ use librad::{
 use crate::field::HasUrn;
 
 #[derive(Debug, thiserror::Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/git/new.rs b/rad-identities/src/git/new.rs
index fb9ccc01..758af792 100644
--- a/rad-identities/src/git/new.rs
+++ b/rad-identities/src/git/new.rs
@@ -13,6 +13,7 @@ use librad::{
     git_ext::OneLevel,
     identities::payload,
 };
+use std_ext::Void;
 
 use crate::{
     field::{HasBranch, HasName},
@@ -46,10 +47,11 @@ impl<V, P: HasName> New<V, P> {
     }
 }
 
-pub type Invalid = PhantomData<!>;
-pub type Valid = PhantomData<!>;
+pub type Invalid = PhantomData<Void>;
+pub type Valid = PhantomData<Void>;
 
 impl<P> New<Invalid, P> {
+    #[allow(clippy::self_named_constructors)]
     pub fn new(payload: P, path: PathBuf) -> Self {
         Self {
             payload,
diff --git a/rad-identities/src/lib.rs b/rad-identities/src/lib.rs
index 90f100a3..d3cdcfd3 100644
--- a/rad-identities/src/lib.rs
+++ b/rad-identities/src/lib.rs
@@ -3,16 +3,14 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(never_type)]
-
 #[macro_use]
 extern crate lazy_static;
+extern crate radicle_std_ext as std_ext;
 
 use std::fmt;
 
-use thiserror::Error;
-
 use librad::{git::Urn, PeerId};
+use thiserror::Error;
 
 pub mod cli;
 
diff --git a/rad-identities/src/rad_refs.rs b/rad-identities/src/rad_refs.rs
index 1a774bd1..705212ee 100644
--- a/rad-identities/src/rad_refs.rs
+++ b/rad-identities/src/rad_refs.rs
@@ -21,6 +21,7 @@ use librad::{
 };
 
 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Identities(#[from] identities::Error),
diff --git a/rad-identities/src/tracking.rs b/rad-identities/src/tracking.rs
index b670d4e1..f8920e06 100644
--- a/rad-identities/src/tracking.rs
+++ b/rad-identities/src/tracking.rs
@@ -14,6 +14,7 @@ use librad::{
 use crate::git::include;
 
 #[derive(Debug, Error)]
+#[allow(clippy::large_enum_variant)]
 pub enum Error {
     #[error(transparent)]
     Include(#[from] include::Error),
diff --git a/rust-toolchain b/rust-toolchain
deleted file mode 100644
index 8398865b..00000000
--- a/rust-toolchain
+++ /dev/null
@@ -1 +0,0 @@
-nightly-2021-06-17
diff --git a/scripts/ci/advisory b/scripts/ci/advisory
index baadc7c9..07e8c72e 100755
--- a/scripts/ci/advisory
+++ b/scripts/ci/advisory
@@ -1,17 +1,8 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- deny: Version'
 cargo deny --version
-
-echo '--- deny: Advisories'
 cargo deny check advisories
-
-echo '--- deny: Licenses'
 cargo deny check licenses
-
-echo '--- deny: Bans'
 cargo deny check bans
-
-echo '--- deny: Sources'
 cargo deny check sources
diff --git a/scripts/ci/build-bins b/scripts/ci/build-bins
index 3a74fcad..4a4c7f8c 100755
--- a/scripts/ci/build-bins
+++ b/scripts/ci/build-bins
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Build'
 cd bins && cargo build --workspace --all-features
diff --git a/scripts/ci/build-test b/scripts/ci/build-test
index c8f22a13..af5330a9 100755
--- a/scripts/ci/build-test
+++ b/scripts/ci/build-test
@@ -1,11 +1,7 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Build'
 cargo build --workspace
 
-echo '--- Test (replication v2)'
 RUST_LOG=error ssh-agent cargo test --workspace
-
-echo '--- Test (replication v3)'
 RUST_LOG=error ssh-agent cargo test --workspace  --features replication-v3
diff --git a/scripts/ci/clippy b/scripts/ci/clippy
deleted file mode 100755
index c63ffe0c..00000000
--- a/scripts/ci/clippy
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env bash
-set -eou pipefail
-
-echo '--- Formatting'
-cargo fmt -- --check
-
-echo '--- Clippy'
-# Force clippy to consider all local sources
-# https://github.com/rust-lang/rust-clippy/issues/4612
-find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
-cargo clippy --all-targets --all-features -- -D warnings
diff --git a/scripts/ci/docs b/scripts/ci/docs
index 368e915f..647880ce 100755
--- a/scripts/ci/docs
+++ b/scripts/ci/docs
@@ -1,6 +1,5 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo "--- Docs"
-RUSTDOCFLAGS="-D broken-intra-doc-links -D warnings" \
-cargo doc --no-deps --workspace --document-private-items --all-features
+RUSTDOCFLAGS="-D rustdoc::broken-intra-doc-links -D warnings" \
+cargo doc --no-deps --workspace --document-private-items
diff --git a/scripts/ci/fmt b/scripts/ci/fmt
new file mode 100755
index 00000000..698940b8
--- /dev/null
+++ b/scripts/ci/fmt
@@ -0,0 +1,4 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+cargo +nightly fmt -- --check
diff --git a/scripts/ci/lint b/scripts/ci/lint
new file mode 100755
index 00000000..2e206d75
--- /dev/null
+++ b/scripts/ci/lint
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+set -eoux pipefail
+
+# Force clippy to consider all local sources
+# https://github.com/rust-lang/rust-clippy/issues/4612
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets -- -D warnings
+
+find . -name "*.rs" -not -path "./target/*" -exec touch "{}" +
+cargo clippy --all-targets --features replication-v3 -- -D warnings
diff --git a/scripts/ci/run b/scripts/ci/run
index 170e733d..228977be 100755
--- a/scripts/ci/run
+++ b/scripts/ci/run
@@ -1,7 +1,8 @@
 #!/usr/bin/env bash
 set -eou pipefail
 
-./scripts/ci/clippy
+./scripts/ci/fmt
+./scripts/ci/lint
 ./scripts/ci/build-test
 ./scripts/ci/docs
 ./scripts/ci/advisory
diff --git a/scripts/ci/test-fast b/scripts/ci/test-fast
index b1bc92d3..d0619af6 100755
--- a/scripts/ci/test-fast
+++ b/scripts/ci/test-fast
@@ -1,5 +1,4 @@
 #!/usr/bin/env bash
-set -eou pipefail
+set -eoux pipefail
 
-echo '--- Library tests'
-cargo test --lib --all-features unit
+cargo test --lib unit
diff --git a/std-ext/Cargo.toml b/std-ext/Cargo.toml
index 9750198f..139840f6 100644
--- a/std-ext/Cargo.toml
+++ b/std-ext/Cargo.toml
@@ -7,5 +7,9 @@ license = "GPL-3.0-or-later"
 description = "Monkey patches of std types"
 
 [lib]
-doctest = true
+doctest = false
 test = false
+
+[features]
+default = []
+nightly = []
diff --git a/std-ext/src/iter.rs b/std-ext/src/iter.rs
deleted file mode 100644
index 9754b401..00000000
--- a/std-ext/src/iter.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright ┬й 2019-2020 The Radicle Foundation <hello@radicle.foundation>
-//
-// This file is part of radicle-link, distributed under the GPLv3 with Radicle
-// Linking Exception. For full terms see the included LICENSE file.
-
-pub trait IteratorExt {
-    /// Converts an interator of triples into a triple of containers, analogous
-    /// to [`Iterator::unzip`].
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use radicle_std_ext::iter::IteratorExt as _;
-    ///
-    /// let a = [(1, 2, 3), (4, 5, 6)];
-    ///
-    /// let (left, middle, right): (Vec<_>, Vec<_>, Vec<_>) = a.iter().copied().unzip3();
-    ///
-    /// assert_eq!(left, [1, 4]);
-    /// assert_eq!(middle, [2, 5]);
-    /// assert_eq!(right, [3, 6]);
-    /// ```
-    fn unzip3<A, B, C, FromA, FromB, FromC>(self) -> (FromA, FromB, FromC)
-    where
-        FromA: Default + Extend<A>,
-        FromB: Default + Extend<B>,
-        FromC: Default + Extend<C>,
-        Self: Sized + Iterator<Item = (A, B, C)>,
-    {
-        fn extend<'a, A, B, C>(
-            ts: &'a mut impl Extend<A>,
-            us: &'a mut impl Extend<B>,
-            vs: &'a mut impl Extend<C>,
-        ) -> impl FnMut((), (A, B, C)) + 'a {
-            move |(), (t, u, v)| {
-                ts.extend_one(t);
-                us.extend_one(u);
-                vs.extend_one(v);
-            }
-        }
-
-        let mut ts: FromA = Default::default();
-        let mut us: FromB = Default::default();
-        let mut vs: FromC = Default::default();
-
-        let (lower_bound, _) = self.size_hint();
-        if lower_bound > 0 {
-            ts.extend_reserve(lower_bound);
-            us.extend_reserve(lower_bound);
-            vs.extend_reserve(lower_bound);
-        }
-
-        self.fold((), extend(&mut ts, &mut us, &mut vs));
-
-        (ts, us, vs)
-    }
-}
-
-impl<T> IteratorExt for T where T: Sized + Iterator {}
diff --git a/std-ext/src/lib.rs b/std-ext/src/lib.rs
index 563e2aba..55c47c42 100644
--- a/std-ext/src/lib.rs
+++ b/std-ext/src/lib.rs
@@ -3,6 +3,17 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(extend_one)]
-pub mod iter;
+#![cfg_attr(feature = "nightly", feature(try_trait_v2))]
+
+pub mod ops;
 pub mod result;
+
+pub type Void = std::convert::Infallible;
+
+pub mod prelude {
+    use super::*;
+
+    pub use super::Void;
+    pub use ops::{FromResidual, Try};
+    pub use result::ResultExt;
+}
diff --git a/std-ext/src/ops.rs b/std-ext/src/ops.rs
new file mode 100644
index 00000000..9dc48a5b
--- /dev/null
+++ b/std-ext/src/ops.rs
@@ -0,0 +1,173 @@
+// Copyright ┬й 2021 The Radicle Link Contributors
+//
+// This file is part of radicle-link, distributed under the GPLv3 with Radicle
+// Linking Exception. For full terms see the included LICENSE file.
+
+//! Provides Try-trait for stable rust
+//!
+//! Probably doesn't work with `?`-desugaring. If the `nightly` feature is
+//! enabled for this crate, the `std` version is enabled.
+
+#[cfg(not(feature = "nightly"))]
+pub use stable::{FromResidual, Try};
+#[cfg(feature = "nightly")]
+pub use std::ops::{FromResidual, Try};
+
+mod stable {
+    use std::{convert, ops::ControlFlow, task::Poll};
+
+    pub trait Try: FromResidual {
+        type Output;
+        type Residual;
+
+        fn from_output(output: Self::Output) -> Self;
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;
+    }
+
+    pub trait FromResidual<R = <Self as Try>::Residual> {
+        fn from_residual(residual: R) -> Self;
+    }
+
+    impl<B, C> Try for ControlFlow<B, C> {
+        type Output = C;
+        type Residual = ControlFlow<B, convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            ControlFlow::Continue(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                ControlFlow::Continue(c) => ControlFlow::Continue(c),
+                ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),
+            }
+        }
+    }
+
+    impl<B, C> FromResidual for ControlFlow<B, C> {
+        #[inline]
+        fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {
+            match residual {
+                ControlFlow::Break(b) => ControlFlow::Break(b),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T> Try for Option<T> {
+        type Output = T;
+        type Residual = Option<convert::Infallible>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Some(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Some(v) => ControlFlow::Continue(v),
+                None => ControlFlow::Break(None),
+            }
+        }
+    }
+
+    impl<T> FromResidual for Option<T> {
+        #[inline]
+        fn from_residual(residual: Option<convert::Infallible>) -> Self {
+            match residual {
+                None => None,
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Result<T, E> {
+        type Output = T;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(output: Self::Output) -> Self {
+            Ok(output)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Ok(v) => ControlFlow::Continue(v),
+                Err(e) => ControlFlow::Break(Err(e)),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
+        #[inline]
+        fn from_residual(residual: Result<convert::Infallible, E>) -> Self {
+            match residual {
+                Err(e) => Err(From::from(e)),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Option<Result<T, E>>> {
+        type Output = Poll<Option<T>>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(|x| x.map(Ok))
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),
+                Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),
+                Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Option<Result<T, F>>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Some(Err(From::from(e)))),
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    impl<T, E> Try for Poll<Result<T, E>> {
+        type Output = Poll<T>;
+        type Residual = Result<convert::Infallible, E>;
+
+        #[inline]
+        fn from_output(c: Self::Output) -> Self {
+            c.map(Ok)
+        }
+
+        #[inline]
+        fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
+            match self {
+                Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),
+                Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),
+                Poll::Pending => ControlFlow::Continue(Poll::Pending),
+            }
+        }
+    }
+
+    impl<T, E, F: From<E>> FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {
+        #[inline]
+        fn from_residual(x: Result<convert::Infallible, E>) -> Self {
+            match x {
+                Err(e) => Poll::Ready(Err(From::from(e))),
+                _ => unreachable!(),
+            }
+        }
+    }
+}
diff --git a/test/Cargo.toml b/test/Cargo.toml
index 4106f1fb..151eb9c8 100644
--- a/test/Cargo.toml
+++ b/test/Cargo.toml
@@ -14,7 +14,7 @@ replication-v3 = ["librad/replication-v3"]
 
 [dependencies]
 assert_cmd = "2"
-assert_matches = "1"
+assert_matches = "1.5.0"
 anyhow = "1"
 async-stream = "0.3"
 async-trait = "0"
@@ -112,6 +112,9 @@ path = "../git-ext"
 [dependencies.radicle-git-helpers]
 path = "../git-helpers"
 
+[dependencies.radicle-std-ext]
+path = "../std-ext"
+
 [dependencies.rand]
 version = "0.8"
 features = [ "small_rng" ]
diff --git a/test/src/lib.rs b/test/src/lib.rs
index 47ab36ce..15441c6c 100644
--- a/test/src/lib.rs
+++ b/test/src/lib.rs
@@ -3,11 +3,9 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-#![feature(bool_to_option)]
-#![feature(never_type)]
-#![feature(assert_matches)]
-#![feature(path_try_exists)]
-
+#[cfg(test)]
+#[macro_use]
+extern crate assert_matches;
 #[macro_use]
 extern crate lazy_static;
 #[cfg(test)]
@@ -19,6 +17,7 @@ extern crate futures_await_test;
 #[cfg(test)]
 #[macro_use]
 extern crate link_canonical;
+extern crate radicle_std_ext as std_ext;
 
 #[macro_use]
 pub mod daemon;
diff --git a/test/src/librad/git.rs b/test/src/librad/git.rs
index d07a06c1..f9295e6f 100644
--- a/test/src/librad/git.rs
+++ b/test/src/librad/git.rs
@@ -7,12 +7,12 @@ use std::io;
 
 use anyhow::anyhow;
 use either::Either::*;
-
 use librad::{
     git::{identities, storage::Storage, Urn},
     identities::{payload, *},
     SecretKey,
 };
+use std_ext::Void;
 
 use crate::tempdir::WithTmpDir;
 
@@ -236,7 +236,7 @@ impl<'a> Project<'a> {
 
     pub fn verify<F>(&self, lookup: F) -> Result<VerifiedProject, error::VerifyProject>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         self.dev
             .git
@@ -246,7 +246,7 @@ impl<'a> Project<'a> {
 
     pub fn assert_verifies<F>(&self, lookup: F) -> anyhow::Result<()>
     where
-        F: Fn(Urn) -> Result<git2::Oid, !>,
+        F: Fn(Urn) -> Result<git2::Oid, Void>,
     {
         let verified = self.verify(lookup)?.into_inner();
         anyhow::ensure!(
diff --git a/test/src/ssh.rs b/test/src/ssh.rs
index 239c46fc..5dc78f53 100644
--- a/test/src/ssh.rs
+++ b/test/src/ssh.rs
@@ -3,10 +3,7 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use std::{
-    fs,
-    process::{Command, Stdio},
-};
+use std::process::{Command, Stdio};
 
 use rad_clib::keys::ssh::SshAuthSock;
 
@@ -32,7 +29,6 @@ pub fn with_ssh_agent<F, T>(callback: F) -> anyhow::Result<T>
 where
     F: FnOnce(SshAuthSock) -> anyhow::Result<T>,
 {
-    fs::try_exists("ssh-agent").expect("`ssh-agent` was not found, it is needed to run this test");
     let sock = ssh_auth_sock();
     let path = match &*sock {
         SshAuthSock::Uds(path) => path,
diff --git a/test/src/test/integration/daemon/gossip.rs b/test/src/test/integration/daemon/gossip.rs
index d96fddc5..91ab1575 100644
--- a/test/src/test/integration/daemon/gossip.rs
+++ b/test/src/test/integration/daemon/gossip.rs
@@ -5,7 +5,6 @@
 
 use std::time::{Duration, SystemTime};
 
-use assert_matches::assert_matches;
 use futures::{future, StreamExt as _};
 use tokio::time::timeout;
 
@@ -188,18 +187,19 @@ fn can_ask_and_clone_project() -> Result<(), anyhow::Error> {
 
         let alice_tracked = state::tracked(&alice_peer.peer, urn.clone()).await?;
 
-        assert_matches!(
-            alice_tracked.first().unwrap(),
+        match alice_tracked.first().unwrap() {
             radicle_daemon::project::peer::Peer::Remote {
                 peer_id,
-                status: radicle_daemon::project::peer::Status::Replicated(
-                    radicle_daemon::project::peer::Replicated { role, .. }
-                ),
+                status:
+                    radicle_daemon::project::peer::Status::Replicated(
+                        radicle_daemon::project::peer::Replicated { role, .. },
+                    ),
             } => {
-                assert_eq!(*peer_id, bob_peer.peer_id);
-                assert_eq!(*role, radicle_daemon::project::peer::Role::Tracker);
-            }
-        );
+                assert_eq!(peer_id, &bob_peer.peer_id);
+                assert_eq!(role, &radicle_daemon::project::peer::Role::Tracker);
+            },
+            _ => unreachable!(),
+        }
 
         Ok(())
     })
diff --git a/test/src/test/integration/daemon/replication.rs b/test/src/test/integration/daemon/replication.rs
index c265892f..8cbf550b 100644
--- a/test/src/test/integration/daemon/replication.rs
+++ b/test/src/test/integration/daemon/replication.rs
@@ -5,7 +5,6 @@
 
 use std::convert::TryFrom;
 
-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;
 
 use librad::{
diff --git a/test/src/test/integration/daemon/working_copy.rs b/test/src/test/integration/daemon/working_copy.rs
index 3e2ea9ae..ac4aa7da 100644
--- a/test/src/test/integration/daemon/working_copy.rs
+++ b/test/src/test/integration/daemon/working_copy.rs
@@ -3,10 +3,8 @@
 // This file is part of radicle-link, distributed under the GPLv3 with Radicle
 // Linking Exception. For full terms see the included LICENSE file.
 
-use radicle_daemon::{project::checkout, state, RunConfig};
-
-use assert_matches::assert_matches;
 use pretty_assertions::assert_eq;
+use radicle_daemon::{project::checkout, state, RunConfig};
 
 use crate::{
     daemon::common::{blocking, shia_le_pathbuf, Harness},
diff --git a/test/src/test/integration/librad/scenario/collaboration.rs b/test/src/test/integration/librad/scenario/collaboration.rs
index 4eb34bd5..ec0a933f 100644
--- a/test/src/test/integration/librad/scenario/collaboration.rs
+++ b/test/src/test/integration/librad/scenario/collaboration.rs
@@ -35,7 +35,7 @@ fn can_add_maintainer() {
 
         let proj = {
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/collaborative_objects.rs b/test/src/test/integration/librad/scenario/collaborative_objects.rs
index 5ee0c2f6..51c3a75b 100644
--- a/test/src/test/integration/librad/scenario/collaborative_objects.rs
+++ b/test/src/test/integration/librad/scenario/collaborative_objects.rs
@@ -86,7 +86,7 @@ fn collab_object_crud() {
         let peer2 = net.peers().index(1);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/menage.rs b/test/src/test/integration/librad/scenario/menage.rs
index 0e4b7a6f..c4238a7e 100644
--- a/test/src/test/integration/librad/scenario/menage.rs
+++ b/test/src/test/integration/librad/scenario/menage.rs
@@ -84,7 +84,7 @@ fn a_trois() {
         let peer3 = net.peers().index(2);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -234,7 +234,7 @@ fn threes_a_crowd() {
         }
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/tracked_references.rs b/test/src/test/integration/librad/scenario/tracked_references.rs
index 7ed57b63..d0593d63 100644
--- a/test/src/test/integration/librad/scenario/tracked_references.rs
+++ b/test/src/test/integration/librad/scenario/tracked_references.rs
@@ -58,7 +58,7 @@ fn can_see_tracked_references() {
         let peer2 = net.peers().index(1);
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/scenario/updated_delegate.rs b/test/src/test/integration/librad/scenario/updated_delegate.rs
index 6733dafb..cfaf5c5b 100644
--- a/test/src/test/integration/librad/scenario/updated_delegate.rs
+++ b/test/src/test/integration/librad/scenario/updated_delegate.rs
@@ -39,7 +39,7 @@ fn can_replicate_with_updated_delegate() {
 
         let person = {
             let person = peer1
-                .using_storage(move |storage| TestPerson::create(storage))
+                .using_storage(TestPerson::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/scenario/working_copy.rs b/test/src/test/integration/librad/scenario/working_copy.rs
index cbaa0fa3..77e1e090 100644
--- a/test/src/test/integration/librad/scenario/working_copy.rs
+++ b/test/src/test/integration/librad/scenario/working_copy.rs
@@ -78,7 +78,7 @@ fn can_fetch() {
         let peer2_events = peer2.subscribe();
 
         let proj = peer1
-            .using_storage(move |store| TestProject::create(store))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/integration/librad/smoke/clone.rs b/test/src/test/integration/librad/smoke/clone.rs
index f67a8cbe..e6f3d87f 100644
--- a/test/src/test/integration/librad/smoke/clone.rs
+++ b/test/src/test/integration/librad/smoke/clone.rs
@@ -147,7 +147,7 @@ struct Host<'a> {
 impl<'a> Host<'a> {
     async fn init(peer: &'a RunningTestPeer) -> Host<'a> {
         let project = peer
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -170,7 +170,7 @@ impl Leecher<'_> {
                 (
                     host_peer,
                     supply_addr_hints
-                        .then_some(host_addrs)
+                        .then(|| host_addrs)
                         .into_iter()
                         .flatten()
                         .collect(),
diff --git a/test/src/test/integration/librad/smoke/gossip.rs b/test/src/test/integration/librad/smoke/gossip.rs
index fdf169de..c06a4983 100644
--- a/test/src/test/integration/librad/smoke/gossip.rs
+++ b/test/src/test/integration/librad/smoke/gossip.rs
@@ -60,7 +60,7 @@ fn fetches_on_gossip_notify() {
         let peer1 = net.peers().index(0);
         let peer2 = net.peers().index(1);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
@@ -201,7 +201,7 @@ fn ask_and_clone() {
         let proj = {
             let events = peer1.subscribe();
             let proj = peer1
-                .using_storage(move |storage| TestProject::create(storage))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/interrogation.rs b/test/src/test/integration/librad/smoke/interrogation.rs
index 617daae9..227496b1 100644
--- a/test/src/test/integration/librad/smoke/interrogation.rs
+++ b/test/src/test/integration/librad/smoke/interrogation.rs
@@ -38,7 +38,7 @@ fn responds() {
         let TestProject { project, owner } = {
             let events = responder.subscribe();
             let proj = responder
-                .using_storage(move |s| TestProject::create(s))
+                .using_storage(TestProject::create)
                 .await
                 .unwrap()
                 .unwrap();
diff --git a/test/src/test/integration/librad/smoke/regression.rs b/test/src/test/integration/librad/smoke/regression.rs
index 3b85c15a..9600d8a0 100644
--- a/test/src/test/integration/librad/smoke/regression.rs
+++ b/test/src/test/integration/librad/smoke/regression.rs
@@ -31,7 +31,7 @@ fn list_identities_returns_only_local_projects() {
         let peer2 = net.peers().index(1);
         let peer3 = net.peers().index(2);
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
diff --git a/test/src/test/properties/librad/identities/generic.rs b/test/src/test/properties/librad/identities/generic.rs
index c21d488d..b5a2edfb 100644
--- a/test/src/test/properties/librad/identities/generic.rs
+++ b/test/src/test/properties/librad/identities/generic.rs
@@ -5,15 +5,15 @@
 
 use std::collections::BTreeMap;
 
-use nonempty::NonEmpty;
-use proptest::prelude::*;
-
 use librad::identities::{
     delegation::Delegations,
     generic::{error, Doc, Identity},
     sign::Signatures,
     Verifying,
 };
+use nonempty::NonEmpty;
+use proptest::prelude::*;
+use std_ext::Void;
 
 use crate::librad::identities::generic::*;
 
@@ -175,7 +175,7 @@ proptest! {
             tail[tail.len() - 1].clone()
         };
         let folded = root
-            .verify(tail.into_iter().map(|x| Ok::<_, !>(Verifying::from(x))))
+            .verify(tail.into_iter().map(|x| Ok::<_, Void>(Verifying::from(x))))
             .unwrap();
 
         assert_eq!(folded.head.into_inner(), expected)
diff --git a/test/src/test/unit/librad/identities/git/project.rs b/test/src/test/unit/librad/identities/git/project.rs
index 0dfef7ea..0be415fd 100644
--- a/test/src/test/unit/librad/identities/git/project.rs
+++ b/test/src/test/unit/librad/identities/git/project.rs
@@ -6,7 +6,6 @@
 use std::collections::BTreeMap;
 
 use either::Either::*;
-
 use librad::{
     git::Urn,
     identities::{
@@ -19,6 +18,7 @@ use librad::{
     },
     SecretKey,
 };
+use std_ext::Void;
 
 use crate::librad::git::{repo, Device, Project};
 
@@ -354,6 +354,6 @@ fn current_heads_from<'a>(
         .collect()
 }
 
-fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, !> + '_ {
+fn lookup(map: &BTreeMap<Urn, git2::Oid>) -> impl Fn(Urn) -> Result<git2::Oid, Void> + '_ {
     move |urn| Ok(*map.get(&urn).unwrap())
 }
diff --git a/test/src/test/unit/librad/net/upgrade.rs b/test/src/test/unit/librad/net/upgrade.rs
index 715df4d5..90b88204 100644
--- a/test/src/test/unit/librad/net/upgrade.rs
+++ b/test/src/test/unit/librad/net/upgrade.rs
@@ -4,7 +4,6 @@
 // Linking Exception. For full terms see the included LICENSE file.
 
 use futures::try_join;
-
 use librad::{
     net::upgrade::{
         upgrade,
diff --git a/test/src/test/unit/rad_identities/git/checkout.rs b/test/src/test/unit/rad_identities/git/checkout.rs
index 9ce01c03..f2b39a9f 100644
--- a/test/src/test/unit/rad_identities/git/checkout.rs
+++ b/test/src/test/unit/rad_identities/git/checkout.rs
@@ -67,7 +67,7 @@ fn remote_checkout() {
         let temp = tempdir().unwrap();
 
         let proj = peer1
-            .using_storage(move |storage| TestProject::create(storage))
+            .using_storage(TestProject::create)
             .await
             .unwrap()
             .unwrap();
-- 
2.34.1



